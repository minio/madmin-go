package madmin

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"time"

	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Audit) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0003 uint32
	zb0003, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(Audit, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		zb0003--
		var zb0001 string
		var zb0002 Status
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0004 uint32
		zb0004, err = dc.ReadMapHeader()
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		var zb0004Mask uint8 /* 1 bits */
		_ = zb0004Mask
		for zb0004 > 0 {
			zb0004--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "status":
				zb0002.Status, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Status")
					return
				}
				zb0004Mask |= 0x1
			default:
				err = dc.Skip()
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
		// Clear omitted fields.
		if zb0004Mask != 0x1 {
			if (zb0004Mask & 0x1) == 0 {
				zb0002.Status = ""
			}
		}
		(*z)[zb0001] = zb0002
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Audit) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteMapHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0005, zb0006 := range z {
		err = en.WriteString(zb0005)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		// check for omitted fields
		zb0001Len := uint32(1)
		var zb0001Mask uint8 /* 1 bits */
		_ = zb0001Mask
		if zb0006.Status == "" {
			zb0001Len--
			zb0001Mask |= 0x1
		}
		// variable map header, size zb0001Len
		err = en.Append(0x80 | uint8(zb0001Len))
		if err != nil {
			return
		}
		if zb0001Len == 0 {
			return
		}
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "status"
			err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			if err != nil {
				return
			}
			err = en.WriteString(zb0006.Status)
			if err != nil {
				err = msgp.WrapError(err, zb0005, "Status")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Audit) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendMapHeader(o, uint32(len(z)))
	for zb0005, zb0006 := range z {
		o = msgp.AppendString(o, zb0005)
		// check for omitted fields
		zb0001Len := uint32(1)
		var zb0001Mask uint8 /* 1 bits */
		_ = zb0001Mask
		if zb0006.Status == "" {
			zb0001Len--
			zb0001Mask |= 0x1
		}
		// variable map header, size zb0001Len
		o = append(o, 0x80|uint8(zb0001Len))
		if zb0001Len == 0 {
			return
		}
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "status"
			o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			o = msgp.AppendString(o, zb0006.Status)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Audit) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(Audit, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		var zb0001 string
		var zb0002 Status
		zb0003--
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0004 uint32
		zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		var zb0004Mask uint8 /* 1 bits */
		_ = zb0004Mask
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "status":
				zb0002.Status, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Status")
					return
				}
				zb0004Mask |= 0x1
			default:
				bts, err = msgp.Skip(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
		// Clear omitted fields.
		if zb0004Mask != 0x1 {
			if (zb0004Mask & 0x1) == 0 {
				zb0002.Status = ""
			}
		}
		(*z)[zb0001] = zb0002
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Audit) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for zb0005, zb0006 := range z {
			_ = zb0006
			s += msgp.StringPrefixSize + len(zb0005) + 1 + 7 + msgp.StringPrefixSize + len(zb0006.Status)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BackendDisks) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0003 uint32
	zb0003, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(BackendDisks, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		zb0003--
		var zb0001 string
		var zb0002 int
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		zb0002, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		(*z)[zb0001] = zb0002
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z BackendDisks) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteMapHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0004, zb0005 := range z {
		err = en.WriteString(zb0004)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		err = en.WriteInt(zb0005)
		if err != nil {
			err = msgp.WrapError(err, zb0004)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BackendDisks) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendMapHeader(o, uint32(len(z)))
	for zb0004, zb0005 := range z {
		o = msgp.AppendString(o, zb0004)
		o = msgp.AppendInt(o, zb0005)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BackendDisks) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(BackendDisks, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		var zb0001 string
		var zb0002 int
		zb0003--
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		zb0002, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		(*z)[zb0001] = zb0002
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BackendDisks) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for zb0004, zb0005 := range z {
			_ = zb0005
			s += msgp.StringPrefixSize + len(zb0004) + msgp.IntSize
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BackendInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = BackendType(zb0002)
			}
		case "GatewayOnline":
			z.GatewayOnline, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "GatewayOnline")
				return
			}
		case "OnlineDisks":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "OnlineDisks")
				return
			}
			if z.OnlineDisks == nil {
				z.OnlineDisks = make(BackendDisks, zb0003)
			} else if len(z.OnlineDisks) > 0 {
				for key := range z.OnlineDisks {
					delete(z.OnlineDisks, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0001 string
				var za0002 int
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "OnlineDisks")
					return
				}
				za0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OnlineDisks", za0001)
					return
				}
				z.OnlineDisks[za0001] = za0002
			}
		case "OfflineDisks":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "OfflineDisks")
				return
			}
			if z.OfflineDisks == nil {
				z.OfflineDisks = make(BackendDisks, zb0004)
			} else if len(z.OfflineDisks) > 0 {
				for key := range z.OfflineDisks {
					delete(z.OfflineDisks, key)
				}
			}
			for zb0004 > 0 {
				zb0004--
				var za0003 string
				var za0004 int
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "OfflineDisks")
					return
				}
				za0004, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OfflineDisks", za0003)
					return
				}
				z.OfflineDisks[za0003] = za0004
			}
		case "StandardSCData":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "StandardSCData")
				return
			}
			if cap(z.StandardSCData) >= int(zb0005) {
				z.StandardSCData = (z.StandardSCData)[:zb0005]
			} else {
				z.StandardSCData = make([]int, zb0005)
			}
			for za0005 := range z.StandardSCData {
				z.StandardSCData[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StandardSCData", za0005)
					return
				}
			}
		case "StandardSCParities":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "StandardSCParities")
				return
			}
			if cap(z.StandardSCParities) >= int(zb0006) {
				z.StandardSCParities = (z.StandardSCParities)[:zb0006]
			} else {
				z.StandardSCParities = make([]int, zb0006)
			}
			for za0006 := range z.StandardSCParities {
				z.StandardSCParities[za0006], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StandardSCParities", za0006)
					return
				}
			}
		case "RRSCData":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "RRSCData")
				return
			}
			if cap(z.RRSCData) >= int(zb0007) {
				z.RRSCData = (z.RRSCData)[:zb0007]
			} else {
				z.RRSCData = make([]int, zb0007)
			}
			for za0007 := range z.RRSCData {
				z.RRSCData[za0007], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "RRSCData", za0007)
					return
				}
			}
		case "RRSCParities":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "RRSCParities")
				return
			}
			if cap(z.RRSCParities) >= int(zb0008) {
				z.RRSCParities = (z.RRSCParities)[:zb0008]
			} else {
				z.RRSCParities = make([]int, zb0008)
			}
			for za0008 := range z.RRSCParities {
				z.RRSCParities[za0008], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "RRSCParities", za0008)
					return
				}
			}
		case "TotalSets":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TotalSets")
				return
			}
			if cap(z.TotalSets) >= int(zb0009) {
				z.TotalSets = (z.TotalSets)[:zb0009]
			} else {
				z.TotalSets = make([]int, zb0009)
			}
			for za0009 := range z.TotalSets {
				z.TotalSets[za0009], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TotalSets", za0009)
					return
				}
			}
		case "DrivesPerSet":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DrivesPerSet")
				return
			}
			if cap(z.DrivesPerSet) >= int(zb0010) {
				z.DrivesPerSet = (z.DrivesPerSet)[:zb0010]
			} else {
				z.DrivesPerSet = make([]int, zb0010)
			}
			for za0010 := range z.DrivesPerSet {
				z.DrivesPerSet[za0010], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DrivesPerSet", za0010)
					return
				}
			}
		case "StandardSCParity":
			z.StandardSCParity, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StandardSCParity")
				return
			}
		case "RRSCParity":
			z.RRSCParity, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RRSCParity")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BackendInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 12
	// write "Type"
	err = en.Append(0x8c, 0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "GatewayOnline"
	err = en.Append(0xad, 0x47, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.GatewayOnline)
	if err != nil {
		err = msgp.WrapError(err, "GatewayOnline")
		return
	}
	// write "OnlineDisks"
	err = en.Append(0xab, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.OnlineDisks)))
	if err != nil {
		err = msgp.WrapError(err, "OnlineDisks")
		return
	}
	for za0001, za0002 := range z.OnlineDisks {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "OnlineDisks")
			return
		}
		err = en.WriteInt(za0002)
		if err != nil {
			err = msgp.WrapError(err, "OnlineDisks", za0001)
			return
		}
	}
	// write "OfflineDisks"
	err = en.Append(0xac, 0x4f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.OfflineDisks)))
	if err != nil {
		err = msgp.WrapError(err, "OfflineDisks")
		return
	}
	for za0003, za0004 := range z.OfflineDisks {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "OfflineDisks")
			return
		}
		err = en.WriteInt(za0004)
		if err != nil {
			err = msgp.WrapError(err, "OfflineDisks", za0003)
			return
		}
	}
	// write "StandardSCData"
	err = en.Append(0xae, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x53, 0x43, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.StandardSCData)))
	if err != nil {
		err = msgp.WrapError(err, "StandardSCData")
		return
	}
	for za0005 := range z.StandardSCData {
		err = en.WriteInt(z.StandardSCData[za0005])
		if err != nil {
			err = msgp.WrapError(err, "StandardSCData", za0005)
			return
		}
	}
	// write "StandardSCParities"
	err = en.Append(0xb2, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.StandardSCParities)))
	if err != nil {
		err = msgp.WrapError(err, "StandardSCParities")
		return
	}
	for za0006 := range z.StandardSCParities {
		err = en.WriteInt(z.StandardSCParities[za0006])
		if err != nil {
			err = msgp.WrapError(err, "StandardSCParities", za0006)
			return
		}
	}
	// write "RRSCData"
	err = en.Append(0xa8, 0x52, 0x52, 0x53, 0x43, 0x44, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.RRSCData)))
	if err != nil {
		err = msgp.WrapError(err, "RRSCData")
		return
	}
	for za0007 := range z.RRSCData {
		err = en.WriteInt(z.RRSCData[za0007])
		if err != nil {
			err = msgp.WrapError(err, "RRSCData", za0007)
			return
		}
	}
	// write "RRSCParities"
	err = en.Append(0xac, 0x52, 0x52, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.RRSCParities)))
	if err != nil {
		err = msgp.WrapError(err, "RRSCParities")
		return
	}
	for za0008 := range z.RRSCParities {
		err = en.WriteInt(z.RRSCParities[za0008])
		if err != nil {
			err = msgp.WrapError(err, "RRSCParities", za0008)
			return
		}
	}
	// write "TotalSets"
	err = en.Append(0xa9, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TotalSets)))
	if err != nil {
		err = msgp.WrapError(err, "TotalSets")
		return
	}
	for za0009 := range z.TotalSets {
		err = en.WriteInt(z.TotalSets[za0009])
		if err != nil {
			err = msgp.WrapError(err, "TotalSets", za0009)
			return
		}
	}
	// write "DrivesPerSet"
	err = en.Append(0xac, 0x44, 0x72, 0x69, 0x76, 0x65, 0x73, 0x50, 0x65, 0x72, 0x53, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DrivesPerSet)))
	if err != nil {
		err = msgp.WrapError(err, "DrivesPerSet")
		return
	}
	for za0010 := range z.DrivesPerSet {
		err = en.WriteInt(z.DrivesPerSet[za0010])
		if err != nil {
			err = msgp.WrapError(err, "DrivesPerSet", za0010)
			return
		}
	}
	// write "StandardSCParity"
	err = en.Append(0xb0, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StandardSCParity)
	if err != nil {
		err = msgp.WrapError(err, "StandardSCParity")
		return
	}
	// write "RRSCParity"
	err = en.Append(0xaa, 0x52, 0x52, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RRSCParity)
	if err != nil {
		err = msgp.WrapError(err, "RRSCParity")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BackendInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "Type"
	o = append(o, 0x8c, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, int(z.Type))
	// string "GatewayOnline"
	o = append(o, 0xad, 0x47, 0x61, 0x74, 0x65, 0x77, 0x61, 0x79, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65)
	o = msgp.AppendBool(o, z.GatewayOnline)
	// string "OnlineDisks"
	o = append(o, 0xab, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.OnlineDisks)))
	for za0001, za0002 := range z.OnlineDisks {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendInt(o, za0002)
	}
	// string "OfflineDisks"
	o = append(o, 0xac, 0x4f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.OfflineDisks)))
	for za0003, za0004 := range z.OfflineDisks {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendInt(o, za0004)
	}
	// string "StandardSCData"
	o = append(o, 0xae, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x53, 0x43, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendArrayHeader(o, uint32(len(z.StandardSCData)))
	for za0005 := range z.StandardSCData {
		o = msgp.AppendInt(o, z.StandardSCData[za0005])
	}
	// string "StandardSCParities"
	o = append(o, 0xb2, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.StandardSCParities)))
	for za0006 := range z.StandardSCParities {
		o = msgp.AppendInt(o, z.StandardSCParities[za0006])
	}
	// string "RRSCData"
	o = append(o, 0xa8, 0x52, 0x52, 0x53, 0x43, 0x44, 0x61, 0x74, 0x61)
	o = msgp.AppendArrayHeader(o, uint32(len(z.RRSCData)))
	for za0007 := range z.RRSCData {
		o = msgp.AppendInt(o, z.RRSCData[za0007])
	}
	// string "RRSCParities"
	o = append(o, 0xac, 0x52, 0x52, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.RRSCParities)))
	for za0008 := range z.RRSCParities {
		o = msgp.AppendInt(o, z.RRSCParities[za0008])
	}
	// string "TotalSets"
	o = append(o, 0xa9, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TotalSets)))
	for za0009 := range z.TotalSets {
		o = msgp.AppendInt(o, z.TotalSets[za0009])
	}
	// string "DrivesPerSet"
	o = append(o, 0xac, 0x44, 0x72, 0x69, 0x76, 0x65, 0x73, 0x50, 0x65, 0x72, 0x53, 0x65, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DrivesPerSet)))
	for za0010 := range z.DrivesPerSet {
		o = msgp.AppendInt(o, z.DrivesPerSet[za0010])
	}
	// string "StandardSCParity"
	o = append(o, 0xb0, 0x53, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.StandardSCParity)
	// string "RRSCParity"
	o = append(o, 0xaa, 0x52, 0x52, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.RRSCParity)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BackendInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = BackendType(zb0002)
			}
		case "GatewayOnline":
			z.GatewayOnline, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GatewayOnline")
				return
			}
		case "OnlineDisks":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OnlineDisks")
				return
			}
			if z.OnlineDisks == nil {
				z.OnlineDisks = make(BackendDisks, zb0003)
			} else if len(z.OnlineDisks) > 0 {
				for key := range z.OnlineDisks {
					delete(z.OnlineDisks, key)
				}
			}
			for zb0003 > 0 {
				var za0001 string
				var za0002 int
				zb0003--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OnlineDisks")
					return
				}
				za0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OnlineDisks", za0001)
					return
				}
				z.OnlineDisks[za0001] = za0002
			}
		case "OfflineDisks":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OfflineDisks")
				return
			}
			if z.OfflineDisks == nil {
				z.OfflineDisks = make(BackendDisks, zb0004)
			} else if len(z.OfflineDisks) > 0 {
				for key := range z.OfflineDisks {
					delete(z.OfflineDisks, key)
				}
			}
			for zb0004 > 0 {
				var za0003 string
				var za0004 int
				zb0004--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OfflineDisks")
					return
				}
				za0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OfflineDisks", za0003)
					return
				}
				z.OfflineDisks[za0003] = za0004
			}
		case "StandardSCData":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StandardSCData")
				return
			}
			if cap(z.StandardSCData) >= int(zb0005) {
				z.StandardSCData = (z.StandardSCData)[:zb0005]
			} else {
				z.StandardSCData = make([]int, zb0005)
			}
			for za0005 := range z.StandardSCData {
				z.StandardSCData[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StandardSCData", za0005)
					return
				}
			}
		case "StandardSCParities":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StandardSCParities")
				return
			}
			if cap(z.StandardSCParities) >= int(zb0006) {
				z.StandardSCParities = (z.StandardSCParities)[:zb0006]
			} else {
				z.StandardSCParities = make([]int, zb0006)
			}
			for za0006 := range z.StandardSCParities {
				z.StandardSCParities[za0006], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StandardSCParities", za0006)
					return
				}
			}
		case "RRSCData":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RRSCData")
				return
			}
			if cap(z.RRSCData) >= int(zb0007) {
				z.RRSCData = (z.RRSCData)[:zb0007]
			} else {
				z.RRSCData = make([]int, zb0007)
			}
			for za0007 := range z.RRSCData {
				z.RRSCData[za0007], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RRSCData", za0007)
					return
				}
			}
		case "RRSCParities":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RRSCParities")
				return
			}
			if cap(z.RRSCParities) >= int(zb0008) {
				z.RRSCParities = (z.RRSCParities)[:zb0008]
			} else {
				z.RRSCParities = make([]int, zb0008)
			}
			for za0008 := range z.RRSCParities {
				z.RRSCParities[za0008], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RRSCParities", za0008)
					return
				}
			}
		case "TotalSets":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSets")
				return
			}
			if cap(z.TotalSets) >= int(zb0009) {
				z.TotalSets = (z.TotalSets)[:zb0009]
			} else {
				z.TotalSets = make([]int, zb0009)
			}
			for za0009 := range z.TotalSets {
				z.TotalSets[za0009], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TotalSets", za0009)
					return
				}
			}
		case "DrivesPerSet":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DrivesPerSet")
				return
			}
			if cap(z.DrivesPerSet) >= int(zb0010) {
				z.DrivesPerSet = (z.DrivesPerSet)[:zb0010]
			} else {
				z.DrivesPerSet = make([]int, zb0010)
			}
			for za0010 := range z.DrivesPerSet {
				z.DrivesPerSet[za0010], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DrivesPerSet", za0010)
					return
				}
			}
		case "StandardSCParity":
			z.StandardSCParity, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StandardSCParity")
				return
			}
		case "RRSCParity":
			z.RRSCParity, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RRSCParity")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BackendInfo) Msgsize() (s int) {
	s = 1 + 5 + msgp.IntSize + 14 + msgp.BoolSize + 12 + msgp.MapHeaderSize
	if z.OnlineDisks != nil {
		for za0001, za0002 := range z.OnlineDisks {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.IntSize
		}
	}
	s += 13 + msgp.MapHeaderSize
	if z.OfflineDisks != nil {
		for za0003, za0004 := range z.OfflineDisks {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.IntSize
		}
	}
	s += 15 + msgp.ArrayHeaderSize + (len(z.StandardSCData) * (msgp.IntSize)) + 19 + msgp.ArrayHeaderSize + (len(z.StandardSCParities) * (msgp.IntSize)) + 9 + msgp.ArrayHeaderSize + (len(z.RRSCData) * (msgp.IntSize)) + 13 + msgp.ArrayHeaderSize + (len(z.RRSCParities) * (msgp.IntSize)) + 10 + msgp.ArrayHeaderSize + (len(z.TotalSets) * (msgp.IntSize)) + 13 + msgp.ArrayHeaderSize + (len(z.DrivesPerSet) * (msgp.IntSize)) + 17 + msgp.IntSize + 11 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BackendType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = BackendType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z BackendType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z BackendType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BackendType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = BackendType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z BackendType) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BucketUsageInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "size":
			z.Size, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "objectsPendingReplicationTotalSize":
			z.ReplicationPendingSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicationPendingSize")
				return
			}
		case "objectsFailedReplicationTotalSize":
			z.ReplicationFailedSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicationFailedSize")
				return
			}
		case "objectsReplicatedTotalSize":
			z.ReplicatedSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "objectReplicaTotalSize":
			z.ReplicaSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicaSize")
				return
			}
		case "objectsPendingReplicationCount":
			z.ReplicationPendingCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicationPendingCount")
				return
			}
		case "objectsFailedReplicationCount":
			z.ReplicationFailedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicationFailedCount")
				return
			}
		case "versionsCount":
			z.VersionsCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "VersionsCount")
				return
			}
		case "objectsCount":
			z.ObjectsCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsCount")
				return
			}
		case "deleteMarkersCount":
			z.DeleteMarkersCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersCount")
				return
			}
		case "objectsSizesHistogram":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ObjectSizesHistogram")
				return
			}
			if z.ObjectSizesHistogram == nil {
				z.ObjectSizesHistogram = make(map[string]uint64, zb0002)
			} else if len(z.ObjectSizesHistogram) > 0 {
				for key := range z.ObjectSizesHistogram {
					delete(z.ObjectSizesHistogram, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 uint64
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ObjectSizesHistogram")
					return
				}
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "ObjectSizesHistogram", za0001)
					return
				}
				z.ObjectSizesHistogram[za0001] = za0002
			}
		case "objectsVersionsHistogram":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ObjectVersionsHistogram")
				return
			}
			if z.ObjectVersionsHistogram == nil {
				z.ObjectVersionsHistogram = make(map[string]uint64, zb0003)
			} else if len(z.ObjectVersionsHistogram) > 0 {
				for key := range z.ObjectVersionsHistogram {
					delete(z.ObjectVersionsHistogram, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 uint64
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ObjectVersionsHistogram")
					return
				}
				za0004, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "ObjectVersionsHistogram", za0003)
					return
				}
				z.ObjectVersionsHistogram[za0003] = za0004
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BucketUsageInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 12
	// write "size"
	err = en.Append(0x8c, 0xa4, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Size)
	if err != nil {
		err = msgp.WrapError(err, "Size")
		return
	}
	// write "objectsPendingReplicationTotalSize"
	err = en.Append(0xd9, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicationPendingSize)
	if err != nil {
		err = msgp.WrapError(err, "ReplicationPendingSize")
		return
	}
	// write "objectsFailedReplicationTotalSize"
	err = en.Append(0xd9, 0x21, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicationFailedSize)
	if err != nil {
		err = msgp.WrapError(err, "ReplicationFailedSize")
		return
	}
	// write "objectsReplicatedTotalSize"
	err = en.Append(0xba, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicatedSize)
	if err != nil {
		err = msgp.WrapError(err, "ReplicatedSize")
		return
	}
	// write "objectReplicaTotalSize"
	err = en.Append(0xb6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicaSize)
	if err != nil {
		err = msgp.WrapError(err, "ReplicaSize")
		return
	}
	// write "objectsPendingReplicationCount"
	err = en.Append(0xbe, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicationPendingCount)
	if err != nil {
		err = msgp.WrapError(err, "ReplicationPendingCount")
		return
	}
	// write "objectsFailedReplicationCount"
	err = en.Append(0xbd, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicationFailedCount)
	if err != nil {
		err = msgp.WrapError(err, "ReplicationFailedCount")
		return
	}
	// write "versionsCount"
	err = en.Append(0xad, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.VersionsCount)
	if err != nil {
		err = msgp.WrapError(err, "VersionsCount")
		return
	}
	// write "objectsCount"
	err = en.Append(0xac, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsCount)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsCount")
		return
	}
	// write "deleteMarkersCount"
	err = en.Append(0xb2, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.DeleteMarkersCount)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkersCount")
		return
	}
	// write "objectsSizesHistogram"
	err = en.Append(0xb5, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x53, 0x69, 0x7a, 0x65, 0x73, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.ObjectSizesHistogram)))
	if err != nil {
		err = msgp.WrapError(err, "ObjectSizesHistogram")
		return
	}
	for za0001, za0002 := range z.ObjectSizesHistogram {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "ObjectSizesHistogram")
			return
		}
		err = en.WriteUint64(za0002)
		if err != nil {
			err = msgp.WrapError(err, "ObjectSizesHistogram", za0001)
			return
		}
	}
	// write "objectsVersionsHistogram"
	err = en.Append(0xb8, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.ObjectVersionsHistogram)))
	if err != nil {
		err = msgp.WrapError(err, "ObjectVersionsHistogram")
		return
	}
	for za0003, za0004 := range z.ObjectVersionsHistogram {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "ObjectVersionsHistogram")
			return
		}
		err = en.WriteUint64(za0004)
		if err != nil {
			err = msgp.WrapError(err, "ObjectVersionsHistogram", za0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BucketUsageInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "size"
	o = append(o, 0x8c, 0xa4, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.Size)
	// string "objectsPendingReplicationTotalSize"
	o = append(o, 0xd9, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ReplicationPendingSize)
	// string "objectsFailedReplicationTotalSize"
	o = append(o, 0xd9, 0x21, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ReplicationFailedSize)
	// string "objectsReplicatedTotalSize"
	o = append(o, 0xba, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ReplicatedSize)
	// string "objectReplicaTotalSize"
	o = append(o, 0xb6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ReplicaSize)
	// string "objectsPendingReplicationCount"
	o = append(o, 0xbe, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ReplicationPendingCount)
	// string "objectsFailedReplicationCount"
	o = append(o, 0xbd, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ReplicationFailedCount)
	// string "versionsCount"
	o = append(o, 0xad, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.VersionsCount)
	// string "objectsCount"
	o = append(o, 0xac, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ObjectsCount)
	// string "deleteMarkersCount"
	o = append(o, 0xb2, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.DeleteMarkersCount)
	// string "objectsSizesHistogram"
	o = append(o, 0xb5, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x53, 0x69, 0x7a, 0x65, 0x73, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d)
	o = msgp.AppendMapHeader(o, uint32(len(z.ObjectSizesHistogram)))
	for za0001, za0002 := range z.ObjectSizesHistogram {
		o = msgp.AppendString(o, za0001)
		o = msgp.AppendUint64(o, za0002)
	}
	// string "objectsVersionsHistogram"
	o = append(o, 0xb8, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x67, 0x72, 0x61, 0x6d)
	o = msgp.AppendMapHeader(o, uint32(len(z.ObjectVersionsHistogram)))
	for za0003, za0004 := range z.ObjectVersionsHistogram {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendUint64(o, za0004)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BucketUsageInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "size":
			z.Size, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "objectsPendingReplicationTotalSize":
			z.ReplicationPendingSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicationPendingSize")
				return
			}
		case "objectsFailedReplicationTotalSize":
			z.ReplicationFailedSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicationFailedSize")
				return
			}
		case "objectsReplicatedTotalSize":
			z.ReplicatedSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "objectReplicaTotalSize":
			z.ReplicaSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicaSize")
				return
			}
		case "objectsPendingReplicationCount":
			z.ReplicationPendingCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicationPendingCount")
				return
			}
		case "objectsFailedReplicationCount":
			z.ReplicationFailedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicationFailedCount")
				return
			}
		case "versionsCount":
			z.VersionsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionsCount")
				return
			}
		case "objectsCount":
			z.ObjectsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsCount")
				return
			}
		case "deleteMarkersCount":
			z.DeleteMarkersCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersCount")
				return
			}
		case "objectsSizesHistogram":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectSizesHistogram")
				return
			}
			if z.ObjectSizesHistogram == nil {
				z.ObjectSizesHistogram = make(map[string]uint64, zb0002)
			} else if len(z.ObjectSizesHistogram) > 0 {
				for key := range z.ObjectSizesHistogram {
					delete(z.ObjectSizesHistogram, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 uint64
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ObjectSizesHistogram")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ObjectSizesHistogram", za0001)
					return
				}
				z.ObjectSizesHistogram[za0001] = za0002
			}
		case "objectsVersionsHistogram":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectVersionsHistogram")
				return
			}
			if z.ObjectVersionsHistogram == nil {
				z.ObjectVersionsHistogram = make(map[string]uint64, zb0003)
			} else if len(z.ObjectVersionsHistogram) > 0 {
				for key := range z.ObjectVersionsHistogram {
					delete(z.ObjectVersionsHistogram, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 uint64
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ObjectVersionsHistogram")
					return
				}
				za0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ObjectVersionsHistogram", za0003)
					return
				}
				z.ObjectVersionsHistogram[za0003] = za0004
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BucketUsageInfo) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 36 + msgp.Uint64Size + 35 + msgp.Uint64Size + 27 + msgp.Uint64Size + 23 + msgp.Uint64Size + 31 + msgp.Uint64Size + 30 + msgp.Uint64Size + 14 + msgp.Uint64Size + 13 + msgp.Uint64Size + 19 + msgp.Uint64Size + 22 + msgp.MapHeaderSize
	if z.ObjectSizesHistogram != nil {
		for za0001, za0002 := range z.ObjectSizesHistogram {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 25 + msgp.MapHeaderSize
	if z.ObjectVersionsHistogram != nil {
		for za0003, za0004 := range z.ObjectVersionsHistogram {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.Uint64Size
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Buckets) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "error":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Buckets) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "count"
	err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "error"
		err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.Error)
		if err != nil {
			err = msgp.WrapError(err, "Error")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Buckets) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "count"
	o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.Count)
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "error"
		o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		o = msgp.AppendString(o, z.Error)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Buckets) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "error":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Buckets) Msgsize() (s int) {
	s = 1 + 6 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Error)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CacheStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "capacity":
			z.Capacity, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Capacity")
				return
			}
		case "used":
			z.Used, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
		case "hits":
			z.Hits, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Hits")
				return
			}
		case "misses":
			z.Misses, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Misses")
				return
			}
		case "delHits":
			z.DelHits, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DelHits")
				return
			}
		case "delMisses":
			z.DelMisses, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DelMisses")
				return
			}
		case "collisions":
			z.Collisions, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Collisions")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CacheStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "capacity"
	err = en.Append(0x87, 0xa8, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Capacity)
	if err != nil {
		err = msgp.WrapError(err, "Capacity")
		return
	}
	// write "used"
	err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Used)
	if err != nil {
		err = msgp.WrapError(err, "Used")
		return
	}
	// write "hits"
	err = en.Append(0xa4, 0x68, 0x69, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Hits)
	if err != nil {
		err = msgp.WrapError(err, "Hits")
		return
	}
	// write "misses"
	err = en.Append(0xa6, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Misses)
	if err != nil {
		err = msgp.WrapError(err, "Misses")
		return
	}
	// write "delHits"
	err = en.Append(0xa7, 0x64, 0x65, 0x6c, 0x48, 0x69, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DelHits)
	if err != nil {
		err = msgp.WrapError(err, "DelHits")
		return
	}
	// write "delMisses"
	err = en.Append(0xa9, 0x64, 0x65, 0x6c, 0x4d, 0x69, 0x73, 0x73, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DelMisses)
	if err != nil {
		err = msgp.WrapError(err, "DelMisses")
		return
	}
	// write "collisions"
	err = en.Append(0xaa, 0x63, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Collisions)
	if err != nil {
		err = msgp.WrapError(err, "Collisions")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CacheStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "capacity"
	o = append(o, 0x87, 0xa8, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	o = msgp.AppendInt64(o, z.Capacity)
	// string "used"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.Used)
	// string "hits"
	o = append(o, 0xa4, 0x68, 0x69, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Hits)
	// string "misses"
	o = append(o, 0xa6, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73)
	o = msgp.AppendInt64(o, z.Misses)
	// string "delHits"
	o = append(o, 0xa7, 0x64, 0x65, 0x6c, 0x48, 0x69, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.DelHits)
	// string "delMisses"
	o = append(o, 0xa9, 0x64, 0x65, 0x6c, 0x4d, 0x69, 0x73, 0x73, 0x65, 0x73)
	o = msgp.AppendInt64(o, z.DelMisses)
	// string "collisions"
	o = append(o, 0xaa, 0x63, 0x6f, 0x6c, 0x6c, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendInt64(o, z.Collisions)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CacheStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "capacity":
			z.Capacity, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Capacity")
				return
			}
		case "used":
			z.Used, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
		case "hits":
			z.Hits, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hits")
				return
			}
		case "misses":
			z.Misses, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Misses")
				return
			}
		case "delHits":
			z.DelHits, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DelHits")
				return
			}
		case "delMisses":
			z.DelMisses, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DelMisses")
				return
			}
		case "collisions":
			z.Collisions, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Collisions")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CacheStats) Msgsize() (s int) {
	s = 1 + 9 + msgp.Int64Size + 5 + msgp.Int64Size + 5 + msgp.Int64Size + 7 + msgp.Int64Size + 8 + msgp.Int64Size + 10 + msgp.Int64Size + 11 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DataUsageInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastUpdate":
			z.LastUpdate, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "objectsCount":
			z.ObjectsTotalCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalCount")
				return
			}
		case "objectsTotalSize":
			z.ObjectsTotalSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalSize")
				return
			}
		case "objectsPendingReplicationTotalSize":
			z.ReplicationPendingSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicationPendingSize")
				return
			}
		case "objectsFailedReplicationTotalSize":
			z.ReplicationFailedSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicationFailedSize")
				return
			}
		case "objectsReplicatedTotalSize":
			z.ReplicatedSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "objectsReplicaTotalSize":
			z.ReplicaSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicaSize")
				return
			}
		case "objectsPendingReplicationCount":
			z.ReplicationPendingCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicationPendingCount")
				return
			}
		case "objectsFailedReplicationCount":
			z.ReplicationFailedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicationFailedCount")
				return
			}
		case "bucketsCount":
			z.BucketsCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BucketsCount")
				return
			}
		case "bucketsUsageInfo":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "BucketsUsage")
				return
			}
			if z.BucketsUsage == nil {
				z.BucketsUsage = make(map[string]BucketUsageInfo, zb0002)
			} else if len(z.BucketsUsage) > 0 {
				for key := range z.BucketsUsage {
					delete(z.BucketsUsage, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 BucketUsageInfo
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BucketsUsage")
					return
				}
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "BucketsUsage", za0001)
					return
				}
				z.BucketsUsage[za0001] = za0002
			}
		case "tierStats":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "TierStats")
				return
			}
			if z.TierStats == nil {
				z.TierStats = make(map[string]TierStats, zb0003)
			} else if len(z.TierStats) > 0 {
				for key := range z.TierStats {
					delete(z.TierStats, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 TierStats
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "TierStats")
					return
				}
				var zb0004 uint32
				zb0004, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "TierStats", za0003)
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "TierStats", za0003)
						return
					}
					switch msgp.UnsafeString(field) {
					case "totalSize":
						za0004.TotalSize, err = dc.ReadUint64()
						if err != nil {
							err = msgp.WrapError(err, "TierStats", za0003, "TotalSize")
							return
						}
					case "numVersions":
						za0004.NumVersions, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "TierStats", za0003, "NumVersions")
							return
						}
					case "numObjects":
						za0004.NumObjects, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "TierStats", za0003, "NumObjects")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "TierStats", za0003)
							return
						}
					}
				}
				z.TierStats[za0003] = za0004
			}
		case "bucketsSizes":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "BucketSizes")
				return
			}
			if z.BucketSizes == nil {
				z.BucketSizes = make(map[string]uint64, zb0005)
			} else if len(z.BucketSizes) > 0 {
				for key := range z.BucketSizes {
					delete(z.BucketSizes, key)
				}
			}
			for zb0005 > 0 {
				zb0005--
				var za0005 string
				var za0006 uint64
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BucketSizes")
					return
				}
				za0006, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "BucketSizes", za0005)
					return
				}
				z.BucketSizes[za0005] = za0006
			}
		case "capacity":
			z.TotalCapacity, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalCapacity")
				return
			}
		case "freeCapacity":
			z.TotalFreeCapacity, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalFreeCapacity")
				return
			}
		case "usedCapacity":
			z.TotalUsedCapacity, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalUsedCapacity")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DataUsageInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 16
	// write "lastUpdate"
	err = en.Append(0xde, 0x0, 0x10, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastUpdate)
	if err != nil {
		err = msgp.WrapError(err, "LastUpdate")
		return
	}
	// write "objectsCount"
	err = en.Append(0xac, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsTotalCount)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsTotalCount")
		return
	}
	// write "objectsTotalSize"
	err = en.Append(0xb0, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsTotalSize)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsTotalSize")
		return
	}
	// write "objectsPendingReplicationTotalSize"
	err = en.Append(0xd9, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicationPendingSize)
	if err != nil {
		err = msgp.WrapError(err, "ReplicationPendingSize")
		return
	}
	// write "objectsFailedReplicationTotalSize"
	err = en.Append(0xd9, 0x21, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicationFailedSize)
	if err != nil {
		err = msgp.WrapError(err, "ReplicationFailedSize")
		return
	}
	// write "objectsReplicatedTotalSize"
	err = en.Append(0xba, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicatedSize)
	if err != nil {
		err = msgp.WrapError(err, "ReplicatedSize")
		return
	}
	// write "objectsReplicaTotalSize"
	err = en.Append(0xb7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicaSize)
	if err != nil {
		err = msgp.WrapError(err, "ReplicaSize")
		return
	}
	// write "objectsPendingReplicationCount"
	err = en.Append(0xbe, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicationPendingCount)
	if err != nil {
		err = msgp.WrapError(err, "ReplicationPendingCount")
		return
	}
	// write "objectsFailedReplicationCount"
	err = en.Append(0xbd, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReplicationFailedCount)
	if err != nil {
		err = msgp.WrapError(err, "ReplicationFailedCount")
		return
	}
	// write "bucketsCount"
	err = en.Append(0xac, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BucketsCount)
	if err != nil {
		err = msgp.WrapError(err, "BucketsCount")
		return
	}
	// write "bucketsUsageInfo"
	err = en.Append(0xb0, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x55, 0x73, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.BucketsUsage)))
	if err != nil {
		err = msgp.WrapError(err, "BucketsUsage")
		return
	}
	for za0001, za0002 := range z.BucketsUsage {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "BucketsUsage")
			return
		}
		err = za0002.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "BucketsUsage", za0001)
			return
		}
	}
	// write "tierStats"
	err = en.Append(0xa9, 0x74, 0x69, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.TierStats)))
	if err != nil {
		err = msgp.WrapError(err, "TierStats")
		return
	}
	for za0003, za0004 := range z.TierStats {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "TierStats")
			return
		}
		// map header, size 3
		// write "totalSize"
		err = en.Append(0x83, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteUint64(za0004.TotalSize)
		if err != nil {
			err = msgp.WrapError(err, "TierStats", za0003, "TotalSize")
			return
		}
		// write "numVersions"
		err = en.Append(0xab, 0x6e, 0x75, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(za0004.NumVersions)
		if err != nil {
			err = msgp.WrapError(err, "TierStats", za0003, "NumVersions")
			return
		}
		// write "numObjects"
		err = en.Append(0xaa, 0x6e, 0x75, 0x6d, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(za0004.NumObjects)
		if err != nil {
			err = msgp.WrapError(err, "TierStats", za0003, "NumObjects")
			return
		}
	}
	// write "bucketsSizes"
	err = en.Append(0xac, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x53, 0x69, 0x7a, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.BucketSizes)))
	if err != nil {
		err = msgp.WrapError(err, "BucketSizes")
		return
	}
	for za0005, za0006 := range z.BucketSizes {
		err = en.WriteString(za0005)
		if err != nil {
			err = msgp.WrapError(err, "BucketSizes")
			return
		}
		err = en.WriteUint64(za0006)
		if err != nil {
			err = msgp.WrapError(err, "BucketSizes", za0005)
			return
		}
	}
	// write "capacity"
	err = en.Append(0xa8, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalCapacity)
	if err != nil {
		err = msgp.WrapError(err, "TotalCapacity")
		return
	}
	// write "freeCapacity"
	err = en.Append(0xac, 0x66, 0x72, 0x65, 0x65, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalFreeCapacity)
	if err != nil {
		err = msgp.WrapError(err, "TotalFreeCapacity")
		return
	}
	// write "usedCapacity"
	err = en.Append(0xac, 0x75, 0x73, 0x65, 0x64, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalUsedCapacity)
	if err != nil {
		err = msgp.WrapError(err, "TotalUsedCapacity")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DataUsageInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 16
	// string "lastUpdate"
	o = append(o, 0xde, 0x0, 0x10, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
	o = msgp.AppendTime(o, z.LastUpdate)
	// string "objectsCount"
	o = append(o, 0xac, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ObjectsTotalCount)
	// string "objectsTotalSize"
	o = append(o, 0xb0, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ObjectsTotalSize)
	// string "objectsPendingReplicationTotalSize"
	o = append(o, 0xd9, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ReplicationPendingSize)
	// string "objectsFailedReplicationTotalSize"
	o = append(o, 0xd9, 0x21, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ReplicationFailedSize)
	// string "objectsReplicatedTotalSize"
	o = append(o, 0xba, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ReplicatedSize)
	// string "objectsReplicaTotalSize"
	o = append(o, 0xb7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ReplicaSize)
	// string "objectsPendingReplicationCount"
	o = append(o, 0xbe, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ReplicationPendingCount)
	// string "objectsFailedReplicationCount"
	o = append(o, 0xbd, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ReplicationFailedCount)
	// string "bucketsCount"
	o = append(o, 0xac, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.BucketsCount)
	// string "bucketsUsageInfo"
	o = append(o, 0xb0, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x55, 0x73, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f)
	o = msgp.AppendMapHeader(o, uint32(len(z.BucketsUsage)))
	for za0001, za0002 := range z.BucketsUsage {
		o = msgp.AppendString(o, za0001)
		o, err = za0002.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "BucketsUsage", za0001)
			return
		}
	}
	// string "tierStats"
	o = append(o, 0xa9, 0x74, 0x69, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.TierStats)))
	for za0003, za0004 := range z.TierStats {
		o = msgp.AppendString(o, za0003)
		// map header, size 3
		// string "totalSize"
		o = append(o, 0x83, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendUint64(o, za0004.TotalSize)
		// string "numVersions"
		o = append(o, 0xab, 0x6e, 0x75, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendInt(o, za0004.NumVersions)
		// string "numObjects"
		o = append(o, 0xaa, 0x6e, 0x75, 0x6d, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
		o = msgp.AppendInt(o, za0004.NumObjects)
	}
	// string "bucketsSizes"
	o = append(o, 0xac, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x53, 0x69, 0x7a, 0x65, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.BucketSizes)))
	for za0005, za0006 := range z.BucketSizes {
		o = msgp.AppendString(o, za0005)
		o = msgp.AppendUint64(o, za0006)
	}
	// string "capacity"
	o = append(o, 0xa8, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	o = msgp.AppendUint64(o, z.TotalCapacity)
	// string "freeCapacity"
	o = append(o, 0xac, 0x66, 0x72, 0x65, 0x65, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	o = msgp.AppendUint64(o, z.TotalFreeCapacity)
	// string "usedCapacity"
	o = append(o, 0xac, 0x75, 0x73, 0x65, 0x64, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	o = msgp.AppendUint64(o, z.TotalUsedCapacity)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DataUsageInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastUpdate":
			z.LastUpdate, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "objectsCount":
			z.ObjectsTotalCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalCount")
				return
			}
		case "objectsTotalSize":
			z.ObjectsTotalSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalSize")
				return
			}
		case "objectsPendingReplicationTotalSize":
			z.ReplicationPendingSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicationPendingSize")
				return
			}
		case "objectsFailedReplicationTotalSize":
			z.ReplicationFailedSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicationFailedSize")
				return
			}
		case "objectsReplicatedTotalSize":
			z.ReplicatedSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "objectsReplicaTotalSize":
			z.ReplicaSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicaSize")
				return
			}
		case "objectsPendingReplicationCount":
			z.ReplicationPendingCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicationPendingCount")
				return
			}
		case "objectsFailedReplicationCount":
			z.ReplicationFailedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicationFailedCount")
				return
			}
		case "bucketsCount":
			z.BucketsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BucketsCount")
				return
			}
		case "bucketsUsageInfo":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BucketsUsage")
				return
			}
			if z.BucketsUsage == nil {
				z.BucketsUsage = make(map[string]BucketUsageInfo, zb0002)
			} else if len(z.BucketsUsage) > 0 {
				for key := range z.BucketsUsage {
					delete(z.BucketsUsage, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 BucketUsageInfo
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BucketsUsage")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BucketsUsage", za0001)
					return
				}
				z.BucketsUsage[za0001] = za0002
			}
		case "tierStats":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TierStats")
				return
			}
			if z.TierStats == nil {
				z.TierStats = make(map[string]TierStats, zb0003)
			} else if len(z.TierStats) > 0 {
				for key := range z.TierStats {
					delete(z.TierStats, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 TierStats
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TierStats")
					return
				}
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TierStats", za0003)
					return
				}
				for zb0004 > 0 {
					zb0004--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "TierStats", za0003)
						return
					}
					switch msgp.UnsafeString(field) {
					case "totalSize":
						za0004.TotalSize, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "TierStats", za0003, "TotalSize")
							return
						}
					case "numVersions":
						za0004.NumVersions, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "TierStats", za0003, "NumVersions")
							return
						}
					case "numObjects":
						za0004.NumObjects, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "TierStats", za0003, "NumObjects")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "TierStats", za0003)
							return
						}
					}
				}
				z.TierStats[za0003] = za0004
			}
		case "bucketsSizes":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BucketSizes")
				return
			}
			if z.BucketSizes == nil {
				z.BucketSizes = make(map[string]uint64, zb0005)
			} else if len(z.BucketSizes) > 0 {
				for key := range z.BucketSizes {
					delete(z.BucketSizes, key)
				}
			}
			for zb0005 > 0 {
				var za0005 string
				var za0006 uint64
				zb0005--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BucketSizes")
					return
				}
				za0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BucketSizes", za0005)
					return
				}
				z.BucketSizes[za0005] = za0006
			}
		case "capacity":
			z.TotalCapacity, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalCapacity")
				return
			}
		case "freeCapacity":
			z.TotalFreeCapacity, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalFreeCapacity")
				return
			}
		case "usedCapacity":
			z.TotalUsedCapacity, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalUsedCapacity")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DataUsageInfo) Msgsize() (s int) {
	s = 3 + 11 + msgp.TimeSize + 13 + msgp.Uint64Size + 17 + msgp.Uint64Size + 36 + msgp.Uint64Size + 35 + msgp.Uint64Size + 27 + msgp.Uint64Size + 24 + msgp.Uint64Size + 31 + msgp.Uint64Size + 30 + msgp.Uint64Size + 13 + msgp.Uint64Size + 17 + msgp.MapHeaderSize
	if z.BucketsUsage != nil {
		for za0001, za0002 := range z.BucketsUsage {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += 10 + msgp.MapHeaderSize
	if z.TierStats != nil {
		for za0003, za0004 := range z.TierStats {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + 1 + 10 + msgp.Uint64Size + 12 + msgp.IntSize + 11 + msgp.IntSize
		}
	}
	s += 13 + msgp.MapHeaderSize
	if z.BucketSizes != nil {
		for za0005, za0006 := range z.BucketSizes {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + msgp.Uint64Size
		}
	}
	s += 9 + msgp.Uint64Size + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DeleteMarkers) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "error":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z DeleteMarkers) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "count"
	err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "error"
		err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.Error)
		if err != nil {
			err = msgp.WrapError(err, "Error")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z DeleteMarkers) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "count"
	o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.Count)
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "error"
		o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		o = msgp.AppendString(o, z.Error)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DeleteMarkers) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "error":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z DeleteMarkers) Msgsize() (s int) {
	s = 1 + 6 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Error)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Disk) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 21 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "endpoint":
			z.Endpoint, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
			zb0001Mask |= 0x1
		case "rootDisk":
			z.RootDisk, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "RootDisk")
				return
			}
			zb0001Mask |= 0x2
		case "path":
			z.DrivePath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DrivePath")
				return
			}
			zb0001Mask |= 0x4
		case "healing":
			z.Healing, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
			zb0001Mask |= 0x8
		case "scanning":
			z.Scanning, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Scanning")
				return
			}
			zb0001Mask |= 0x10
		case "state":
			z.State, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
			zb0001Mask |= 0x20
		case "uuid":
			z.UUID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UUID")
				return
			}
			zb0001Mask |= 0x40
		case "major":
			z.Major, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Major")
				return
			}
		case "minor":
			z.Minor, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Minor")
				return
			}
		case "model":
			z.Model, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Model")
				return
			}
			zb0001Mask |= 0x80
		case "totalspace":
			z.TotalSpace, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalSpace")
				return
			}
			zb0001Mask |= 0x100
		case "usedspace":
			z.UsedSpace, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "UsedSpace")
				return
			}
			zb0001Mask |= 0x200
		case "availspace":
			z.AvailableSpace, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "AvailableSpace")
				return
			}
			zb0001Mask |= 0x400
		case "readthroughput":
			z.ReadThroughput, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReadThroughput")
				return
			}
			zb0001Mask |= 0x800
		case "writethroughput":
			z.WriteThroughPut, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WriteThroughPut")
				return
			}
			zb0001Mask |= 0x1000
		case "readlatency":
			z.ReadLatency, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReadLatency")
				return
			}
			zb0001Mask |= 0x2000
		case "writelatency":
			z.WriteLatency, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WriteLatency")
				return
			}
			zb0001Mask |= 0x4000
		case "utilization":
			z.Utilization, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Utilization")
				return
			}
			zb0001Mask |= 0x8000
		case "metrics":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Metrics")
					return
				}
				z.Metrics = nil
			} else {
				if z.Metrics == nil {
					z.Metrics = new(DiskMetrics)
				}
				err = z.Metrics.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Metrics")
					return
				}
			}
			zb0001Mask |= 0x10000
		case "heal_info":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HealInfo")
					return
				}
				z.HealInfo = nil
			} else {
				if z.HealInfo == nil {
					z.HealInfo = new(HealingDisk)
				}
				err = z.HealInfo.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "HealInfo")
					return
				}
			}
			zb0001Mask |= 0x20000
		case "used_inodes":
			z.UsedInodes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes")
				return
			}
		case "free_inodes":
			z.FreeInodes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes")
				return
			}
			zb0001Mask |= 0x40000
		case "local":
			z.Local, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Local")
				return
			}
			zb0001Mask |= 0x80000
		case "cacheStats":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
				z.Cache = nil
			} else {
				if z.Cache == nil {
					z.Cache = new(CacheStats)
				}
				err = z.Cache.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
			}
			zb0001Mask |= 0x100000
		case "pool_index":
			z.PoolIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "disk_index":
			z.DiskIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DiskIndex")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1fffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Endpoint = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.RootDisk = false
		}
		if (zb0001Mask & 0x4) == 0 {
			z.DrivePath = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Healing = false
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Scanning = false
		}
		if (zb0001Mask & 0x20) == 0 {
			z.State = ""
		}
		if (zb0001Mask & 0x40) == 0 {
			z.UUID = ""
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Model = ""
		}
		if (zb0001Mask & 0x100) == 0 {
			z.TotalSpace = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.UsedSpace = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.AvailableSpace = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReadThroughput = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.WriteThroughPut = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.ReadLatency = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.WriteLatency = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.Utilization = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.Metrics = nil
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.HealInfo = nil
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.FreeInodes = 0
		}
		if (zb0001Mask & 0x80000) == 0 {
			z.Local = false
		}
		if (zb0001Mask & 0x100000) == 0 {
			z.Cache = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Disk) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(27)
	var zb0001Mask uint32 /* 27 bits */
	_ = zb0001Mask
	if z.Endpoint == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.RootDisk == false {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.DrivePath == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Healing == false {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Scanning == false {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.State == "" {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.UUID == "" {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Model == "" {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.TotalSpace == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.UsedSpace == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.AvailableSpace == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.ReadThroughput == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.WriteThroughPut == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.ReadLatency == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.WriteLatency == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.Utilization == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.Metrics == nil {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.HealInfo == nil {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.FreeInodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x200000
	}
	if z.Local == false {
		zb0001Len--
		zb0001Mask |= 0x400000
	}
	if z.Cache == nil {
		zb0001Len--
		zb0001Mask |= 0x800000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// write "endpoint"
		err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Endpoint)
		if err != nil {
			err = msgp.WrapError(err, "Endpoint")
			return
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "rootDisk"
		err = en.Append(0xa8, 0x72, 0x6f, 0x6f, 0x74, 0x44, 0x69, 0x73, 0x6b)
		if err != nil {
			return
		}
		err = en.WriteBool(z.RootDisk)
		if err != nil {
			err = msgp.WrapError(err, "RootDisk")
			return
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// write "path"
		err = en.Append(0xa4, 0x70, 0x61, 0x74, 0x68)
		if err != nil {
			return
		}
		err = en.WriteString(z.DrivePath)
		if err != nil {
			err = msgp.WrapError(err, "DrivePath")
			return
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// write "healing"
		err = en.Append(0xa7, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Healing)
		if err != nil {
			err = msgp.WrapError(err, "Healing")
			return
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// write "scanning"
		err = en.Append(0xa8, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x69, 0x6e, 0x67)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Scanning)
		if err != nil {
			err = msgp.WrapError(err, "Scanning")
			return
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// write "state"
		err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.State)
		if err != nil {
			err = msgp.WrapError(err, "State")
			return
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// write "uuid"
		err = en.Append(0xa4, 0x75, 0x75, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.UUID)
		if err != nil {
			err = msgp.WrapError(err, "UUID")
			return
		}
	}
	// write "major"
	err = en.Append(0xa5, 0x6d, 0x61, 0x6a, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Major)
	if err != nil {
		err = msgp.WrapError(err, "Major")
		return
	}
	// write "minor"
	err = en.Append(0xa5, 0x6d, 0x69, 0x6e, 0x6f, 0x72)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Minor)
	if err != nil {
		err = msgp.WrapError(err, "Minor")
		return
	}
	if (zb0001Mask & 0x200) == 0 { // if not omitted
		// write "model"
		err = en.Append(0xa5, 0x6d, 0x6f, 0x64, 0x65, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteString(z.Model)
		if err != nil {
			err = msgp.WrapError(err, "Model")
			return
		}
	}
	if (zb0001Mask & 0x400) == 0 { // if not omitted
		// write "totalspace"
		err = en.Append(0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x73, 0x70, 0x61, 0x63, 0x65)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.TotalSpace)
		if err != nil {
			err = msgp.WrapError(err, "TotalSpace")
			return
		}
	}
	if (zb0001Mask & 0x800) == 0 { // if not omitted
		// write "usedspace"
		err = en.Append(0xa9, 0x75, 0x73, 0x65, 0x64, 0x73, 0x70, 0x61, 0x63, 0x65)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.UsedSpace)
		if err != nil {
			err = msgp.WrapError(err, "UsedSpace")
			return
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not omitted
		// write "availspace"
		err = en.Append(0xaa, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x73, 0x70, 0x61, 0x63, 0x65)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.AvailableSpace)
		if err != nil {
			err = msgp.WrapError(err, "AvailableSpace")
			return
		}
	}
	if (zb0001Mask & 0x2000) == 0 { // if not omitted
		// write "readthroughput"
		err = en.Append(0xae, 0x72, 0x65, 0x61, 0x64, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x70, 0x75, 0x74)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.ReadThroughput)
		if err != nil {
			err = msgp.WrapError(err, "ReadThroughput")
			return
		}
	}
	if (zb0001Mask & 0x4000) == 0 { // if not omitted
		// write "writethroughput"
		err = en.Append(0xaf, 0x77, 0x72, 0x69, 0x74, 0x65, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x70, 0x75, 0x74)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.WriteThroughPut)
		if err != nil {
			err = msgp.WrapError(err, "WriteThroughPut")
			return
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not omitted
		// write "readlatency"
		err = en.Append(0xab, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.ReadLatency)
		if err != nil {
			err = msgp.WrapError(err, "ReadLatency")
			return
		}
	}
	if (zb0001Mask & 0x10000) == 0 { // if not omitted
		// write "writelatency"
		err = en.Append(0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.WriteLatency)
		if err != nil {
			err = msgp.WrapError(err, "WriteLatency")
			return
		}
	}
	if (zb0001Mask & 0x20000) == 0 { // if not omitted
		// write "utilization"
		err = en.Append(0xab, 0x75, 0x74, 0x69, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.Utilization)
		if err != nil {
			err = msgp.WrapError(err, "Utilization")
			return
		}
	}
	if (zb0001Mask & 0x40000) == 0 { // if not omitted
		// write "metrics"
		err = en.Append(0xa7, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
		if err != nil {
			return
		}
		if z.Metrics == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Metrics.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Metrics")
				return
			}
		}
	}
	if (zb0001Mask & 0x80000) == 0 { // if not omitted
		// write "heal_info"
		err = en.Append(0xa9, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x66, 0x6f)
		if err != nil {
			return
		}
		if z.HealInfo == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.HealInfo.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "HealInfo")
				return
			}
		}
	}
	// write "used_inodes"
	err = en.Append(0xab, 0x75, 0x73, 0x65, 0x64, 0x5f, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.UsedInodes)
	if err != nil {
		err = msgp.WrapError(err, "UsedInodes")
		return
	}
	if (zb0001Mask & 0x200000) == 0 { // if not omitted
		// write "free_inodes"
		err = en.Append(0xab, 0x66, 0x72, 0x65, 0x65, 0x5f, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.FreeInodes)
		if err != nil {
			err = msgp.WrapError(err, "FreeInodes")
			return
		}
	}
	if (zb0001Mask & 0x400000) == 0 { // if not omitted
		// write "local"
		err = en.Append(0xa5, 0x6c, 0x6f, 0x63, 0x61, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Local)
		if err != nil {
			err = msgp.WrapError(err, "Local")
			return
		}
	}
	if (zb0001Mask & 0x800000) == 0 { // if not omitted
		// write "cacheStats"
		err = en.Append(0xaa, 0x63, 0x61, 0x63, 0x68, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73)
		if err != nil {
			return
		}
		if z.Cache == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Cache.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
		}
	}
	// write "pool_index"
	err = en.Append(0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PoolIndex)
	if err != nil {
		err = msgp.WrapError(err, "PoolIndex")
		return
	}
	// write "set_index"
	err = en.Append(0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SetIndex)
	if err != nil {
		err = msgp.WrapError(err, "SetIndex")
		return
	}
	// write "disk_index"
	err = en.Append(0xaa, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DiskIndex)
	if err != nil {
		err = msgp.WrapError(err, "DiskIndex")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Disk) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(27)
	var zb0001Mask uint32 /* 27 bits */
	_ = zb0001Mask
	if z.Endpoint == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.RootDisk == false {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.DrivePath == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Healing == false {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Scanning == false {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.State == "" {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.UUID == "" {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Model == "" {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.TotalSpace == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.UsedSpace == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.AvailableSpace == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.ReadThroughput == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.WriteThroughPut == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.ReadLatency == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.WriteLatency == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.Utilization == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.Metrics == nil {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.HealInfo == nil {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.FreeInodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x200000
	}
	if z.Local == false {
		zb0001Len--
		zb0001Mask |= 0x400000
	}
	if z.Cache == nil {
		zb0001Len--
		zb0001Mask |= 0x800000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// string "endpoint"
		o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		o = msgp.AppendString(o, z.Endpoint)
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "rootDisk"
		o = append(o, 0xa8, 0x72, 0x6f, 0x6f, 0x74, 0x44, 0x69, 0x73, 0x6b)
		o = msgp.AppendBool(o, z.RootDisk)
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// string "path"
		o = append(o, 0xa4, 0x70, 0x61, 0x74, 0x68)
		o = msgp.AppendString(o, z.DrivePath)
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// string "healing"
		o = append(o, 0xa7, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67)
		o = msgp.AppendBool(o, z.Healing)
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// string "scanning"
		o = append(o, 0xa8, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x69, 0x6e, 0x67)
		o = msgp.AppendBool(o, z.Scanning)
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// string "state"
		o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
		o = msgp.AppendString(o, z.State)
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// string "uuid"
		o = append(o, 0xa4, 0x75, 0x75, 0x69, 0x64)
		o = msgp.AppendString(o, z.UUID)
	}
	// string "major"
	o = append(o, 0xa5, 0x6d, 0x61, 0x6a, 0x6f, 0x72)
	o = msgp.AppendUint32(o, z.Major)
	// string "minor"
	o = append(o, 0xa5, 0x6d, 0x69, 0x6e, 0x6f, 0x72)
	o = msgp.AppendUint32(o, z.Minor)
	if (zb0001Mask & 0x200) == 0 { // if not omitted
		// string "model"
		o = append(o, 0xa5, 0x6d, 0x6f, 0x64, 0x65, 0x6c)
		o = msgp.AppendString(o, z.Model)
	}
	if (zb0001Mask & 0x400) == 0 { // if not omitted
		// string "totalspace"
		o = append(o, 0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x73, 0x70, 0x61, 0x63, 0x65)
		o = msgp.AppendUint64(o, z.TotalSpace)
	}
	if (zb0001Mask & 0x800) == 0 { // if not omitted
		// string "usedspace"
		o = append(o, 0xa9, 0x75, 0x73, 0x65, 0x64, 0x73, 0x70, 0x61, 0x63, 0x65)
		o = msgp.AppendUint64(o, z.UsedSpace)
	}
	if (zb0001Mask & 0x1000) == 0 { // if not omitted
		// string "availspace"
		o = append(o, 0xaa, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x73, 0x70, 0x61, 0x63, 0x65)
		o = msgp.AppendUint64(o, z.AvailableSpace)
	}
	if (zb0001Mask & 0x2000) == 0 { // if not omitted
		// string "readthroughput"
		o = append(o, 0xae, 0x72, 0x65, 0x61, 0x64, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x70, 0x75, 0x74)
		o = msgp.AppendFloat64(o, z.ReadThroughput)
	}
	if (zb0001Mask & 0x4000) == 0 { // if not omitted
		// string "writethroughput"
		o = append(o, 0xaf, 0x77, 0x72, 0x69, 0x74, 0x65, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x70, 0x75, 0x74)
		o = msgp.AppendFloat64(o, z.WriteThroughPut)
	}
	if (zb0001Mask & 0x8000) == 0 { // if not omitted
		// string "readlatency"
		o = append(o, 0xab, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79)
		o = msgp.AppendFloat64(o, z.ReadLatency)
	}
	if (zb0001Mask & 0x10000) == 0 { // if not omitted
		// string "writelatency"
		o = append(o, 0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79)
		o = msgp.AppendFloat64(o, z.WriteLatency)
	}
	if (zb0001Mask & 0x20000) == 0 { // if not omitted
		// string "utilization"
		o = append(o, 0xab, 0x75, 0x74, 0x69, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e)
		o = msgp.AppendFloat64(o, z.Utilization)
	}
	if (zb0001Mask & 0x40000) == 0 { // if not omitted
		// string "metrics"
		o = append(o, 0xa7, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
		if z.Metrics == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Metrics.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Metrics")
				return
			}
		}
	}
	if (zb0001Mask & 0x80000) == 0 { // if not omitted
		// string "heal_info"
		o = append(o, 0xa9, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x6e, 0x66, 0x6f)
		if z.HealInfo == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.HealInfo.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "HealInfo")
				return
			}
		}
	}
	// string "used_inodes"
	o = append(o, 0xab, 0x75, 0x73, 0x65, 0x64, 0x5f, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.UsedInodes)
	if (zb0001Mask & 0x200000) == 0 { // if not omitted
		// string "free_inodes"
		o = append(o, 0xab, 0x66, 0x72, 0x65, 0x65, 0x5f, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		o = msgp.AppendUint64(o, z.FreeInodes)
	}
	if (zb0001Mask & 0x400000) == 0 { // if not omitted
		// string "local"
		o = append(o, 0xa5, 0x6c, 0x6f, 0x63, 0x61, 0x6c)
		o = msgp.AppendBool(o, z.Local)
	}
	if (zb0001Mask & 0x800000) == 0 { // if not omitted
		// string "cacheStats"
		o = append(o, 0xaa, 0x63, 0x61, 0x63, 0x68, 0x65, 0x53, 0x74, 0x61, 0x74, 0x73)
		if z.Cache == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Cache.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
		}
	}
	// string "pool_index"
	o = append(o, 0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.PoolIndex)
	// string "set_index"
	o = append(o, 0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.SetIndex)
	// string "disk_index"
	o = append(o, 0xaa, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.DiskIndex)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Disk) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 21 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "endpoint":
			z.Endpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
			zb0001Mask |= 0x1
		case "rootDisk":
			z.RootDisk, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RootDisk")
				return
			}
			zb0001Mask |= 0x2
		case "path":
			z.DrivePath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DrivePath")
				return
			}
			zb0001Mask |= 0x4
		case "healing":
			z.Healing, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
			zb0001Mask |= 0x8
		case "scanning":
			z.Scanning, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Scanning")
				return
			}
			zb0001Mask |= 0x10
		case "state":
			z.State, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
			zb0001Mask |= 0x20
		case "uuid":
			z.UUID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UUID")
				return
			}
			zb0001Mask |= 0x40
		case "major":
			z.Major, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Major")
				return
			}
		case "minor":
			z.Minor, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Minor")
				return
			}
		case "model":
			z.Model, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Model")
				return
			}
			zb0001Mask |= 0x80
		case "totalspace":
			z.TotalSpace, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSpace")
				return
			}
			zb0001Mask |= 0x100
		case "usedspace":
			z.UsedSpace, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UsedSpace")
				return
			}
			zb0001Mask |= 0x200
		case "availspace":
			z.AvailableSpace, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AvailableSpace")
				return
			}
			zb0001Mask |= 0x400
		case "readthroughput":
			z.ReadThroughput, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadThroughput")
				return
			}
			zb0001Mask |= 0x800
		case "writethroughput":
			z.WriteThroughPut, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteThroughPut")
				return
			}
			zb0001Mask |= 0x1000
		case "readlatency":
			z.ReadLatency, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadLatency")
				return
			}
			zb0001Mask |= 0x2000
		case "writelatency":
			z.WriteLatency, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteLatency")
				return
			}
			zb0001Mask |= 0x4000
		case "utilization":
			z.Utilization, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Utilization")
				return
			}
			zb0001Mask |= 0x8000
		case "metrics":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Metrics = nil
			} else {
				if z.Metrics == nil {
					z.Metrics = new(DiskMetrics)
				}
				bts, err = z.Metrics.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Metrics")
					return
				}
			}
			zb0001Mask |= 0x10000
		case "heal_info":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HealInfo = nil
			} else {
				if z.HealInfo == nil {
					z.HealInfo = new(HealingDisk)
				}
				bts, err = z.HealInfo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "HealInfo")
					return
				}
			}
			zb0001Mask |= 0x20000
		case "used_inodes":
			z.UsedInodes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes")
				return
			}
		case "free_inodes":
			z.FreeInodes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes")
				return
			}
			zb0001Mask |= 0x40000
		case "local":
			z.Local, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Local")
				return
			}
			zb0001Mask |= 0x80000
		case "cacheStats":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Cache = nil
			} else {
				if z.Cache == nil {
					z.Cache = new(CacheStats)
				}
				bts, err = z.Cache.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
			}
			zb0001Mask |= 0x100000
		case "pool_index":
			z.PoolIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "disk_index":
			z.DiskIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiskIndex")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1fffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Endpoint = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.RootDisk = false
		}
		if (zb0001Mask & 0x4) == 0 {
			z.DrivePath = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Healing = false
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Scanning = false
		}
		if (zb0001Mask & 0x20) == 0 {
			z.State = ""
		}
		if (zb0001Mask & 0x40) == 0 {
			z.UUID = ""
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Model = ""
		}
		if (zb0001Mask & 0x100) == 0 {
			z.TotalSpace = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.UsedSpace = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.AvailableSpace = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReadThroughput = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.WriteThroughPut = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.ReadLatency = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.WriteLatency = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.Utilization = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.Metrics = nil
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.HealInfo = nil
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.FreeInodes = 0
		}
		if (zb0001Mask & 0x80000) == 0 {
			z.Local = false
		}
		if (zb0001Mask & 0x100000) == 0 {
			z.Cache = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Disk) Msgsize() (s int) {
	s = 3 + 9 + msgp.StringPrefixSize + len(z.Endpoint) + 9 + msgp.BoolSize + 5 + msgp.StringPrefixSize + len(z.DrivePath) + 8 + msgp.BoolSize + 9 + msgp.BoolSize + 6 + msgp.StringPrefixSize + len(z.State) + 5 + msgp.StringPrefixSize + len(z.UUID) + 6 + msgp.Uint32Size + 6 + msgp.Uint32Size + 6 + msgp.StringPrefixSize + len(z.Model) + 11 + msgp.Uint64Size + 10 + msgp.Uint64Size + 11 + msgp.Uint64Size + 15 + msgp.Float64Size + 16 + msgp.Float64Size + 12 + msgp.Float64Size + 13 + msgp.Float64Size + 12 + msgp.Float64Size + 8
	if z.Metrics == nil {
		s += msgp.NilSize
	} else {
		s += z.Metrics.Msgsize()
	}
	s += 10
	if z.HealInfo == nil {
		s += msgp.NilSize
	} else {
		s += z.HealInfo.Msgsize()
	}
	s += 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 6 + msgp.BoolSize + 11
	if z.Cache == nil {
		s += msgp.NilSize
	} else {
		s += z.Cache.Msgsize()
	}
	s += 11 + msgp.IntSize + 10 + msgp.IntSize + 11 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DiskMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastMinute":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			if z.LastMinute == nil {
				z.LastMinute = make(map[string]TimedAction, zb0002)
			} else if len(z.LastMinute) > 0 {
				for key := range z.LastMinute {
					delete(z.LastMinute, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 TimedAction
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0001)
					return
				}
				z.LastMinute[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "apiCalls":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "APICalls")
				return
			}
			if z.APICalls == nil {
				z.APICalls = make(map[string]uint64, zb0003)
			} else if len(z.APICalls) > 0 {
				for key := range z.APICalls {
					delete(z.APICalls, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 uint64
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "APICalls")
					return
				}
				za0004, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "APICalls", za0003)
					return
				}
				z.APICalls[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "totalTokens":
			z.TotalTokens, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "TotalTokens")
				return
			}
			zb0001Mask |= 0x4
		case "totalWaiting":
			z.TotalWaiting, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "TotalWaiting")
				return
			}
			zb0001Mask |= 0x8
		case "totalErrorsAvailability":
			z.TotalErrorsAvailability, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalErrorsAvailability")
				return
			}
			zb0001Mask |= 0x10
		case "totalErrorsTimeout":
			z.TotalErrorsTimeout, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalErrorsTimeout")
				return
			}
			zb0001Mask |= 0x20
		case "totalWrites":
			z.TotalWrites, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalWrites")
				return
			}
			zb0001Mask |= 0x40
		case "totalDeletes":
			z.TotalDeletes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalDeletes")
				return
			}
			zb0001Mask |= 0x80
		case "apiLatencies":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "APILatencies")
				return
			}
			if z.APILatencies == nil {
				z.APILatencies = make(map[string]interface{}, zb0004)
			} else if len(z.APILatencies) > 0 {
				for key := range z.APILatencies {
					delete(z.APILatencies, key)
				}
			}
			for zb0004 > 0 {
				zb0004--
				var za0005 string
				var za0006 interface{}
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "APILatencies")
					return
				}
				za0006, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "APILatencies", za0005)
					return
				}
				z.APILatencies[za0005] = za0006
			}
			zb0001Mask |= 0x100
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ff {
		if (zb0001Mask & 0x1) == 0 {
			z.LastMinute = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.APICalls = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.TotalTokens = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.TotalWaiting = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.TotalErrorsAvailability = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.TotalErrorsTimeout = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.TotalWrites = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.TotalDeletes = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.APILatencies = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DiskMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.LastMinute == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.APICalls == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.TotalTokens == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.TotalWaiting == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TotalErrorsAvailability == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TotalErrorsTimeout == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TotalWrites == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.TotalDeletes == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.APILatencies == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// write "lastMinute"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteMapHeader(uint32(len(z.LastMinute)))
		if err != nil {
			err = msgp.WrapError(err, "LastMinute")
			return
		}
		for za0001, za0002 := range z.LastMinute {
			err = en.WriteString(za0001)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			err = za0002.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute", za0001)
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "apiCalls"
		err = en.Append(0xa8, 0x61, 0x70, 0x69, 0x43, 0x61, 0x6c, 0x6c, 0x73)
		if err != nil {
			return
		}
		err = en.WriteMapHeader(uint32(len(z.APICalls)))
		if err != nil {
			err = msgp.WrapError(err, "APICalls")
			return
		}
		for za0003, za0004 := range z.APICalls {
			err = en.WriteString(za0003)
			if err != nil {
				err = msgp.WrapError(err, "APICalls")
				return
			}
			err = en.WriteUint64(za0004)
			if err != nil {
				err = msgp.WrapError(err, "APICalls", za0003)
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// write "totalTokens"
		err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x73)
		if err != nil {
			return
		}
		err = en.WriteUint32(z.TotalTokens)
		if err != nil {
			err = msgp.WrapError(err, "TotalTokens")
			return
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// write "totalWaiting"
		err = en.Append(0xac, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x57, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67)
		if err != nil {
			return
		}
		err = en.WriteUint32(z.TotalWaiting)
		if err != nil {
			err = msgp.WrapError(err, "TotalWaiting")
			return
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// write "totalErrorsAvailability"
		err = en.Append(0xb7, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.TotalErrorsAvailability)
		if err != nil {
			err = msgp.WrapError(err, "TotalErrorsAvailability")
			return
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// write "totalErrorsTimeout"
		err = en.Append(0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.TotalErrorsTimeout)
		if err != nil {
			err = msgp.WrapError(err, "TotalErrorsTimeout")
			return
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// write "totalWrites"
		err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.TotalWrites)
		if err != nil {
			err = msgp.WrapError(err, "TotalWrites")
			return
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// write "totalDeletes"
		err = en.Append(0xac, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.TotalDeletes)
		if err != nil {
			err = msgp.WrapError(err, "TotalDeletes")
			return
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not omitted
		// write "apiLatencies"
		err = en.Append(0xac, 0x61, 0x70, 0x69, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x69, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteMapHeader(uint32(len(z.APILatencies)))
		if err != nil {
			err = msgp.WrapError(err, "APILatencies")
			return
		}
		for za0005, za0006 := range z.APILatencies {
			err = en.WriteString(za0005)
			if err != nil {
				err = msgp.WrapError(err, "APILatencies")
				return
			}
			err = en.WriteIntf(za0006)
			if err != nil {
				err = msgp.WrapError(err, "APILatencies", za0005)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DiskMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.LastMinute == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.APICalls == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.TotalTokens == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.TotalWaiting == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TotalErrorsAvailability == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TotalErrorsTimeout == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TotalWrites == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.TotalDeletes == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.APILatencies == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// string "lastMinute"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute)))
		for za0001, za0002 := range z.LastMinute {
			o = msgp.AppendString(o, za0001)
			o, err = za0002.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute", za0001)
				return
			}
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "apiCalls"
		o = append(o, 0xa8, 0x61, 0x70, 0x69, 0x43, 0x61, 0x6c, 0x6c, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.APICalls)))
		for za0003, za0004 := range z.APICalls {
			o = msgp.AppendString(o, za0003)
			o = msgp.AppendUint64(o, za0004)
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// string "totalTokens"
		o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x73)
		o = msgp.AppendUint32(o, z.TotalTokens)
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// string "totalWaiting"
		o = append(o, 0xac, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x57, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67)
		o = msgp.AppendUint32(o, z.TotalWaiting)
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// string "totalErrorsAvailability"
		o = append(o, 0xb7, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
		o = msgp.AppendUint64(o, z.TotalErrorsAvailability)
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// string "totalErrorsTimeout"
		o = append(o, 0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74)
		o = msgp.AppendUint64(o, z.TotalErrorsTimeout)
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// string "totalWrites"
		o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x57, 0x72, 0x69, 0x74, 0x65, 0x73)
		o = msgp.AppendUint64(o, z.TotalWrites)
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// string "totalDeletes"
		o = append(o, 0xac, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x73)
		o = msgp.AppendUint64(o, z.TotalDeletes)
	}
	if (zb0001Mask & 0x100) == 0 { // if not omitted
		// string "apiLatencies"
		o = append(o, 0xac, 0x61, 0x70, 0x69, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x69, 0x65, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.APILatencies)))
		for za0005, za0006 := range z.APILatencies {
			o = msgp.AppendString(o, za0005)
			o, err = msgp.AppendIntf(o, za0006)
			if err != nil {
				err = msgp.WrapError(err, "APILatencies", za0005)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DiskMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastMinute":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			if z.LastMinute == nil {
				z.LastMinute = make(map[string]TimedAction, zb0002)
			} else if len(z.LastMinute) > 0 {
				for key := range z.LastMinute {
					delete(z.LastMinute, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 TimedAction
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0001)
					return
				}
				z.LastMinute[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "apiCalls":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "APICalls")
				return
			}
			if z.APICalls == nil {
				z.APICalls = make(map[string]uint64, zb0003)
			} else if len(z.APICalls) > 0 {
				for key := range z.APICalls {
					delete(z.APICalls, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 uint64
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "APICalls")
					return
				}
				za0004, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "APICalls", za0003)
					return
				}
				z.APICalls[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "totalTokens":
			z.TotalTokens, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalTokens")
				return
			}
			zb0001Mask |= 0x4
		case "totalWaiting":
			z.TotalWaiting, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalWaiting")
				return
			}
			zb0001Mask |= 0x8
		case "totalErrorsAvailability":
			z.TotalErrorsAvailability, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalErrorsAvailability")
				return
			}
			zb0001Mask |= 0x10
		case "totalErrorsTimeout":
			z.TotalErrorsTimeout, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalErrorsTimeout")
				return
			}
			zb0001Mask |= 0x20
		case "totalWrites":
			z.TotalWrites, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalWrites")
				return
			}
			zb0001Mask |= 0x40
		case "totalDeletes":
			z.TotalDeletes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalDeletes")
				return
			}
			zb0001Mask |= 0x80
		case "apiLatencies":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "APILatencies")
				return
			}
			if z.APILatencies == nil {
				z.APILatencies = make(map[string]interface{}, zb0004)
			} else if len(z.APILatencies) > 0 {
				for key := range z.APILatencies {
					delete(z.APILatencies, key)
				}
			}
			for zb0004 > 0 {
				var za0005 string
				var za0006 interface{}
				zb0004--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "APILatencies")
					return
				}
				za0006, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "APILatencies", za0005)
					return
				}
				z.APILatencies[za0005] = za0006
			}
			zb0001Mask |= 0x100
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ff {
		if (zb0001Mask & 0x1) == 0 {
			z.LastMinute = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.APICalls = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.TotalTokens = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.TotalWaiting = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.TotalErrorsAvailability = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.TotalErrorsTimeout = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.TotalWrites = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.TotalDeletes = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.APILatencies = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DiskMetrics) Msgsize() (s int) {
	s = 1 + 11 + msgp.MapHeaderSize
	if z.LastMinute != nil {
		for za0001, za0002 := range z.LastMinute {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += 9 + msgp.MapHeaderSize
	if z.APICalls != nil {
		for za0003, za0004 := range z.APICalls {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.Uint64Size
		}
	}
	s += 12 + msgp.Uint32Size + 13 + msgp.Uint32Size + 24 + msgp.Uint64Size + 19 + msgp.Uint64Size + 12 + msgp.Uint64Size + 13 + msgp.Uint64Size + 13 + msgp.MapHeaderSize
	if z.APILatencies != nil {
		for za0005, za0006 := range z.APILatencies {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + msgp.GuessSize(za0006)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ErasureBackend) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "backendType":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = backendType(zb0002)
			}
		case "onlineDisks":
			z.OnlineDisks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OnlineDisks")
				return
			}
		case "offlineDisks":
			z.OfflineDisks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OfflineDisks")
				return
			}
		case "standardSCParity":
			z.StandardSCParity, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StandardSCParity")
				return
			}
		case "rrSCParity":
			z.RRSCParity, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RRSCParity")
				return
			}
		case "totalSets":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TotalSets")
				return
			}
			if cap(z.TotalSets) >= int(zb0003) {
				z.TotalSets = (z.TotalSets)[:zb0003]
			} else {
				z.TotalSets = make([]int, zb0003)
			}
			for za0001 := range z.TotalSets {
				z.TotalSets[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TotalSets", za0001)
					return
				}
			}
		case "totalDrivesPerSet":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DrivesPerSet")
				return
			}
			if cap(z.DrivesPerSet) >= int(zb0004) {
				z.DrivesPerSet = (z.DrivesPerSet)[:zb0004]
			} else {
				z.DrivesPerSet = make([]int, zb0004)
			}
			for za0002 := range z.DrivesPerSet {
				z.DrivesPerSet[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DrivesPerSet", za0002)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ErasureBackend) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "backendType"
	err = en.Append(0x87, 0xab, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "onlineDisks"
	err = en.Append(0xab, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.OnlineDisks)
	if err != nil {
		err = msgp.WrapError(err, "OnlineDisks")
		return
	}
	// write "offlineDisks"
	err = en.Append(0xac, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.OfflineDisks)
	if err != nil {
		err = msgp.WrapError(err, "OfflineDisks")
		return
	}
	// write "standardSCParity"
	err = en.Append(0xb0, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StandardSCParity)
	if err != nil {
		err = msgp.WrapError(err, "StandardSCParity")
		return
	}
	// write "rrSCParity"
	err = en.Append(0xaa, 0x72, 0x72, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RRSCParity)
	if err != nil {
		err = msgp.WrapError(err, "RRSCParity")
		return
	}
	// write "totalSets"
	err = en.Append(0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TotalSets)))
	if err != nil {
		err = msgp.WrapError(err, "TotalSets")
		return
	}
	for za0001 := range z.TotalSets {
		err = en.WriteInt(z.TotalSets[za0001])
		if err != nil {
			err = msgp.WrapError(err, "TotalSets", za0001)
			return
		}
	}
	// write "totalDrivesPerSet"
	err = en.Append(0xb1, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x72, 0x69, 0x76, 0x65, 0x73, 0x50, 0x65, 0x72, 0x53, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DrivesPerSet)))
	if err != nil {
		err = msgp.WrapError(err, "DrivesPerSet")
		return
	}
	for za0002 := range z.DrivesPerSet {
		err = en.WriteInt(z.DrivesPerSet[za0002])
		if err != nil {
			err = msgp.WrapError(err, "DrivesPerSet", za0002)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ErasureBackend) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "backendType"
	o = append(o, 0x87, 0xab, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "onlineDisks"
	o = append(o, 0xab, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendInt(o, z.OnlineDisks)
	// string "offlineDisks"
	o = append(o, 0xac, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendInt(o, z.OfflineDisks)
	// string "standardSCParity"
	o = append(o, 0xb0, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.StandardSCParity)
	// string "rrSCParity"
	o = append(o, 0xaa, 0x72, 0x72, 0x53, 0x43, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.RRSCParity)
	// string "totalSets"
	o = append(o, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TotalSets)))
	for za0001 := range z.TotalSets {
		o = msgp.AppendInt(o, z.TotalSets[za0001])
	}
	// string "totalDrivesPerSet"
	o = append(o, 0xb1, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x44, 0x72, 0x69, 0x76, 0x65, 0x73, 0x50, 0x65, 0x72, 0x53, 0x65, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DrivesPerSet)))
	for za0002 := range z.DrivesPerSet {
		o = msgp.AppendInt(o, z.DrivesPerSet[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ErasureBackend) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "backendType":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = backendType(zb0002)
			}
		case "onlineDisks":
			z.OnlineDisks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OnlineDisks")
				return
			}
		case "offlineDisks":
			z.OfflineDisks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OfflineDisks")
				return
			}
		case "standardSCParity":
			z.StandardSCParity, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StandardSCParity")
				return
			}
		case "rrSCParity":
			z.RRSCParity, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RRSCParity")
				return
			}
		case "totalSets":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSets")
				return
			}
			if cap(z.TotalSets) >= int(zb0003) {
				z.TotalSets = (z.TotalSets)[:zb0003]
			} else {
				z.TotalSets = make([]int, zb0003)
			}
			for za0001 := range z.TotalSets {
				z.TotalSets[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TotalSets", za0001)
					return
				}
			}
		case "totalDrivesPerSet":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DrivesPerSet")
				return
			}
			if cap(z.DrivesPerSet) >= int(zb0004) {
				z.DrivesPerSet = (z.DrivesPerSet)[:zb0004]
			} else {
				z.DrivesPerSet = make([]int, zb0004)
			}
			for za0002 := range z.DrivesPerSet {
				z.DrivesPerSet[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DrivesPerSet", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ErasureBackend) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(string(z.Type)) + 12 + msgp.IntSize + 13 + msgp.IntSize + 17 + msgp.IntSize + 11 + msgp.IntSize + 10 + msgp.ArrayHeaderSize + (len(z.TotalSets) * (msgp.IntSize)) + 18 + msgp.ArrayHeaderSize + (len(z.DrivesPerSet) * (msgp.IntSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ErasureSetInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "rawUsage":
			z.RawUsage, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RawUsage")
				return
			}
		case "rawCapacity":
			z.RawCapacity, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RawCapacity")
				return
			}
		case "usage":
			z.Usage, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Usage")
				return
			}
		case "objectsCount":
			z.ObjectsCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsCount")
				return
			}
		case "versionsCount":
			z.VersionsCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "VersionsCount")
				return
			}
		case "deleteMarkersCount":
			z.DeleteMarkersCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersCount")
				return
			}
		case "healDisks":
			z.HealDisks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HealDisks")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ErasureSetInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "id"
	err = en.Append(0x88, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "rawUsage"
	err = en.Append(0xa8, 0x72, 0x61, 0x77, 0x55, 0x73, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.RawUsage)
	if err != nil {
		err = msgp.WrapError(err, "RawUsage")
		return
	}
	// write "rawCapacity"
	err = en.Append(0xab, 0x72, 0x61, 0x77, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.RawCapacity)
	if err != nil {
		err = msgp.WrapError(err, "RawCapacity")
		return
	}
	// write "usage"
	err = en.Append(0xa5, 0x75, 0x73, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Usage)
	if err != nil {
		err = msgp.WrapError(err, "Usage")
		return
	}
	// write "objectsCount"
	err = en.Append(0xac, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsCount)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsCount")
		return
	}
	// write "versionsCount"
	err = en.Append(0xad, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.VersionsCount)
	if err != nil {
		err = msgp.WrapError(err, "VersionsCount")
		return
	}
	// write "deleteMarkersCount"
	err = en.Append(0xb2, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.DeleteMarkersCount)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkersCount")
		return
	}
	// write "healDisks"
	err = en.Append(0xa9, 0x68, 0x65, 0x61, 0x6c, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HealDisks)
	if err != nil {
		err = msgp.WrapError(err, "HealDisks")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ErasureSetInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "id"
	o = append(o, 0x88, 0xa2, 0x69, 0x64)
	o = msgp.AppendInt(o, z.ID)
	// string "rawUsage"
	o = append(o, 0xa8, 0x72, 0x61, 0x77, 0x55, 0x73, 0x61, 0x67, 0x65)
	o = msgp.AppendUint64(o, z.RawUsage)
	// string "rawCapacity"
	o = append(o, 0xab, 0x72, 0x61, 0x77, 0x43, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79)
	o = msgp.AppendUint64(o, z.RawCapacity)
	// string "usage"
	o = append(o, 0xa5, 0x75, 0x73, 0x61, 0x67, 0x65)
	o = msgp.AppendUint64(o, z.Usage)
	// string "objectsCount"
	o = append(o, 0xac, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ObjectsCount)
	// string "versionsCount"
	o = append(o, 0xad, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.VersionsCount)
	// string "deleteMarkersCount"
	o = append(o, 0xb2, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.DeleteMarkersCount)
	// string "healDisks"
	o = append(o, 0xa9, 0x68, 0x65, 0x61, 0x6c, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendInt(o, z.HealDisks)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ErasureSetInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "rawUsage":
			z.RawUsage, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RawUsage")
				return
			}
		case "rawCapacity":
			z.RawCapacity, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RawCapacity")
				return
			}
		case "usage":
			z.Usage, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Usage")
				return
			}
		case "objectsCount":
			z.ObjectsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsCount")
				return
			}
		case "versionsCount":
			z.VersionsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionsCount")
				return
			}
		case "deleteMarkersCount":
			z.DeleteMarkersCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersCount")
				return
			}
		case "healDisks":
			z.HealDisks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealDisks")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ErasureSetInfo) Msgsize() (s int) {
	s = 1 + 3 + msgp.IntSize + 9 + msgp.Uint64Size + 12 + msgp.Uint64Size + 6 + msgp.Uint64Size + 13 + msgp.Uint64Size + 14 + msgp.Uint64Size + 19 + msgp.Uint64Size + 10 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *FSBackend) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "backendType":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = backendType(zb0002)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z FSBackend) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "backendType"
	err = en.Append(0x81, 0xab, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z FSBackend) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "backendType"
	o = append(o, 0x81, 0xab, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FSBackend) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "backendType":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = backendType(zb0002)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z FSBackend) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(string(z.Type))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GCStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "last_gc":
			z.LastGC, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastGC")
				return
			}
		case "num_gc":
			z.NumGC, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "NumGC")
				return
			}
		case "pause_total":
			z.PauseTotal, err = dc.ReadDuration()
			if err != nil {
				err = msgp.WrapError(err, "PauseTotal")
				return
			}
		case "pause":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Pause")
				return
			}
			if cap(z.Pause) >= int(zb0002) {
				z.Pause = (z.Pause)[:zb0002]
			} else {
				z.Pause = make([]time.Duration, zb0002)
			}
			for za0001 := range z.Pause {
				z.Pause[za0001], err = dc.ReadDuration()
				if err != nil {
					err = msgp.WrapError(err, "Pause", za0001)
					return
				}
			}
		case "pause_end":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PauseEnd")
				return
			}
			if cap(z.PauseEnd) >= int(zb0003) {
				z.PauseEnd = (z.PauseEnd)[:zb0003]
			} else {
				z.PauseEnd = make([]time.Time, zb0003)
			}
			for za0002 := range z.PauseEnd {
				z.PauseEnd[za0002], err = dc.ReadTime()
				if err != nil {
					err = msgp.WrapError(err, "PauseEnd", za0002)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GCStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "last_gc"
	err = en.Append(0x85, 0xa7, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x67, 0x63)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastGC)
	if err != nil {
		err = msgp.WrapError(err, "LastGC")
		return
	}
	// write "num_gc"
	err = en.Append(0xa6, 0x6e, 0x75, 0x6d, 0x5f, 0x67, 0x63)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.NumGC)
	if err != nil {
		err = msgp.WrapError(err, "NumGC")
		return
	}
	// write "pause_total"
	err = en.Append(0xab, 0x70, 0x61, 0x75, 0x73, 0x65, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteDuration(z.PauseTotal)
	if err != nil {
		err = msgp.WrapError(err, "PauseTotal")
		return
	}
	// write "pause"
	err = en.Append(0xa5, 0x70, 0x61, 0x75, 0x73, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Pause)))
	if err != nil {
		err = msgp.WrapError(err, "Pause")
		return
	}
	for za0001 := range z.Pause {
		err = en.WriteDuration(z.Pause[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Pause", za0001)
			return
		}
	}
	// write "pause_end"
	err = en.Append(0xa9, 0x70, 0x61, 0x75, 0x73, 0x65, 0x5f, 0x65, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PauseEnd)))
	if err != nil {
		err = msgp.WrapError(err, "PauseEnd")
		return
	}
	for za0002 := range z.PauseEnd {
		err = en.WriteTime(z.PauseEnd[za0002])
		if err != nil {
			err = msgp.WrapError(err, "PauseEnd", za0002)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GCStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "last_gc"
	o = append(o, 0x85, 0xa7, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x67, 0x63)
	o = msgp.AppendTime(o, z.LastGC)
	// string "num_gc"
	o = append(o, 0xa6, 0x6e, 0x75, 0x6d, 0x5f, 0x67, 0x63)
	o = msgp.AppendInt64(o, z.NumGC)
	// string "pause_total"
	o = append(o, 0xab, 0x70, 0x61, 0x75, 0x73, 0x65, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c)
	o = msgp.AppendDuration(o, z.PauseTotal)
	// string "pause"
	o = append(o, 0xa5, 0x70, 0x61, 0x75, 0x73, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Pause)))
	for za0001 := range z.Pause {
		o = msgp.AppendDuration(o, z.Pause[za0001])
	}
	// string "pause_end"
	o = append(o, 0xa9, 0x70, 0x61, 0x75, 0x73, 0x65, 0x5f, 0x65, 0x6e, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PauseEnd)))
	for za0002 := range z.PauseEnd {
		o = msgp.AppendTime(o, z.PauseEnd[za0002])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GCStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "last_gc":
			z.LastGC, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastGC")
				return
			}
		case "num_gc":
			z.NumGC, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumGC")
				return
			}
		case "pause_total":
			z.PauseTotal, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PauseTotal")
				return
			}
		case "pause":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pause")
				return
			}
			if cap(z.Pause) >= int(zb0002) {
				z.Pause = (z.Pause)[:zb0002]
			} else {
				z.Pause = make([]time.Duration, zb0002)
			}
			for za0001 := range z.Pause {
				z.Pause[za0001], bts, err = msgp.ReadDurationBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pause", za0001)
					return
				}
			}
		case "pause_end":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PauseEnd")
				return
			}
			if cap(z.PauseEnd) >= int(zb0003) {
				z.PauseEnd = (z.PauseEnd)[:zb0003]
			} else {
				z.PauseEnd = make([]time.Time, zb0003)
			}
			for za0002 := range z.PauseEnd {
				z.PauseEnd[za0002], bts, err = msgp.ReadTimeBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PauseEnd", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GCStats) Msgsize() (s int) {
	s = 1 + 8 + msgp.TimeSize + 7 + msgp.Int64Size + 12 + msgp.DurationSize + 6 + msgp.ArrayHeaderSize + (len(z.Pause) * (msgp.DurationSize)) + 10 + msgp.ArrayHeaderSize + (len(z.PauseEnd) * (msgp.TimeSize))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *InfoMessage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "mode":
			z.Mode, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
			zb0001Mask |= 0x1
		case "domain":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Domain")
				return
			}
			if cap(z.Domain) >= int(zb0002) {
				z.Domain = (z.Domain)[:zb0002]
			} else {
				z.Domain = make([]string, zb0002)
			}
			for za0001 := range z.Domain {
				z.Domain[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Domain", za0001)
					return
				}
			}
			zb0001Mask |= 0x2
		case "region":
			z.Region, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Region")
				return
			}
			zb0001Mask |= 0x4
		case "sqsARN":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SQSARN")
				return
			}
			if cap(z.SQSARN) >= int(zb0003) {
				z.SQSARN = (z.SQSARN)[:zb0003]
			} else {
				z.SQSARN = make([]string, zb0003)
			}
			for za0002 := range z.SQSARN {
				z.SQSARN[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "SQSARN", za0002)
					return
				}
			}
			zb0001Mask |= 0x8
		case "deploymentID":
			z.DeploymentID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DeploymentID")
				return
			}
			zb0001Mask |= 0x10
		case "buckets":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			var zb0004Mask uint8 /* 1 bits */
			_ = zb0004Mask
			for zb0004 > 0 {
				zb0004--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Buckets")
					return
				}
				switch msgp.UnsafeString(field) {
				case "count":
					z.Buckets.Count, err = dc.ReadUint64()
					if err != nil {
						err = msgp.WrapError(err, "Buckets", "Count")
						return
					}
				case "error":
					z.Buckets.Error, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Buckets", "Error")
						return
					}
					zb0004Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Buckets")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0004Mask != 0x1 {
				if (zb0004Mask & 0x1) == 0 {
					z.Buckets.Error = ""
				}
			}
			zb0001Mask |= 0x20
		case "objects":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
			var zb0005Mask uint8 /* 1 bits */
			_ = zb0005Mask
			for zb0005 > 0 {
				zb0005--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Objects")
					return
				}
				switch msgp.UnsafeString(field) {
				case "count":
					z.Objects.Count, err = dc.ReadUint64()
					if err != nil {
						err = msgp.WrapError(err, "Objects", "Count")
						return
					}
				case "error":
					z.Objects.Error, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Objects", "Error")
						return
					}
					zb0005Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Objects")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0005Mask != 0x1 {
				if (zb0005Mask & 0x1) == 0 {
					z.Objects.Error = ""
				}
			}
			zb0001Mask |= 0x40
		case "versions":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Versions")
				return
			}
			var zb0006Mask uint8 /* 1 bits */
			_ = zb0006Mask
			for zb0006 > 0 {
				zb0006--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Versions")
					return
				}
				switch msgp.UnsafeString(field) {
				case "count":
					z.Versions.Count, err = dc.ReadUint64()
					if err != nil {
						err = msgp.WrapError(err, "Versions", "Count")
						return
					}
				case "error":
					z.Versions.Error, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Versions", "Error")
						return
					}
					zb0006Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Versions")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0006Mask != 0x1 {
				if (zb0006Mask & 0x1) == 0 {
					z.Versions.Error = ""
				}
			}
			zb0001Mask |= 0x80
		case "deletemarkers":
			var zb0007 uint32
			zb0007, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
			var zb0007Mask uint8 /* 1 bits */
			_ = zb0007Mask
			for zb0007 > 0 {
				zb0007--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "DeleteMarkers")
					return
				}
				switch msgp.UnsafeString(field) {
				case "count":
					z.DeleteMarkers.Count, err = dc.ReadUint64()
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarkers", "Count")
						return
					}
				case "error":
					z.DeleteMarkers.Error, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarkers", "Error")
						return
					}
					zb0007Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarkers")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0007Mask != 0x1 {
				if (zb0007Mask & 0x1) == 0 {
					z.DeleteMarkers.Error = ""
				}
			}
			zb0001Mask |= 0x100
		case "usage":
			var zb0008 uint32
			zb0008, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Usage")
				return
			}
			var zb0008Mask uint8 /* 1 bits */
			_ = zb0008Mask
			for zb0008 > 0 {
				zb0008--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Usage")
					return
				}
				switch msgp.UnsafeString(field) {
				case "size":
					z.Usage.Size, err = dc.ReadUint64()
					if err != nil {
						err = msgp.WrapError(err, "Usage", "Size")
						return
					}
				case "error":
					z.Usage.Error, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Usage", "Error")
						return
					}
					zb0008Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Usage")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0008Mask != 0x1 {
				if (zb0008Mask & 0x1) == 0 {
					z.Usage.Error = ""
				}
			}
			zb0001Mask |= 0x200
		case "services":
			err = z.Services.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Services")
				return
			}
			zb0001Mask |= 0x400
		case "backend":
			err = z.Backend.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Backend")
				return
			}
			zb0001Mask |= 0x800
		case "servers":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Servers")
				return
			}
			if cap(z.Servers) >= int(zb0009) {
				z.Servers = (z.Servers)[:zb0009]
			} else {
				z.Servers = make([]ServerProperties, zb0009)
			}
			for za0003 := range z.Servers {
				err = z.Servers[za0003].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Servers", za0003)
					return
				}
			}
			zb0001Mask |= 0x1000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1fff {
		if (zb0001Mask & 0x1) == 0 {
			z.Mode = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Domain = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Region = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.SQSARN = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.DeploymentID = ""
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Buckets = (Buckets{})
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Objects = (Objects{})
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Versions = (Versions{})
		}
		if (zb0001Mask & 0x100) == 0 {
			z.DeleteMarkers = (DeleteMarkers{})
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Usage = (Usage{})
		}
		if (zb0001Mask & 0x400) == 0 {
			z.Services = Services{}
		}
		if (zb0001Mask & 0x800) == 0 {
			z.Backend = ErasureBackend{}
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.Servers = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *InfoMessage) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.Mode == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Domain == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Region == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.SQSARN == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.DeploymentID == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Buckets == (Buckets{}) {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Objects == (Objects{}) {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Versions == (Versions{}) {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.DeleteMarkers == (DeleteMarkers{}) {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Usage == (Usage{}) {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Servers == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// write "mode"
		err = en.Append(0xa4, 0x6d, 0x6f, 0x64, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Mode)
		if err != nil {
			err = msgp.WrapError(err, "Mode")
			return
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "domain"
		err = en.Append(0xa6, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Domain)))
		if err != nil {
			err = msgp.WrapError(err, "Domain")
			return
		}
		for za0001 := range z.Domain {
			err = en.WriteString(z.Domain[za0001])
			if err != nil {
				err = msgp.WrapError(err, "Domain", za0001)
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// write "region"
		err = en.Append(0xa6, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Region)
		if err != nil {
			err = msgp.WrapError(err, "Region")
			return
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// write "sqsARN"
		err = en.Append(0xa6, 0x73, 0x71, 0x73, 0x41, 0x52, 0x4e)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.SQSARN)))
		if err != nil {
			err = msgp.WrapError(err, "SQSARN")
			return
		}
		for za0002 := range z.SQSARN {
			err = en.WriteString(z.SQSARN[za0002])
			if err != nil {
				err = msgp.WrapError(err, "SQSARN", za0002)
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// write "deploymentID"
		err = en.Append(0xac, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.DeploymentID)
		if err != nil {
			err = msgp.WrapError(err, "DeploymentID")
			return
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// write "buckets"
		err = en.Append(0xa7, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(2)
		var zb0002Mask uint8 /* 2 bits */
		_ = zb0002Mask
		if z.Buckets.Error == "" {
			zb0002Len--
			zb0002Mask |= 0x2
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}
		// write "count"
		err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Buckets.Count)
		if err != nil {
			err = msgp.WrapError(err, "Buckets", "Count")
			return
		}
		if (zb0002Mask & 0x2) == 0 { // if not omitted
			// write "error"
			err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			if err != nil {
				return
			}
			err = en.WriteString(z.Buckets.Error)
			if err != nil {
				err = msgp.WrapError(err, "Buckets", "Error")
				return
			}
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// write "objects"
		err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0003Len := uint32(2)
		var zb0003Mask uint8 /* 2 bits */
		_ = zb0003Mask
		if z.Objects.Error == "" {
			zb0003Len--
			zb0003Mask |= 0x2
		}
		// variable map header, size zb0003Len
		err = en.Append(0x80 | uint8(zb0003Len))
		if err != nil {
			return
		}
		// write "count"
		err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Objects.Count)
		if err != nil {
			err = msgp.WrapError(err, "Objects", "Count")
			return
		}
		if (zb0003Mask & 0x2) == 0 { // if not omitted
			// write "error"
			err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			if err != nil {
				return
			}
			err = en.WriteString(z.Objects.Error)
			if err != nil {
				err = msgp.WrapError(err, "Objects", "Error")
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// write "versions"
		err = en.Append(0xa8, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0004Len := uint32(2)
		var zb0004Mask uint8 /* 2 bits */
		_ = zb0004Mask
		if z.Versions.Error == "" {
			zb0004Len--
			zb0004Mask |= 0x2
		}
		// variable map header, size zb0004Len
		err = en.Append(0x80 | uint8(zb0004Len))
		if err != nil {
			return
		}
		// write "count"
		err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Versions.Count)
		if err != nil {
			err = msgp.WrapError(err, "Versions", "Count")
			return
		}
		if (zb0004Mask & 0x2) == 0 { // if not omitted
			// write "error"
			err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			if err != nil {
				return
			}
			err = en.WriteString(z.Versions.Error)
			if err != nil {
				err = msgp.WrapError(err, "Versions", "Error")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not omitted
		// write "deletemarkers"
		err = en.Append(0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x6d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0005Len := uint32(2)
		var zb0005Mask uint8 /* 2 bits */
		_ = zb0005Mask
		if z.DeleteMarkers.Error == "" {
			zb0005Len--
			zb0005Mask |= 0x2
		}
		// variable map header, size zb0005Len
		err = en.Append(0x80 | uint8(zb0005Len))
		if err != nil {
			return
		}
		// write "count"
		err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.DeleteMarkers.Count)
		if err != nil {
			err = msgp.WrapError(err, "DeleteMarkers", "Count")
			return
		}
		if (zb0005Mask & 0x2) == 0 { // if not omitted
			// write "error"
			err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			if err != nil {
				return
			}
			err = en.WriteString(z.DeleteMarkers.Error)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers", "Error")
				return
			}
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not omitted
		// write "usage"
		err = en.Append(0xa5, 0x75, 0x73, 0x61, 0x67, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0006Len := uint32(2)
		var zb0006Mask uint8 /* 2 bits */
		_ = zb0006Mask
		if z.Usage.Error == "" {
			zb0006Len--
			zb0006Mask |= 0x2
		}
		// variable map header, size zb0006Len
		err = en.Append(0x80 | uint8(zb0006Len))
		if err != nil {
			return
		}
		// write "size"
		err = en.Append(0xa4, 0x73, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.Usage.Size)
		if err != nil {
			err = msgp.WrapError(err, "Usage", "Size")
			return
		}
		if (zb0006Mask & 0x2) == 0 { // if not omitted
			// write "error"
			err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			if err != nil {
				return
			}
			err = en.WriteString(z.Usage.Error)
			if err != nil {
				err = msgp.WrapError(err, "Usage", "Error")
				return
			}
		}
	}
	// write "services"
	err = en.Append(0xa8, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = z.Services.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Services")
		return
	}
	// write "backend"
	err = en.Append(0xa7, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = z.Backend.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Backend")
		return
	}
	if (zb0001Mask & 0x1000) == 0 { // if not omitted
		// write "servers"
		err = en.Append(0xa7, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Servers)))
		if err != nil {
			err = msgp.WrapError(err, "Servers")
			return
		}
		for za0003 := range z.Servers {
			err = z.Servers[za0003].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Servers", za0003)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InfoMessage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.Mode == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Domain == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Region == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.SQSARN == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.DeploymentID == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Buckets == (Buckets{}) {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Objects == (Objects{}) {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Versions == (Versions{}) {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.DeleteMarkers == (DeleteMarkers{}) {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Usage == (Usage{}) {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Servers == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// string "mode"
		o = append(o, 0xa4, 0x6d, 0x6f, 0x64, 0x65)
		o = msgp.AppendString(o, z.Mode)
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "domain"
		o = append(o, 0xa6, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Domain)))
		for za0001 := range z.Domain {
			o = msgp.AppendString(o, z.Domain[za0001])
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// string "region"
		o = append(o, 0xa6, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e)
		o = msgp.AppendString(o, z.Region)
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// string "sqsARN"
		o = append(o, 0xa6, 0x73, 0x71, 0x73, 0x41, 0x52, 0x4e)
		o = msgp.AppendArrayHeader(o, uint32(len(z.SQSARN)))
		for za0002 := range z.SQSARN {
			o = msgp.AppendString(o, z.SQSARN[za0002])
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// string "deploymentID"
		o = append(o, 0xac, 0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x44)
		o = msgp.AppendString(o, z.DeploymentID)
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// string "buckets"
		o = append(o, 0xa7, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		// check for omitted fields
		zb0002Len := uint32(2)
		var zb0002Mask uint8 /* 2 bits */
		_ = zb0002Mask
		if z.Buckets.Error == "" {
			zb0002Len--
			zb0002Mask |= 0x2
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))
		// string "count"
		o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.Buckets.Count)
		if (zb0002Mask & 0x2) == 0 { // if not omitted
			// string "error"
			o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			o = msgp.AppendString(o, z.Buckets.Error)
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// string "objects"
		o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
		// check for omitted fields
		zb0003Len := uint32(2)
		var zb0003Mask uint8 /* 2 bits */
		_ = zb0003Mask
		if z.Objects.Error == "" {
			zb0003Len--
			zb0003Mask |= 0x2
		}
		// variable map header, size zb0003Len
		o = append(o, 0x80|uint8(zb0003Len))
		// string "count"
		o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.Objects.Count)
		if (zb0003Mask & 0x2) == 0 { // if not omitted
			// string "error"
			o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			o = msgp.AppendString(o, z.Objects.Error)
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// string "versions"
		o = append(o, 0xa8, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73)
		// check for omitted fields
		zb0004Len := uint32(2)
		var zb0004Mask uint8 /* 2 bits */
		_ = zb0004Mask
		if z.Versions.Error == "" {
			zb0004Len--
			zb0004Mask |= 0x2
		}
		// variable map header, size zb0004Len
		o = append(o, 0x80|uint8(zb0004Len))
		// string "count"
		o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.Versions.Count)
		if (zb0004Mask & 0x2) == 0 { // if not omitted
			// string "error"
			o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			o = msgp.AppendString(o, z.Versions.Error)
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not omitted
		// string "deletemarkers"
		o = append(o, 0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x6d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
		// check for omitted fields
		zb0005Len := uint32(2)
		var zb0005Mask uint8 /* 2 bits */
		_ = zb0005Mask
		if z.DeleteMarkers.Error == "" {
			zb0005Len--
			zb0005Mask |= 0x2
		}
		// variable map header, size zb0005Len
		o = append(o, 0x80|uint8(zb0005Len))
		// string "count"
		o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.DeleteMarkers.Count)
		if (zb0005Mask & 0x2) == 0 { // if not omitted
			// string "error"
			o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			o = msgp.AppendString(o, z.DeleteMarkers.Error)
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not omitted
		// string "usage"
		o = append(o, 0xa5, 0x75, 0x73, 0x61, 0x67, 0x65)
		// check for omitted fields
		zb0006Len := uint32(2)
		var zb0006Mask uint8 /* 2 bits */
		_ = zb0006Mask
		if z.Usage.Error == "" {
			zb0006Len--
			zb0006Mask |= 0x2
		}
		// variable map header, size zb0006Len
		o = append(o, 0x80|uint8(zb0006Len))
		// string "size"
		o = append(o, 0xa4, 0x73, 0x69, 0x7a, 0x65)
		o = msgp.AppendUint64(o, z.Usage.Size)
		if (zb0006Mask & 0x2) == 0 { // if not omitted
			// string "error"
			o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			o = msgp.AppendString(o, z.Usage.Error)
		}
	}
	// string "services"
	o = append(o, 0xa8, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73)
	o, err = z.Services.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Services")
		return
	}
	// string "backend"
	o = append(o, 0xa7, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64)
	o, err = z.Backend.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Backend")
		return
	}
	if (zb0001Mask & 0x1000) == 0 { // if not omitted
		// string "servers"
		o = append(o, 0xa7, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Servers)))
		for za0003 := range z.Servers {
			o, err = z.Servers[za0003].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Servers", za0003)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InfoMessage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "mode":
			z.Mode, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
			zb0001Mask |= 0x1
		case "domain":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Domain")
				return
			}
			if cap(z.Domain) >= int(zb0002) {
				z.Domain = (z.Domain)[:zb0002]
			} else {
				z.Domain = make([]string, zb0002)
			}
			for za0001 := range z.Domain {
				z.Domain[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Domain", za0001)
					return
				}
			}
			zb0001Mask |= 0x2
		case "region":
			z.Region, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Region")
				return
			}
			zb0001Mask |= 0x4
		case "sqsARN":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SQSARN")
				return
			}
			if cap(z.SQSARN) >= int(zb0003) {
				z.SQSARN = (z.SQSARN)[:zb0003]
			} else {
				z.SQSARN = make([]string, zb0003)
			}
			for za0002 := range z.SQSARN {
				z.SQSARN[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SQSARN", za0002)
					return
				}
			}
			zb0001Mask |= 0x8
		case "deploymentID":
			z.DeploymentID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeploymentID")
				return
			}
			zb0001Mask |= 0x10
		case "buckets":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			var zb0004Mask uint8 /* 1 bits */
			_ = zb0004Mask
			for zb0004 > 0 {
				zb0004--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buckets")
					return
				}
				switch msgp.UnsafeString(field) {
				case "count":
					z.Buckets.Count, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buckets", "Count")
						return
					}
				case "error":
					z.Buckets.Error, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buckets", "Error")
						return
					}
					zb0004Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Buckets")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0004Mask != 0x1 {
				if (zb0004Mask & 0x1) == 0 {
					z.Buckets.Error = ""
				}
			}
			zb0001Mask |= 0x20
		case "objects":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
			var zb0005Mask uint8 /* 1 bits */
			_ = zb0005Mask
			for zb0005 > 0 {
				zb0005--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Objects")
					return
				}
				switch msgp.UnsafeString(field) {
				case "count":
					z.Objects.Count, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Objects", "Count")
						return
					}
				case "error":
					z.Objects.Error, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Objects", "Error")
						return
					}
					zb0005Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Objects")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0005Mask != 0x1 {
				if (zb0005Mask & 0x1) == 0 {
					z.Objects.Error = ""
				}
			}
			zb0001Mask |= 0x40
		case "versions":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Versions")
				return
			}
			var zb0006Mask uint8 /* 1 bits */
			_ = zb0006Mask
			for zb0006 > 0 {
				zb0006--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Versions")
					return
				}
				switch msgp.UnsafeString(field) {
				case "count":
					z.Versions.Count, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Versions", "Count")
						return
					}
				case "error":
					z.Versions.Error, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Versions", "Error")
						return
					}
					zb0006Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Versions")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0006Mask != 0x1 {
				if (zb0006Mask & 0x1) == 0 {
					z.Versions.Error = ""
				}
			}
			zb0001Mask |= 0x80
		case "deletemarkers":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
			var zb0007Mask uint8 /* 1 bits */
			_ = zb0007Mask
			for zb0007 > 0 {
				zb0007--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "DeleteMarkers")
					return
				}
				switch msgp.UnsafeString(field) {
				case "count":
					z.DeleteMarkers.Count, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarkers", "Count")
						return
					}
				case "error":
					z.DeleteMarkers.Error, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarkers", "Error")
						return
					}
					zb0007Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "DeleteMarkers")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0007Mask != 0x1 {
				if (zb0007Mask & 0x1) == 0 {
					z.DeleteMarkers.Error = ""
				}
			}
			zb0001Mask |= 0x100
		case "usage":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Usage")
				return
			}
			var zb0008Mask uint8 /* 1 bits */
			_ = zb0008Mask
			for zb0008 > 0 {
				zb0008--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Usage")
					return
				}
				switch msgp.UnsafeString(field) {
				case "size":
					z.Usage.Size, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Usage", "Size")
						return
					}
				case "error":
					z.Usage.Error, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Usage", "Error")
						return
					}
					zb0008Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Usage")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0008Mask != 0x1 {
				if (zb0008Mask & 0x1) == 0 {
					z.Usage.Error = ""
				}
			}
			zb0001Mask |= 0x200
		case "services":
			bts, err = z.Services.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Services")
				return
			}
			zb0001Mask |= 0x400
		case "backend":
			bts, err = z.Backend.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Backend")
				return
			}
			zb0001Mask |= 0x800
		case "servers":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Servers")
				return
			}
			if cap(z.Servers) >= int(zb0009) {
				z.Servers = (z.Servers)[:zb0009]
			} else {
				z.Servers = make([]ServerProperties, zb0009)
			}
			for za0003 := range z.Servers {
				bts, err = z.Servers[za0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Servers", za0003)
					return
				}
			}
			zb0001Mask |= 0x1000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1fff {
		if (zb0001Mask & 0x1) == 0 {
			z.Mode = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Domain = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Region = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.SQSARN = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.DeploymentID = ""
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Buckets = (Buckets{})
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Objects = (Objects{})
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Versions = (Versions{})
		}
		if (zb0001Mask & 0x100) == 0 {
			z.DeleteMarkers = (DeleteMarkers{})
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Usage = (Usage{})
		}
		if (zb0001Mask & 0x400) == 0 {
			z.Services = Services{}
		}
		if (zb0001Mask & 0x800) == 0 {
			z.Backend = ErasureBackend{}
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.Servers = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InfoMessage) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Mode) + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Domain {
		s += msgp.StringPrefixSize + len(z.Domain[za0001])
	}
	s += 7 + msgp.StringPrefixSize + len(z.Region) + 7 + msgp.ArrayHeaderSize
	for za0002 := range z.SQSARN {
		s += msgp.StringPrefixSize + len(z.SQSARN[za0002])
	}
	s += 13 + msgp.StringPrefixSize + len(z.DeploymentID) + 8 + 1 + 6 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Buckets.Error) + 8 + 1 + 6 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Objects.Error) + 9 + 1 + 6 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Versions.Error) + 14 + 1 + 6 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.DeleteMarkers.Error) + 6 + 1 + 5 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Usage.Error) + 9 + z.Services.Msgsize() + 8 + z.Backend.Msgsize() + 8 + msgp.ArrayHeaderSize
	for za0003 := range z.Servers {
		s += z.Servers[za0003].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ItemState) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ItemState(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ItemState) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ItemState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ItemState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = ItemState(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ItemState) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *KMS) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "status":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			zb0001Mask |= 0x1
		case "encrypt":
			z.Encrypt, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Encrypt")
				return
			}
			zb0001Mask |= 0x2
		case "decrypt":
			z.Decrypt, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Decrypt")
				return
			}
			zb0001Mask |= 0x4
		case "endpoint":
			z.Endpoint, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
			zb0001Mask |= 0x8
		case "version":
			z.Version, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
			zb0001Mask |= 0x10
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.Status = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Encrypt = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Decrypt = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Endpoint = ""
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Version = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *KMS) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Status == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Encrypt == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Decrypt == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Endpoint == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Version == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// write "status"
		err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		if err != nil {
			return
		}
		err = en.WriteString(z.Status)
		if err != nil {
			err = msgp.WrapError(err, "Status")
			return
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "encrypt"
		err = en.Append(0xa7, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Encrypt)
		if err != nil {
			err = msgp.WrapError(err, "Encrypt")
			return
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// write "decrypt"
		err = en.Append(0xa7, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Decrypt)
		if err != nil {
			err = msgp.WrapError(err, "Decrypt")
			return
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// write "endpoint"
		err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Endpoint)
		if err != nil {
			err = msgp.WrapError(err, "Endpoint")
			return
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// write "version"
		err = en.Append(0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Version)
		if err != nil {
			err = msgp.WrapError(err, "Version")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *KMS) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Status == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Encrypt == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Decrypt == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Endpoint == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Version == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// string "status"
		o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		o = msgp.AppendString(o, z.Status)
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "encrypt"
		o = append(o, 0xa7, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74)
		o = msgp.AppendString(o, z.Encrypt)
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// string "decrypt"
		o = append(o, 0xa7, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74)
		o = msgp.AppendString(o, z.Decrypt)
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// string "endpoint"
		o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		o = msgp.AppendString(o, z.Endpoint)
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// string "version"
		o = append(o, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
		o = msgp.AppendString(o, z.Version)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *KMS) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "status":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			zb0001Mask |= 0x1
		case "encrypt":
			z.Encrypt, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Encrypt")
				return
			}
			zb0001Mask |= 0x2
		case "decrypt":
			z.Decrypt, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Decrypt")
				return
			}
			zb0001Mask |= 0x4
		case "endpoint":
			z.Endpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
			zb0001Mask |= 0x8
		case "version":
			z.Version, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
			zb0001Mask |= 0x10
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.Status = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Encrypt = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Decrypt = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Endpoint = ""
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Version = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *KMS) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Status) + 8 + msgp.StringPrefixSize + len(z.Encrypt) + 8 + msgp.StringPrefixSize + len(z.Decrypt) + 9 + msgp.StringPrefixSize + len(z.Endpoint) + 8 + msgp.StringPrefixSize + len(z.Version)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LDAP) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "status":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Status = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z LDAP) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	if z.Status == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// write "status"
		err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		if err != nil {
			return
		}
		err = en.WriteString(z.Status)
		if err != nil {
			err = msgp.WrapError(err, "Status")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z LDAP) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	if z.Status == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// string "status"
		o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		o = msgp.AppendString(o, z.Status)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LDAP) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "status":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Status = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z LDAP) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Status)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Logger) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0003 uint32
	zb0003, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(Logger, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		zb0003--
		var zb0001 string
		var zb0002 Status
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0004 uint32
		zb0004, err = dc.ReadMapHeader()
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		var zb0004Mask uint8 /* 1 bits */
		_ = zb0004Mask
		for zb0004 > 0 {
			zb0004--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "status":
				zb0002.Status, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Status")
					return
				}
				zb0004Mask |= 0x1
			default:
				err = dc.Skip()
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
		// Clear omitted fields.
		if zb0004Mask != 0x1 {
			if (zb0004Mask & 0x1) == 0 {
				zb0002.Status = ""
			}
		}
		(*z)[zb0001] = zb0002
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Logger) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteMapHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0005, zb0006 := range z {
		err = en.WriteString(zb0005)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		// check for omitted fields
		zb0001Len := uint32(1)
		var zb0001Mask uint8 /* 1 bits */
		_ = zb0001Mask
		if zb0006.Status == "" {
			zb0001Len--
			zb0001Mask |= 0x1
		}
		// variable map header, size zb0001Len
		err = en.Append(0x80 | uint8(zb0001Len))
		if err != nil {
			return
		}
		if zb0001Len == 0 {
			return
		}
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "status"
			err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			if err != nil {
				return
			}
			err = en.WriteString(zb0006.Status)
			if err != nil {
				err = msgp.WrapError(err, zb0005, "Status")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Logger) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendMapHeader(o, uint32(len(z)))
	for zb0005, zb0006 := range z {
		o = msgp.AppendString(o, zb0005)
		// check for omitted fields
		zb0001Len := uint32(1)
		var zb0001Mask uint8 /* 1 bits */
		_ = zb0001Mask
		if zb0006.Status == "" {
			zb0001Len--
			zb0001Mask |= 0x1
		}
		// variable map header, size zb0001Len
		o = append(o, 0x80|uint8(zb0001Len))
		if zb0001Len == 0 {
			return
		}
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "status"
			o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			o = msgp.AppendString(o, zb0006.Status)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Logger) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(Logger, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		var zb0001 string
		var zb0002 Status
		zb0003--
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0004 uint32
		zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		var zb0004Mask uint8 /* 1 bits */
		_ = zb0004Mask
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "status":
				zb0002.Status, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Status")
					return
				}
				zb0004Mask |= 0x1
			default:
				bts, err = msgp.Skip(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
		// Clear omitted fields.
		if zb0004Mask != 0x1 {
			if (zb0004Mask & 0x1) == 0 {
				zb0002.Status = ""
			}
		}
		(*z)[zb0001] = zb0002
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Logger) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for zb0005, zb0006 := range z {
			_ = zb0006
			s += msgp.StringPrefixSize + len(zb0005) + 1 + 7 + msgp.StringPrefixSize + len(zb0006.Status)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MemStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Alloc":
			z.Alloc, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Alloc")
				return
			}
		case "TotalAlloc":
			z.TotalAlloc, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalAlloc")
				return
			}
		case "Mallocs":
			z.Mallocs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Mallocs")
				return
			}
		case "Frees":
			z.Frees, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Frees")
				return
			}
		case "HeapAlloc":
			z.HeapAlloc, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "HeapAlloc")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MemStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "Alloc"
	err = en.Append(0x85, 0xa5, 0x41, 0x6c, 0x6c, 0x6f, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Alloc)
	if err != nil {
		err = msgp.WrapError(err, "Alloc")
		return
	}
	// write "TotalAlloc"
	err = en.Append(0xaa, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6c, 0x6c, 0x6f, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalAlloc)
	if err != nil {
		err = msgp.WrapError(err, "TotalAlloc")
		return
	}
	// write "Mallocs"
	err = en.Append(0xa7, 0x4d, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Mallocs)
	if err != nil {
		err = msgp.WrapError(err, "Mallocs")
		return
	}
	// write "Frees"
	err = en.Append(0xa5, 0x46, 0x72, 0x65, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Frees)
	if err != nil {
		err = msgp.WrapError(err, "Frees")
		return
	}
	// write "HeapAlloc"
	err = en.Append(0xa9, 0x48, 0x65, 0x61, 0x70, 0x41, 0x6c, 0x6c, 0x6f, 0x63)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.HeapAlloc)
	if err != nil {
		err = msgp.WrapError(err, "HeapAlloc")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MemStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "Alloc"
	o = append(o, 0x85, 0xa5, 0x41, 0x6c, 0x6c, 0x6f, 0x63)
	o = msgp.AppendUint64(o, z.Alloc)
	// string "TotalAlloc"
	o = append(o, 0xaa, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x41, 0x6c, 0x6c, 0x6f, 0x63)
	o = msgp.AppendUint64(o, z.TotalAlloc)
	// string "Mallocs"
	o = append(o, 0xa7, 0x4d, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x73)
	o = msgp.AppendUint64(o, z.Mallocs)
	// string "Frees"
	o = append(o, 0xa5, 0x46, 0x72, 0x65, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.Frees)
	// string "HeapAlloc"
	o = append(o, 0xa9, 0x48, 0x65, 0x61, 0x70, 0x41, 0x6c, 0x6c, 0x6f, 0x63)
	o = msgp.AppendUint64(o, z.HeapAlloc)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MemStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Alloc":
			z.Alloc, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Alloc")
				return
			}
		case "TotalAlloc":
			z.TotalAlloc, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalAlloc")
				return
			}
		case "Mallocs":
			z.Mallocs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mallocs")
				return
			}
		case "Frees":
			z.Frees, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Frees")
				return
			}
		case "HeapAlloc":
			z.HeapAlloc, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HeapAlloc")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MemStats) Msgsize() (s int) {
	s = 1 + 6 + msgp.Uint64Size + 11 + msgp.Uint64Size + 8 + msgp.Uint64Size + 6 + msgp.Uint64Size + 10 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Objects) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "error":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Objects) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "count"
	err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "error"
		err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.Error)
		if err != nil {
			err = msgp.WrapError(err, "Error")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Objects) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "count"
	o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.Count)
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "error"
		o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		o = msgp.AppendString(o, z.Error)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Objects) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "error":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Objects) Msgsize() (s int) {
	s = 1 + 6 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Error)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ServerInfoOpts) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Metrics":
			z.Metrics, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Metrics")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ServerInfoOpts) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "Metrics"
	err = en.Append(0x81, 0xa7, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Metrics)
	if err != nil {
		err = msgp.WrapError(err, "Metrics")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ServerInfoOpts) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Metrics"
	o = append(o, 0x81, 0xa7, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
	o = msgp.AppendBool(o, z.Metrics)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerInfoOpts) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Metrics":
			z.Metrics, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Metrics")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ServerInfoOpts) Msgsize() (s int) {
	s = 1 + 8 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ServerProperties) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 15 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "state":
			z.State, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
			zb0001Mask |= 0x1
		case "endpoint":
			z.Endpoint, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
			zb0001Mask |= 0x2
		case "scheme":
			z.Scheme, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Scheme")
				return
			}
			zb0001Mask |= 0x4
		case "uptime":
			z.Uptime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Uptime")
				return
			}
			zb0001Mask |= 0x8
		case "version":
			z.Version, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
			zb0001Mask |= 0x10
		case "commitID":
			z.CommitID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CommitID")
				return
			}
			zb0001Mask |= 0x20
		case "network":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Network")
				return
			}
			if z.Network == nil {
				z.Network = make(map[string]string, zb0002)
			} else if len(z.Network) > 0 {
				for key := range z.Network {
					delete(z.Network, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Network")
					return
				}
				za0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Network", za0001)
					return
				}
				z.Network[za0001] = za0002
			}
			zb0001Mask |= 0x40
		case "drives":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0003) {
				z.Disks = (z.Disks)[:zb0003]
			} else {
				z.Disks = make([]Disk, zb0003)
			}
			for za0003 := range z.Disks {
				err = z.Disks[za0003].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0003)
					return
				}
			}
			zb0001Mask |= 0x80
		case "poolNumber":
			z.PoolNumber, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PoolNumber")
				return
			}
			zb0001Mask |= 0x100
		case "poolNumbers":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PoolNumbers")
				return
			}
			if cap(z.PoolNumbers) >= int(zb0004) {
				z.PoolNumbers = (z.PoolNumbers)[:zb0004]
			} else {
				z.PoolNumbers = make([]int, zb0004)
			}
			for za0004 := range z.PoolNumbers {
				z.PoolNumbers[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PoolNumbers", za0004)
					return
				}
			}
			zb0001Mask |= 0x200
		case "mem_stats":
			err = z.MemStats.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "MemStats")
				return
			}
		case "go_max_procs":
			z.GoMaxProcs, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "GoMaxProcs")
				return
			}
			zb0001Mask |= 0x400
		case "num_cpu":
			z.NumCPU, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NumCPU")
				return
			}
			zb0001Mask |= 0x800
		case "runtime_version":
			z.RuntimeVersion, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "RuntimeVersion")
				return
			}
			zb0001Mask |= 0x1000
		case "gc_stats":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "GCStats")
					return
				}
				z.GCStats = nil
			} else {
				if z.GCStats == nil {
					z.GCStats = new(GCStats)
				}
				err = z.GCStats.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "GCStats")
					return
				}
			}
			zb0001Mask |= 0x2000
		case "minio_env_vars":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "MinioEnvVars")
				return
			}
			if z.MinioEnvVars == nil {
				z.MinioEnvVars = make(map[string]string, zb0005)
			} else if len(z.MinioEnvVars) > 0 {
				for key := range z.MinioEnvVars {
					delete(z.MinioEnvVars, key)
				}
			}
			for zb0005 > 0 {
				zb0005--
				var za0005 string
				var za0006 string
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "MinioEnvVars")
					return
				}
				za0006, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "MinioEnvVars", za0005)
					return
				}
				z.MinioEnvVars[za0005] = za0006
			}
			zb0001Mask |= 0x4000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7fff {
		if (zb0001Mask & 0x1) == 0 {
			z.State = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Endpoint = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Scheme = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Uptime = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Version = ""
		}
		if (zb0001Mask & 0x20) == 0 {
			z.CommitID = ""
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Network = nil
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Disks = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.PoolNumber = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.PoolNumbers = nil
		}
		if (zb0001Mask & 0x400) == 0 {
			z.GoMaxProcs = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.NumCPU = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.RuntimeVersion = ""
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.GCStats = nil
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.MinioEnvVars = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ServerProperties) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(16)
	var zb0001Mask uint16 /* 16 bits */
	_ = zb0001Mask
	if z.State == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Endpoint == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Scheme == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Uptime == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Version == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.CommitID == "" {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Network == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Disks == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.PoolNumber == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.PoolNumbers == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.GoMaxProcs == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.NumCPU == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.RuntimeVersion == "" {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.GCStats == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.MinioEnvVars == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// write "state"
		err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.State)
		if err != nil {
			err = msgp.WrapError(err, "State")
			return
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "endpoint"
		err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Endpoint)
		if err != nil {
			err = msgp.WrapError(err, "Endpoint")
			return
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// write "scheme"
		err = en.Append(0xa6, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Scheme)
		if err != nil {
			err = msgp.WrapError(err, "Scheme")
			return
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// write "uptime"
		err = en.Append(0xa6, 0x75, 0x70, 0x74, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.Uptime)
		if err != nil {
			err = msgp.WrapError(err, "Uptime")
			return
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// write "version"
		err = en.Append(0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.Version)
		if err != nil {
			err = msgp.WrapError(err, "Version")
			return
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// write "commitID"
		err = en.Append(0xa8, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.CommitID)
		if err != nil {
			err = msgp.WrapError(err, "CommitID")
			return
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// write "network"
		err = en.Append(0xa7, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b)
		if err != nil {
			return
		}
		err = en.WriteMapHeader(uint32(len(z.Network)))
		if err != nil {
			err = msgp.WrapError(err, "Network")
			return
		}
		for za0001, za0002 := range z.Network {
			err = en.WriteString(za0001)
			if err != nil {
				err = msgp.WrapError(err, "Network")
				return
			}
			err = en.WriteString(za0002)
			if err != nil {
				err = msgp.WrapError(err, "Network", za0001)
				return
			}
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// write "drives"
		err = en.Append(0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Disks)))
		if err != nil {
			err = msgp.WrapError(err, "Disks")
			return
		}
		for za0003 := range z.Disks {
			err = z.Disks[za0003].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Disks", za0003)
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not omitted
		// write "poolNumber"
		err = en.Append(0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
		if err != nil {
			return
		}
		err = en.WriteInt(z.PoolNumber)
		if err != nil {
			err = msgp.WrapError(err, "PoolNumber")
			return
		}
	}
	if (zb0001Mask & 0x200) == 0 { // if not omitted
		// write "poolNumbers"
		err = en.Append(0xab, 0x70, 0x6f, 0x6f, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.PoolNumbers)))
		if err != nil {
			err = msgp.WrapError(err, "PoolNumbers")
			return
		}
		for za0004 := range z.PoolNumbers {
			err = en.WriteInt(z.PoolNumbers[za0004])
			if err != nil {
				err = msgp.WrapError(err, "PoolNumbers", za0004)
				return
			}
		}
	}
	// write "mem_stats"
	err = en.Append(0xa9, 0x6d, 0x65, 0x6d, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = z.MemStats.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "MemStats")
		return
	}
	if (zb0001Mask & 0x800) == 0 { // if not omitted
		// write "go_max_procs"
		err = en.Append(0xac, 0x67, 0x6f, 0x5f, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.GoMaxProcs)
		if err != nil {
			err = msgp.WrapError(err, "GoMaxProcs")
			return
		}
	}
	if (zb0001Mask & 0x1000) == 0 { // if not omitted
		// write "num_cpu"
		err = en.Append(0xa7, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x70, 0x75)
		if err != nil {
			return
		}
		err = en.WriteInt(z.NumCPU)
		if err != nil {
			err = msgp.WrapError(err, "NumCPU")
			return
		}
	}
	if (zb0001Mask & 0x2000) == 0 { // if not omitted
		// write "runtime_version"
		err = en.Append(0xaf, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteString(z.RuntimeVersion)
		if err != nil {
			err = msgp.WrapError(err, "RuntimeVersion")
			return
		}
	}
	if (zb0001Mask & 0x4000) == 0 { // if not omitted
		// write "gc_stats"
		err = en.Append(0xa8, 0x67, 0x63, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
		if err != nil {
			return
		}
		if z.GCStats == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.GCStats.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "GCStats")
				return
			}
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not omitted
		// write "minio_env_vars"
		err = en.Append(0xae, 0x6d, 0x69, 0x6e, 0x69, 0x6f, 0x5f, 0x65, 0x6e, 0x76, 0x5f, 0x76, 0x61, 0x72, 0x73)
		if err != nil {
			return
		}
		err = en.WriteMapHeader(uint32(len(z.MinioEnvVars)))
		if err != nil {
			err = msgp.WrapError(err, "MinioEnvVars")
			return
		}
		for za0005, za0006 := range z.MinioEnvVars {
			err = en.WriteString(za0005)
			if err != nil {
				err = msgp.WrapError(err, "MinioEnvVars")
				return
			}
			err = en.WriteString(za0006)
			if err != nil {
				err = msgp.WrapError(err, "MinioEnvVars", za0005)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ServerProperties) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(16)
	var zb0001Mask uint16 /* 16 bits */
	_ = zb0001Mask
	if z.State == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Endpoint == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Scheme == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Uptime == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Version == "" {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.CommitID == "" {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Network == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Disks == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.PoolNumber == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.PoolNumbers == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.GoMaxProcs == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.NumCPU == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.RuntimeVersion == "" {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.GCStats == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.MinioEnvVars == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// string "state"
		o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
		o = msgp.AppendString(o, z.State)
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "endpoint"
		o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		o = msgp.AppendString(o, z.Endpoint)
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// string "scheme"
		o = append(o, 0xa6, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65)
		o = msgp.AppendString(o, z.Scheme)
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// string "uptime"
		o = append(o, 0xa6, 0x75, 0x70, 0x74, 0x69, 0x6d, 0x65)
		o = msgp.AppendInt64(o, z.Uptime)
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// string "version"
		o = append(o, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
		o = msgp.AppendString(o, z.Version)
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// string "commitID"
		o = append(o, 0xa8, 0x63, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x49, 0x44)
		o = msgp.AppendString(o, z.CommitID)
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// string "network"
		o = append(o, 0xa7, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b)
		o = msgp.AppendMapHeader(o, uint32(len(z.Network)))
		for za0001, za0002 := range z.Network {
			o = msgp.AppendString(o, za0001)
			o = msgp.AppendString(o, za0002)
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// string "drives"
		o = append(o, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Disks)))
		for za0003 := range z.Disks {
			o, err = z.Disks[za0003].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Disks", za0003)
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not omitted
		// string "poolNumber"
		o = append(o, 0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72)
		o = msgp.AppendInt(o, z.PoolNumber)
	}
	if (zb0001Mask & 0x200) == 0 { // if not omitted
		// string "poolNumbers"
		o = append(o, 0xab, 0x70, 0x6f, 0x6f, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.PoolNumbers)))
		for za0004 := range z.PoolNumbers {
			o = msgp.AppendInt(o, z.PoolNumbers[za0004])
		}
	}
	// string "mem_stats"
	o = append(o, 0xa9, 0x6d, 0x65, 0x6d, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
	o, err = z.MemStats.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "MemStats")
		return
	}
	if (zb0001Mask & 0x800) == 0 { // if not omitted
		// string "go_max_procs"
		o = append(o, 0xac, 0x67, 0x6f, 0x5f, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x73)
		o = msgp.AppendInt(o, z.GoMaxProcs)
	}
	if (zb0001Mask & 0x1000) == 0 { // if not omitted
		// string "num_cpu"
		o = append(o, 0xa7, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x70, 0x75)
		o = msgp.AppendInt(o, z.NumCPU)
	}
	if (zb0001Mask & 0x2000) == 0 { // if not omitted
		// string "runtime_version"
		o = append(o, 0xaf, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
		o = msgp.AppendString(o, z.RuntimeVersion)
	}
	if (zb0001Mask & 0x4000) == 0 { // if not omitted
		// string "gc_stats"
		o = append(o, 0xa8, 0x67, 0x63, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
		if z.GCStats == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.GCStats.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "GCStats")
				return
			}
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not omitted
		// string "minio_env_vars"
		o = append(o, 0xae, 0x6d, 0x69, 0x6e, 0x69, 0x6f, 0x5f, 0x65, 0x6e, 0x76, 0x5f, 0x76, 0x61, 0x72, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.MinioEnvVars)))
		for za0005, za0006 := range z.MinioEnvVars {
			o = msgp.AppendString(o, za0005)
			o = msgp.AppendString(o, za0006)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ServerProperties) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 15 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "state":
			z.State, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
			zb0001Mask |= 0x1
		case "endpoint":
			z.Endpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
			zb0001Mask |= 0x2
		case "scheme":
			z.Scheme, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Scheme")
				return
			}
			zb0001Mask |= 0x4
		case "uptime":
			z.Uptime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Uptime")
				return
			}
			zb0001Mask |= 0x8
		case "version":
			z.Version, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
			zb0001Mask |= 0x10
		case "commitID":
			z.CommitID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CommitID")
				return
			}
			zb0001Mask |= 0x20
		case "network":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Network")
				return
			}
			if z.Network == nil {
				z.Network = make(map[string]string, zb0002)
			} else if len(z.Network) > 0 {
				for key := range z.Network {
					delete(z.Network, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 string
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Network")
					return
				}
				za0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Network", za0001)
					return
				}
				z.Network[za0001] = za0002
			}
			zb0001Mask |= 0x40
		case "drives":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0003) {
				z.Disks = (z.Disks)[:zb0003]
			} else {
				z.Disks = make([]Disk, zb0003)
			}
			for za0003 := range z.Disks {
				bts, err = z.Disks[za0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0003)
					return
				}
			}
			zb0001Mask |= 0x80
		case "poolNumber":
			z.PoolNumber, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolNumber")
				return
			}
			zb0001Mask |= 0x100
		case "poolNumbers":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolNumbers")
				return
			}
			if cap(z.PoolNumbers) >= int(zb0004) {
				z.PoolNumbers = (z.PoolNumbers)[:zb0004]
			} else {
				z.PoolNumbers = make([]int, zb0004)
			}
			for za0004 := range z.PoolNumbers {
				z.PoolNumbers[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PoolNumbers", za0004)
					return
				}
			}
			zb0001Mask |= 0x200
		case "mem_stats":
			bts, err = z.MemStats.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MemStats")
				return
			}
		case "go_max_procs":
			z.GoMaxProcs, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GoMaxProcs")
				return
			}
			zb0001Mask |= 0x400
		case "num_cpu":
			z.NumCPU, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumCPU")
				return
			}
			zb0001Mask |= 0x800
		case "runtime_version":
			z.RuntimeVersion, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RuntimeVersion")
				return
			}
			zb0001Mask |= 0x1000
		case "gc_stats":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.GCStats = nil
			} else {
				if z.GCStats == nil {
					z.GCStats = new(GCStats)
				}
				bts, err = z.GCStats.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "GCStats")
					return
				}
			}
			zb0001Mask |= 0x2000
		case "minio_env_vars":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinioEnvVars")
				return
			}
			if z.MinioEnvVars == nil {
				z.MinioEnvVars = make(map[string]string, zb0005)
			} else if len(z.MinioEnvVars) > 0 {
				for key := range z.MinioEnvVars {
					delete(z.MinioEnvVars, key)
				}
			}
			for zb0005 > 0 {
				var za0005 string
				var za0006 string
				zb0005--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MinioEnvVars")
					return
				}
				za0006, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MinioEnvVars", za0005)
					return
				}
				z.MinioEnvVars[za0005] = za0006
			}
			zb0001Mask |= 0x4000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7fff {
		if (zb0001Mask & 0x1) == 0 {
			z.State = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Endpoint = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Scheme = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Uptime = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Version = ""
		}
		if (zb0001Mask & 0x20) == 0 {
			z.CommitID = ""
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Network = nil
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Disks = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.PoolNumber = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.PoolNumbers = nil
		}
		if (zb0001Mask & 0x400) == 0 {
			z.GoMaxProcs = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.NumCPU = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.RuntimeVersion = ""
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.GCStats = nil
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.MinioEnvVars = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ServerProperties) Msgsize() (s int) {
	s = 3 + 6 + msgp.StringPrefixSize + len(z.State) + 9 + msgp.StringPrefixSize + len(z.Endpoint) + 7 + msgp.StringPrefixSize + len(z.Scheme) + 7 + msgp.Int64Size + 8 + msgp.StringPrefixSize + len(z.Version) + 9 + msgp.StringPrefixSize + len(z.CommitID) + 8 + msgp.MapHeaderSize
	if z.Network != nil {
		for za0001, za0002 := range z.Network {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.StringPrefixSize + len(za0002)
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0003 := range z.Disks {
		s += z.Disks[za0003].Msgsize()
	}
	s += 11 + msgp.IntSize + 12 + msgp.ArrayHeaderSize + (len(z.PoolNumbers) * (msgp.IntSize)) + 10 + z.MemStats.Msgsize() + 13 + msgp.IntSize + 8 + msgp.IntSize + 16 + msgp.StringPrefixSize + len(z.RuntimeVersion) + 9
	if z.GCStats == nil {
		s += msgp.NilSize
	} else {
		s += z.GCStats.Msgsize()
	}
	s += 15 + msgp.MapHeaderSize
	if z.MinioEnvVars != nil {
		for za0005, za0006 := range z.MinioEnvVars {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + msgp.StringPrefixSize + len(za0006)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Services) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "kms":
			err = z.KMS.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "KMS")
				return
			}
			zb0001Mask |= 0x1
		case "kmsStatus":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "KMSStatus")
				return
			}
			if cap(z.KMSStatus) >= int(zb0002) {
				z.KMSStatus = (z.KMSStatus)[:zb0002]
			} else {
				z.KMSStatus = make([]KMS, zb0002)
			}
			for za0001 := range z.KMSStatus {
				err = z.KMSStatus[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "KMSStatus", za0001)
					return
				}
			}
			zb0001Mask |= 0x2
		case "ldap":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LDAP")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LDAP")
					return
				}
				switch msgp.UnsafeString(field) {
				case "status":
					z.LDAP.Status, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "LDAP", "Status")
						return
					}
					zb0003Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LDAP")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0003Mask != 0x1 {
				if (zb0003Mask & 0x1) == 0 {
					z.LDAP.Status = ""
				}
			}
			zb0001Mask |= 0x4
		case "logger":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Logger")
				return
			}
			if cap(z.Logger) >= int(zb0004) {
				z.Logger = (z.Logger)[:zb0004]
			} else {
				z.Logger = make([]Logger, zb0004)
			}
			for za0002 := range z.Logger {
				var zb0005 uint32
				zb0005, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Logger", za0002)
					return
				}
				if z.Logger[za0002] == nil {
					z.Logger[za0002] = make(Logger, zb0005)
				} else if len(z.Logger[za0002]) > 0 {
					for key := range z.Logger[za0002] {
						delete(z.Logger[za0002], key)
					}
				}
				for zb0005 > 0 {
					zb0005--
					var za0003 string
					var za0004 Status
					za0003, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Logger", za0002)
						return
					}
					var zb0006 uint32
					zb0006, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Logger", za0002, za0003)
						return
					}
					var zb0006Mask uint8 /* 1 bits */
					_ = zb0006Mask
					for zb0006 > 0 {
						zb0006--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Logger", za0002, za0003)
							return
						}
						switch msgp.UnsafeString(field) {
						case "status":
							za0004.Status, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "Logger", za0002, za0003, "Status")
								return
							}
							zb0006Mask |= 0x1
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Logger", za0002, za0003)
								return
							}
						}
					}
					// Clear omitted fields.
					if zb0006Mask != 0x1 {
						if (zb0006Mask & 0x1) == 0 {
							za0004.Status = ""
						}
					}
					z.Logger[za0002][za0003] = za0004
				}
			}
			zb0001Mask |= 0x8
		case "audit":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Audit")
				return
			}
			if cap(z.Audit) >= int(zb0007) {
				z.Audit = (z.Audit)[:zb0007]
			} else {
				z.Audit = make([]Audit, zb0007)
			}
			for za0005 := range z.Audit {
				var zb0008 uint32
				zb0008, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Audit", za0005)
					return
				}
				if z.Audit[za0005] == nil {
					z.Audit[za0005] = make(Audit, zb0008)
				} else if len(z.Audit[za0005]) > 0 {
					for key := range z.Audit[za0005] {
						delete(z.Audit[za0005], key)
					}
				}
				for zb0008 > 0 {
					zb0008--
					var za0006 string
					var za0007 Status
					za0006, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Audit", za0005)
						return
					}
					var zb0009 uint32
					zb0009, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Audit", za0005, za0006)
						return
					}
					var zb0009Mask uint8 /* 1 bits */
					_ = zb0009Mask
					for zb0009 > 0 {
						zb0009--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Audit", za0005, za0006)
							return
						}
						switch msgp.UnsafeString(field) {
						case "status":
							za0007.Status, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "Audit", za0005, za0006, "Status")
								return
							}
							zb0009Mask |= 0x1
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Audit", za0005, za0006)
								return
							}
						}
					}
					// Clear omitted fields.
					if zb0009Mask != 0x1 {
						if (zb0009Mask & 0x1) == 0 {
							za0007.Status = ""
						}
					}
					z.Audit[za0005][za0006] = za0007
				}
			}
			zb0001Mask |= 0x10
		case "notifications":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Notifications")
				return
			}
			if cap(z.Notifications) >= int(zb0010) {
				z.Notifications = (z.Notifications)[:zb0010]
			} else {
				z.Notifications = make([]map[string][]TargetIDStatus, zb0010)
			}
			for za0008 := range z.Notifications {
				var zb0011 uint32
				zb0011, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Notifications", za0008)
					return
				}
				if z.Notifications[za0008] == nil {
					z.Notifications[za0008] = make(map[string][]TargetIDStatus, zb0011)
				} else if len(z.Notifications[za0008]) > 0 {
					for key := range z.Notifications[za0008] {
						delete(z.Notifications[za0008], key)
					}
				}
				for zb0011 > 0 {
					zb0011--
					var za0009 string
					var za0010 []TargetIDStatus
					za0009, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Notifications", za0008)
						return
					}
					var zb0012 uint32
					zb0012, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Notifications", za0008, za0009)
						return
					}
					if cap(za0010) >= int(zb0012) {
						za0010 = (za0010)[:zb0012]
					} else {
						za0010 = make([]TargetIDStatus, zb0012)
					}
					for za0011 := range za0010 {
						var zb0013 uint32
						zb0013, err = dc.ReadMapHeader()
						if err != nil {
							err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011)
							return
						}
						if za0010[za0011] == nil {
							za0010[za0011] = make(TargetIDStatus, zb0013)
						} else if len(za0010[za0011]) > 0 {
							for key := range za0010[za0011] {
								delete(za0010[za0011], key)
							}
						}
						for zb0013 > 0 {
							zb0013--
							var za0012 string
							var za0013 Status
							za0012, err = dc.ReadString()
							if err != nil {
								err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011)
								return
							}
							var zb0014 uint32
							zb0014, err = dc.ReadMapHeader()
							if err != nil {
								err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012)
								return
							}
							var zb0014Mask uint8 /* 1 bits */
							_ = zb0014Mask
							for zb0014 > 0 {
								zb0014--
								field, err = dc.ReadMapKeyPtr()
								if err != nil {
									err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012)
									return
								}
								switch msgp.UnsafeString(field) {
								case "status":
									za0013.Status, err = dc.ReadString()
									if err != nil {
										err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012, "Status")
										return
									}
									zb0014Mask |= 0x1
								default:
									err = dc.Skip()
									if err != nil {
										err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012)
										return
									}
								}
							}
							// Clear omitted fields.
							if zb0014Mask != 0x1 {
								if (zb0014Mask & 0x1) == 0 {
									za0013.Status = ""
								}
							}
							za0010[za0011][za0012] = za0013
						}
					}
					z.Notifications[za0008][za0009] = za0010
				}
			}
			zb0001Mask |= 0x20
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3f {
		if (zb0001Mask & 0x1) == 0 {
			z.KMS = KMS{}
		}
		if (zb0001Mask & 0x2) == 0 {
			z.KMSStatus = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LDAP = (LDAP{})
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Logger = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Audit = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Notifications = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Services) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	if z.KMSStatus == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.LDAP == (LDAP{}) {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Logger == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Audit == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Notifications == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "kms"
	err = en.Append(0xa3, 0x6b, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = z.KMS.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "KMS")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "kmsStatus"
		err = en.Append(0xa9, 0x6b, 0x6d, 0x73, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.KMSStatus)))
		if err != nil {
			err = msgp.WrapError(err, "KMSStatus")
			return
		}
		for za0001 := range z.KMSStatus {
			err = z.KMSStatus[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "KMSStatus", za0001)
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// write "ldap"
		err = en.Append(0xa4, 0x6c, 0x64, 0x61, 0x70)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LDAP.Status == "" {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// write "status"
			err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			if err != nil {
				return
			}
			err = en.WriteString(z.LDAP.Status)
			if err != nil {
				err = msgp.WrapError(err, "LDAP", "Status")
				return
			}
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// write "logger"
		err = en.Append(0xa6, 0x6c, 0x6f, 0x67, 0x67, 0x65, 0x72)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Logger)))
		if err != nil {
			err = msgp.WrapError(err, "Logger")
			return
		}
		for za0002 := range z.Logger {
			err = en.WriteMapHeader(uint32(len(z.Logger[za0002])))
			if err != nil {
				err = msgp.WrapError(err, "Logger", za0002)
				return
			}
			for za0003, za0004 := range z.Logger[za0002] {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "Logger", za0002)
					return
				}
				// check for omitted fields
				zb0003Len := uint32(1)
				var zb0003Mask uint8 /* 1 bits */
				_ = zb0003Mask
				if za0004.Status == "" {
					zb0003Len--
					zb0003Mask |= 0x1
				}
				// variable map header, size zb0003Len
				err = en.Append(0x80 | uint8(zb0003Len))
				if err != nil {
					return
				}
				if zb0003Len == 0 {
					return
				}
				if (zb0003Mask & 0x1) == 0 { // if not omitted
					// write "status"
					err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
					if err != nil {
						return
					}
					err = en.WriteString(za0004.Status)
					if err != nil {
						err = msgp.WrapError(err, "Logger", za0002, za0003, "Status")
						return
					}
				}
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// write "audit"
		err = en.Append(0xa5, 0x61, 0x75, 0x64, 0x69, 0x74)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Audit)))
		if err != nil {
			err = msgp.WrapError(err, "Audit")
			return
		}
		for za0005 := range z.Audit {
			err = en.WriteMapHeader(uint32(len(z.Audit[za0005])))
			if err != nil {
				err = msgp.WrapError(err, "Audit", za0005)
				return
			}
			for za0006, za0007 := range z.Audit[za0005] {
				err = en.WriteString(za0006)
				if err != nil {
					err = msgp.WrapError(err, "Audit", za0005)
					return
				}
				// check for omitted fields
				zb0004Len := uint32(1)
				var zb0004Mask uint8 /* 1 bits */
				_ = zb0004Mask
				if za0007.Status == "" {
					zb0004Len--
					zb0004Mask |= 0x1
				}
				// variable map header, size zb0004Len
				err = en.Append(0x80 | uint8(zb0004Len))
				if err != nil {
					return
				}
				if zb0004Len == 0 {
					return
				}
				if (zb0004Mask & 0x1) == 0 { // if not omitted
					// write "status"
					err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
					if err != nil {
						return
					}
					err = en.WriteString(za0007.Status)
					if err != nil {
						err = msgp.WrapError(err, "Audit", za0005, za0006, "Status")
						return
					}
				}
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// write "notifications"
		err = en.Append(0xad, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Notifications)))
		if err != nil {
			err = msgp.WrapError(err, "Notifications")
			return
		}
		for za0008 := range z.Notifications {
			err = en.WriteMapHeader(uint32(len(z.Notifications[za0008])))
			if err != nil {
				err = msgp.WrapError(err, "Notifications", za0008)
				return
			}
			for za0009, za0010 := range z.Notifications[za0008] {
				err = en.WriteString(za0009)
				if err != nil {
					err = msgp.WrapError(err, "Notifications", za0008)
					return
				}
				err = en.WriteArrayHeader(uint32(len(za0010)))
				if err != nil {
					err = msgp.WrapError(err, "Notifications", za0008, za0009)
					return
				}
				for za0011 := range za0010 {
					err = en.WriteMapHeader(uint32(len(za0010[za0011])))
					if err != nil {
						err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011)
						return
					}
					for za0012, za0013 := range za0010[za0011] {
						err = en.WriteString(za0012)
						if err != nil {
							err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011)
							return
						}
						// check for omitted fields
						zb0005Len := uint32(1)
						var zb0005Mask uint8 /* 1 bits */
						_ = zb0005Mask
						if za0013.Status == "" {
							zb0005Len--
							zb0005Mask |= 0x1
						}
						// variable map header, size zb0005Len
						err = en.Append(0x80 | uint8(zb0005Len))
						if err != nil {
							return
						}
						if zb0005Len == 0 {
							return
						}
						if (zb0005Mask & 0x1) == 0 { // if not omitted
							// write "status"
							err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
							if err != nil {
								return
							}
							err = en.WriteString(za0013.Status)
							if err != nil {
								err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012, "Status")
								return
							}
						}
					}
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Services) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	if z.KMSStatus == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.LDAP == (LDAP{}) {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Logger == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Audit == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Notifications == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "kms"
	o = append(o, 0xa3, 0x6b, 0x6d, 0x73)
	o, err = z.KMS.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "KMS")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "kmsStatus"
		o = append(o, 0xa9, 0x6b, 0x6d, 0x73, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.KMSStatus)))
		for za0001 := range z.KMSStatus {
			o, err = z.KMSStatus[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "KMSStatus", za0001)
				return
			}
		}
	}
	if (zb0001Mask & 0x4) == 0 { // if not omitted
		// string "ldap"
		o = append(o, 0xa4, 0x6c, 0x64, 0x61, 0x70)
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LDAP.Status == "" {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// string "status"
			o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			o = msgp.AppendString(o, z.LDAP.Status)
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not omitted
		// string "logger"
		o = append(o, 0xa6, 0x6c, 0x6f, 0x67, 0x67, 0x65, 0x72)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Logger)))
		for za0002 := range z.Logger {
			o = msgp.AppendMapHeader(o, uint32(len(z.Logger[za0002])))
			for za0003, za0004 := range z.Logger[za0002] {
				o = msgp.AppendString(o, za0003)
				// check for omitted fields
				zb0003Len := uint32(1)
				var zb0003Mask uint8 /* 1 bits */
				_ = zb0003Mask
				if za0004.Status == "" {
					zb0003Len--
					zb0003Mask |= 0x1
				}
				// variable map header, size zb0003Len
				o = append(o, 0x80|uint8(zb0003Len))
				if zb0003Len == 0 {
					return
				}
				if (zb0003Mask & 0x1) == 0 { // if not omitted
					// string "status"
					o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
					o = msgp.AppendString(o, za0004.Status)
				}
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// string "audit"
		o = append(o, 0xa5, 0x61, 0x75, 0x64, 0x69, 0x74)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Audit)))
		for za0005 := range z.Audit {
			o = msgp.AppendMapHeader(o, uint32(len(z.Audit[za0005])))
			for za0006, za0007 := range z.Audit[za0005] {
				o = msgp.AppendString(o, za0006)
				// check for omitted fields
				zb0004Len := uint32(1)
				var zb0004Mask uint8 /* 1 bits */
				_ = zb0004Mask
				if za0007.Status == "" {
					zb0004Len--
					zb0004Mask |= 0x1
				}
				// variable map header, size zb0004Len
				o = append(o, 0x80|uint8(zb0004Len))
				if zb0004Len == 0 {
					return
				}
				if (zb0004Mask & 0x1) == 0 { // if not omitted
					// string "status"
					o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
					o = msgp.AppendString(o, za0007.Status)
				}
			}
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not omitted
		// string "notifications"
		o = append(o, 0xad, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Notifications)))
		for za0008 := range z.Notifications {
			o = msgp.AppendMapHeader(o, uint32(len(z.Notifications[za0008])))
			for za0009, za0010 := range z.Notifications[za0008] {
				o = msgp.AppendString(o, za0009)
				o = msgp.AppendArrayHeader(o, uint32(len(za0010)))
				for za0011 := range za0010 {
					o = msgp.AppendMapHeader(o, uint32(len(za0010[za0011])))
					for za0012, za0013 := range za0010[za0011] {
						o = msgp.AppendString(o, za0012)
						// check for omitted fields
						zb0005Len := uint32(1)
						var zb0005Mask uint8 /* 1 bits */
						_ = zb0005Mask
						if za0013.Status == "" {
							zb0005Len--
							zb0005Mask |= 0x1
						}
						// variable map header, size zb0005Len
						o = append(o, 0x80|uint8(zb0005Len))
						if zb0005Len == 0 {
							return
						}
						if (zb0005Mask & 0x1) == 0 { // if not omitted
							// string "status"
							o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
							o = msgp.AppendString(o, za0013.Status)
						}
					}
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Services) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "kms":
			bts, err = z.KMS.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "KMS")
				return
			}
			zb0001Mask |= 0x1
		case "kmsStatus":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KMSStatus")
				return
			}
			if cap(z.KMSStatus) >= int(zb0002) {
				z.KMSStatus = (z.KMSStatus)[:zb0002]
			} else {
				z.KMSStatus = make([]KMS, zb0002)
			}
			for za0001 := range z.KMSStatus {
				bts, err = z.KMSStatus[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "KMSStatus", za0001)
					return
				}
			}
			zb0001Mask |= 0x2
		case "ldap":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LDAP")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LDAP")
					return
				}
				switch msgp.UnsafeString(field) {
				case "status":
					z.LDAP.Status, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LDAP", "Status")
						return
					}
					zb0003Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LDAP")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0003Mask != 0x1 {
				if (zb0003Mask & 0x1) == 0 {
					z.LDAP.Status = ""
				}
			}
			zb0001Mask |= 0x4
		case "logger":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Logger")
				return
			}
			if cap(z.Logger) >= int(zb0004) {
				z.Logger = (z.Logger)[:zb0004]
			} else {
				z.Logger = make([]Logger, zb0004)
			}
			for za0002 := range z.Logger {
				var zb0005 uint32
				zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Logger", za0002)
					return
				}
				if z.Logger[za0002] == nil {
					z.Logger[za0002] = make(Logger, zb0005)
				} else if len(z.Logger[za0002]) > 0 {
					for key := range z.Logger[za0002] {
						delete(z.Logger[za0002], key)
					}
				}
				for zb0005 > 0 {
					var za0003 string
					var za0004 Status
					zb0005--
					za0003, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Logger", za0002)
						return
					}
					var zb0006 uint32
					zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Logger", za0002, za0003)
						return
					}
					var zb0006Mask uint8 /* 1 bits */
					_ = zb0006Mask
					for zb0006 > 0 {
						zb0006--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Logger", za0002, za0003)
							return
						}
						switch msgp.UnsafeString(field) {
						case "status":
							za0004.Status, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Logger", za0002, za0003, "Status")
								return
							}
							zb0006Mask |= 0x1
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Logger", za0002, za0003)
								return
							}
						}
					}
					// Clear omitted fields.
					if zb0006Mask != 0x1 {
						if (zb0006Mask & 0x1) == 0 {
							za0004.Status = ""
						}
					}
					z.Logger[za0002][za0003] = za0004
				}
			}
			zb0001Mask |= 0x8
		case "audit":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Audit")
				return
			}
			if cap(z.Audit) >= int(zb0007) {
				z.Audit = (z.Audit)[:zb0007]
			} else {
				z.Audit = make([]Audit, zb0007)
			}
			for za0005 := range z.Audit {
				var zb0008 uint32
				zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Audit", za0005)
					return
				}
				if z.Audit[za0005] == nil {
					z.Audit[za0005] = make(Audit, zb0008)
				} else if len(z.Audit[za0005]) > 0 {
					for key := range z.Audit[za0005] {
						delete(z.Audit[za0005], key)
					}
				}
				for zb0008 > 0 {
					var za0006 string
					var za0007 Status
					zb0008--
					za0006, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Audit", za0005)
						return
					}
					var zb0009 uint32
					zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Audit", za0005, za0006)
						return
					}
					var zb0009Mask uint8 /* 1 bits */
					_ = zb0009Mask
					for zb0009 > 0 {
						zb0009--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Audit", za0005, za0006)
							return
						}
						switch msgp.UnsafeString(field) {
						case "status":
							za0007.Status, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Audit", za0005, za0006, "Status")
								return
							}
							zb0009Mask |= 0x1
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Audit", za0005, za0006)
								return
							}
						}
					}
					// Clear omitted fields.
					if zb0009Mask != 0x1 {
						if (zb0009Mask & 0x1) == 0 {
							za0007.Status = ""
						}
					}
					z.Audit[za0005][za0006] = za0007
				}
			}
			zb0001Mask |= 0x10
		case "notifications":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Notifications")
				return
			}
			if cap(z.Notifications) >= int(zb0010) {
				z.Notifications = (z.Notifications)[:zb0010]
			} else {
				z.Notifications = make([]map[string][]TargetIDStatus, zb0010)
			}
			for za0008 := range z.Notifications {
				var zb0011 uint32
				zb0011, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Notifications", za0008)
					return
				}
				if z.Notifications[za0008] == nil {
					z.Notifications[za0008] = make(map[string][]TargetIDStatus, zb0011)
				} else if len(z.Notifications[za0008]) > 0 {
					for key := range z.Notifications[za0008] {
						delete(z.Notifications[za0008], key)
					}
				}
				for zb0011 > 0 {
					var za0009 string
					var za0010 []TargetIDStatus
					zb0011--
					za0009, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Notifications", za0008)
						return
					}
					var zb0012 uint32
					zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Notifications", za0008, za0009)
						return
					}
					if cap(za0010) >= int(zb0012) {
						za0010 = (za0010)[:zb0012]
					} else {
						za0010 = make([]TargetIDStatus, zb0012)
					}
					for za0011 := range za0010 {
						var zb0013 uint32
						zb0013, bts, err = msgp.ReadMapHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011)
							return
						}
						if za0010[za0011] == nil {
							za0010[za0011] = make(TargetIDStatus, zb0013)
						} else if len(za0010[za0011]) > 0 {
							for key := range za0010[za0011] {
								delete(za0010[za0011], key)
							}
						}
						for zb0013 > 0 {
							var za0012 string
							var za0013 Status
							zb0013--
							za0012, bts, err = msgp.ReadStringBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011)
								return
							}
							var zb0014 uint32
							zb0014, bts, err = msgp.ReadMapHeaderBytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012)
								return
							}
							var zb0014Mask uint8 /* 1 bits */
							_ = zb0014Mask
							for zb0014 > 0 {
								zb0014--
								field, bts, err = msgp.ReadMapKeyZC(bts)
								if err != nil {
									err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012)
									return
								}
								switch msgp.UnsafeString(field) {
								case "status":
									za0013.Status, bts, err = msgp.ReadStringBytes(bts)
									if err != nil {
										err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012, "Status")
										return
									}
									zb0014Mask |= 0x1
								default:
									bts, err = msgp.Skip(bts)
									if err != nil {
										err = msgp.WrapError(err, "Notifications", za0008, za0009, za0011, za0012)
										return
									}
								}
							}
							// Clear omitted fields.
							if zb0014Mask != 0x1 {
								if (zb0014Mask & 0x1) == 0 {
									za0013.Status = ""
								}
							}
							za0010[za0011][za0012] = za0013
						}
					}
					z.Notifications[za0008][za0009] = za0010
				}
			}
			zb0001Mask |= 0x20
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3f {
		if (zb0001Mask & 0x1) == 0 {
			z.KMS = KMS{}
		}
		if (zb0001Mask & 0x2) == 0 {
			z.KMSStatus = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LDAP = (LDAP{})
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Logger = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Audit = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Notifications = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Services) Msgsize() (s int) {
	s = 1 + 4 + z.KMS.Msgsize() + 10 + msgp.ArrayHeaderSize
	for za0001 := range z.KMSStatus {
		s += z.KMSStatus[za0001].Msgsize()
	}
	s += 5 + 1 + 7 + msgp.StringPrefixSize + len(z.LDAP.Status) + 7 + msgp.ArrayHeaderSize
	for za0002 := range z.Logger {
		s += msgp.MapHeaderSize
		if z.Logger[za0002] != nil {
			for za0003, za0004 := range z.Logger[za0002] {
				_ = za0004
				s += msgp.StringPrefixSize + len(za0003) + 1 + 7 + msgp.StringPrefixSize + len(za0004.Status)
			}
		}
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0005 := range z.Audit {
		s += msgp.MapHeaderSize
		if z.Audit[za0005] != nil {
			for za0006, za0007 := range z.Audit[za0005] {
				_ = za0007
				s += msgp.StringPrefixSize + len(za0006) + 1 + 7 + msgp.StringPrefixSize + len(za0007.Status)
			}
		}
	}
	s += 14 + msgp.ArrayHeaderSize
	for za0008 := range z.Notifications {
		s += msgp.MapHeaderSize
		if z.Notifications[za0008] != nil {
			for za0009, za0010 := range z.Notifications[za0008] {
				_ = za0010
				s += msgp.StringPrefixSize + len(za0009) + msgp.ArrayHeaderSize
				for za0011 := range za0010 {
					s += msgp.MapHeaderSize
					if za0010[za0011] != nil {
						for za0012, za0013 := range za0010[za0011] {
							_ = za0013
							s += msgp.StringPrefixSize + len(za0012) + 1 + 7 + msgp.StringPrefixSize + len(za0013.Status)
						}
					}
				}
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Status) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "status":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Status = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Status) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	if z.Status == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// write "status"
		err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		if err != nil {
			return
		}
		err = en.WriteString(z.Status)
		if err != nil {
			err = msgp.WrapError(err, "Status")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Status) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	if z.Status == "" {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not omitted
		// string "status"
		o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		o = msgp.AppendString(o, z.Status)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Status) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "status":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Status = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Status) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Status)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StorageInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Disks":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0002) {
				z.Disks = (z.Disks)[:zb0002]
			} else {
				z.Disks = make([]Disk, zb0002)
			}
			for za0001 := range z.Disks {
				err = z.Disks[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0001)
					return
				}
			}
		case "Backend":
			err = z.Backend.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Backend")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *StorageInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Disks"
	err = en.Append(0x82, 0xa5, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Disks)))
	if err != nil {
		err = msgp.WrapError(err, "Disks")
		return
	}
	for za0001 := range z.Disks {
		err = z.Disks[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0001)
			return
		}
	}
	// write "Backend"
	err = en.Append(0xa7, 0x42, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = z.Backend.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Backend")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StorageInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Disks"
	o = append(o, 0x82, 0xa5, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Disks)))
	for za0001 := range z.Disks {
		o, err = z.Disks[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0001)
			return
		}
	}
	// string "Backend"
	o = append(o, 0xa7, 0x42, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64)
	o, err = z.Backend.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Backend")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StorageInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Disks":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0002) {
				z.Disks = (z.Disks)[:zb0002]
			} else {
				z.Disks = make([]Disk, zb0002)
			}
			for za0001 := range z.Disks {
				bts, err = z.Disks[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0001)
					return
				}
			}
		case "Backend":
			bts, err = z.Backend.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Backend")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StorageInfo) Msgsize() (s int) {
	s = 1 + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Disks {
		s += z.Disks[za0001].Msgsize()
	}
	s += 8 + z.Backend.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TargetIDStatus) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0003 uint32
	zb0003, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(TargetIDStatus, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		zb0003--
		var zb0001 string
		var zb0002 Status
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0004 uint32
		zb0004, err = dc.ReadMapHeader()
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		var zb0004Mask uint8 /* 1 bits */
		_ = zb0004Mask
		for zb0004 > 0 {
			zb0004--
			field, err = dc.ReadMapKeyPtr()
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "status":
				zb0002.Status, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Status")
					return
				}
				zb0004Mask |= 0x1
			default:
				err = dc.Skip()
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
		// Clear omitted fields.
		if zb0004Mask != 0x1 {
			if (zb0004Mask & 0x1) == 0 {
				zb0002.Status = ""
			}
		}
		(*z)[zb0001] = zb0002
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TargetIDStatus) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteMapHeader(uint32(len(z)))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0005, zb0006 := range z {
		err = en.WriteString(zb0005)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		// check for omitted fields
		zb0001Len := uint32(1)
		var zb0001Mask uint8 /* 1 bits */
		_ = zb0001Mask
		if zb0006.Status == "" {
			zb0001Len--
			zb0001Mask |= 0x1
		}
		// variable map header, size zb0001Len
		err = en.Append(0x80 | uint8(zb0001Len))
		if err != nil {
			return
		}
		if zb0001Len == 0 {
			return
		}
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "status"
			err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			if err != nil {
				return
			}
			err = en.WriteString(zb0006.Status)
			if err != nil {
				err = msgp.WrapError(err, zb0005, "Status")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TargetIDStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendMapHeader(o, uint32(len(z)))
	for zb0005, zb0006 := range z {
		o = msgp.AppendString(o, zb0005)
		// check for omitted fields
		zb0001Len := uint32(1)
		var zb0001Mask uint8 /* 1 bits */
		_ = zb0001Mask
		if zb0006.Status == "" {
			zb0001Len--
			zb0001Mask |= 0x1
		}
		// variable map header, size zb0001Len
		o = append(o, 0x80|uint8(zb0001Len))
		if zb0001Len == 0 {
			return
		}
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "status"
			o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
			o = msgp.AppendString(o, zb0006.Status)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TargetIDStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0003 uint32
	zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if (*z) == nil {
		(*z) = make(TargetIDStatus, zb0003)
	} else if len((*z)) > 0 {
		for key := range *z {
			delete((*z), key)
		}
	}
	var field []byte
	_ = field
	for zb0003 > 0 {
		var zb0001 string
		var zb0002 Status
		zb0003--
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		var zb0004 uint32
		zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err, zb0001)
			return
		}
		var zb0004Mask uint8 /* 1 bits */
		_ = zb0004Mask
		for zb0004 > 0 {
			zb0004--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err, zb0001)
				return
			}
			switch msgp.UnsafeString(field) {
			case "status":
				zb0002.Status, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001, "Status")
					return
				}
				zb0004Mask |= 0x1
			default:
				bts, err = msgp.Skip(bts)
				if err != nil {
					err = msgp.WrapError(err, zb0001)
					return
				}
			}
		}
		// Clear omitted fields.
		if zb0004Mask != 0x1 {
			if (zb0004Mask & 0x1) == 0 {
				zb0002.Status = ""
			}
		}
		(*z)[zb0001] = zb0002
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TargetIDStatus) Msgsize() (s int) {
	s = msgp.MapHeaderSize
	if z != nil {
		for zb0005, zb0006 := range z {
			_ = zb0006
			s += msgp.StringPrefixSize + len(zb0005) + 1 + 7 + msgp.StringPrefixSize + len(zb0006.Status)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TierStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "totalSize":
			z.TotalSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalSize")
				return
			}
		case "numVersions":
			z.NumVersions, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NumVersions")
				return
			}
		case "numObjects":
			z.NumObjects, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NumObjects")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TierStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "totalSize"
	err = en.Append(0x83, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalSize)
	if err != nil {
		err = msgp.WrapError(err, "TotalSize")
		return
	}
	// write "numVersions"
	err = en.Append(0xab, 0x6e, 0x75, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.NumVersions)
	if err != nil {
		err = msgp.WrapError(err, "NumVersions")
		return
	}
	// write "numObjects"
	err = en.Append(0xaa, 0x6e, 0x75, 0x6d, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.NumObjects)
	if err != nil {
		err = msgp.WrapError(err, "NumObjects")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TierStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "totalSize"
	o = append(o, 0x83, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.TotalSize)
	// string "numVersions"
	o = append(o, 0xab, 0x6e, 0x75, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendInt(o, z.NumVersions)
	// string "numObjects"
	o = append(o, 0xaa, 0x6e, 0x75, 0x6d, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt(o, z.NumObjects)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TierStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "totalSize":
			z.TotalSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSize")
				return
			}
		case "numVersions":
			z.NumVersions, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumVersions")
				return
			}
		case "numObjects":
			z.NumObjects, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumObjects")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TierStats) Msgsize() (s int) {
	s = 1 + 10 + msgp.Uint64Size + 12 + msgp.IntSize + 11 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Usage) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "size":
			z.Size, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "error":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Usage) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "size"
	err = en.Append(0xa4, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Size)
	if err != nil {
		err = msgp.WrapError(err, "Size")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "error"
		err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.Error)
		if err != nil {
			err = msgp.WrapError(err, "Error")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Usage) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "size"
	o = append(o, 0xa4, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.Size)
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "error"
		o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		o = msgp.AppendString(o, z.Error)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Usage) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "size":
			z.Size, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "error":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Usage) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Error)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Versions) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "error":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Versions) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "count"
	err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// write "error"
		err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.Error)
		if err != nil {
			err = msgp.WrapError(err, "Error")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Versions) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "count"
	o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.Count)
	if (zb0001Mask & 0x2) == 0 { // if not omitted
		// string "error"
		o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
		o = msgp.AppendString(o, z.Error)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Versions) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "count":
			z.Count, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "error":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Error = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Versions) Msgsize() (s int) {
	s = 1 + 6 + msgp.Uint64Size + 6 + msgp.StringPrefixSize + len(z.Error)
	return
}
