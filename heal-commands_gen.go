package madmin

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *BgHealState) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "offline_nodes":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OfflineEndpoints")
				return
			}
			if cap(z.OfflineEndpoints) >= int(zb0002) {
				z.OfflineEndpoints = (z.OfflineEndpoints)[:zb0002]
			} else {
				z.OfflineEndpoints = make([]string, zb0002)
			}
			for za0001 := range z.OfflineEndpoints {
				z.OfflineEndpoints[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "OfflineEndpoints", za0001)
					return
				}
			}
		case "ScannedItemsCount":
			z.ScannedItemsCount, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ScannedItemsCount")
				return
			}
		case "HealDisks":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HealDisks")
				return
			}
			if cap(z.HealDisks) >= int(zb0003) {
				z.HealDisks = (z.HealDisks)[:zb0003]
			} else {
				z.HealDisks = make([]string, zb0003)
			}
			for za0002 := range z.HealDisks {
				z.HealDisks[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HealDisks", za0002)
					return
				}
			}
		case "sets":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Sets")
				return
			}
			if cap(z.Sets) >= int(zb0004) {
				z.Sets = (z.Sets)[:zb0004]
			} else {
				z.Sets = make([]SetStatus, zb0004)
			}
			for za0003 := range z.Sets {
				err = z.Sets[za0003].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Sets", za0003)
					return
				}
			}
		case "mrf":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "MRF")
				return
			}
			if z.MRF == nil {
				z.MRF = make(map[string]MRFStatus, zb0005)
			} else if len(z.MRF) > 0 {
				for key := range z.MRF {
					delete(z.MRF, key)
				}
			}
			for zb0005 > 0 {
				zb0005--
				var za0004 string
				var za0005 MRFStatus
				za0004, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "MRF")
					return
				}
				var zb0006 uint32
				zb0006, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "MRF", za0004)
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "MRF", za0004)
						return
					}
					switch msgp.UnsafeString(field) {
					case "bytes_healed":
						za0005.BytesHealed, err = dc.ReadUint64()
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004, "BytesHealed")
							return
						}
					case "items_healed":
						za0005.ItemsHealed, err = dc.ReadUint64()
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004, "ItemsHealed")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004)
							return
						}
					}
				}
				z.MRF[za0004] = za0005
			}
		case "sc_parity":
			var zb0007 uint32
			zb0007, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "SCParity")
				return
			}
			if z.SCParity == nil {
				z.SCParity = make(map[string]int, zb0007)
			} else if len(z.SCParity) > 0 {
				for key := range z.SCParity {
					delete(z.SCParity, key)
				}
			}
			for zb0007 > 0 {
				zb0007--
				var za0006 string
				var za0007 int
				za0006, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "SCParity")
					return
				}
				za0007, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SCParity", za0006)
					return
				}
				z.SCParity[za0006] = za0007
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BgHealState) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "offline_nodes"
	err = en.Append(0x86, 0xad, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.OfflineEndpoints)))
	if err != nil {
		err = msgp.WrapError(err, "OfflineEndpoints")
		return
	}
	for za0001 := range z.OfflineEndpoints {
		err = en.WriteString(z.OfflineEndpoints[za0001])
		if err != nil {
			err = msgp.WrapError(err, "OfflineEndpoints", za0001)
			return
		}
	}
	// write "ScannedItemsCount"
	err = en.Append(0xb1, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ScannedItemsCount)
	if err != nil {
		err = msgp.WrapError(err, "ScannedItemsCount")
		return
	}
	// write "HealDisks"
	err = en.Append(0xa9, 0x48, 0x65, 0x61, 0x6c, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.HealDisks)))
	if err != nil {
		err = msgp.WrapError(err, "HealDisks")
		return
	}
	for za0002 := range z.HealDisks {
		err = en.WriteString(z.HealDisks[za0002])
		if err != nil {
			err = msgp.WrapError(err, "HealDisks", za0002)
			return
		}
	}
	// write "sets"
	err = en.Append(0xa4, 0x73, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Sets)))
	if err != nil {
		err = msgp.WrapError(err, "Sets")
		return
	}
	for za0003 := range z.Sets {
		err = z.Sets[za0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Sets", za0003)
			return
		}
	}
	// write "mrf"
	err = en.Append(0xa3, 0x6d, 0x72, 0x66)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.MRF)))
	if err != nil {
		err = msgp.WrapError(err, "MRF")
		return
	}
	for za0004, za0005 := range z.MRF {
		err = en.WriteString(za0004)
		if err != nil {
			err = msgp.WrapError(err, "MRF")
			return
		}
		// map header, size 2
		// write "bytes_healed"
		err = en.Append(0x82, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(za0005.BytesHealed)
		if err != nil {
			err = msgp.WrapError(err, "MRF", za0004, "BytesHealed")
			return
		}
		// write "items_healed"
		err = en.Append(0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(za0005.ItemsHealed)
		if err != nil {
			err = msgp.WrapError(err, "MRF", za0004, "ItemsHealed")
			return
		}
	}
	// write "sc_parity"
	err = en.Append(0xa9, 0x73, 0x63, 0x5f, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.SCParity)))
	if err != nil {
		err = msgp.WrapError(err, "SCParity")
		return
	}
	for za0006, za0007 := range z.SCParity {
		err = en.WriteString(za0006)
		if err != nil {
			err = msgp.WrapError(err, "SCParity")
			return
		}
		err = en.WriteInt(za0007)
		if err != nil {
			err = msgp.WrapError(err, "SCParity", za0006)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BgHealState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "offline_nodes"
	o = append(o, 0x86, 0xad, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OfflineEndpoints)))
	for za0001 := range z.OfflineEndpoints {
		o = msgp.AppendString(o, z.OfflineEndpoints[za0001])
	}
	// string "ScannedItemsCount"
	o = append(o, 0xb1, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt64(o, z.ScannedItemsCount)
	// string "HealDisks"
	o = append(o, 0xa9, 0x48, 0x65, 0x61, 0x6c, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.HealDisks)))
	for za0002 := range z.HealDisks {
		o = msgp.AppendString(o, z.HealDisks[za0002])
	}
	// string "sets"
	o = append(o, 0xa4, 0x73, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Sets)))
	for za0003 := range z.Sets {
		o, err = z.Sets[za0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Sets", za0003)
			return
		}
	}
	// string "mrf"
	o = append(o, 0xa3, 0x6d, 0x72, 0x66)
	o = msgp.AppendMapHeader(o, uint32(len(z.MRF)))
	for za0004, za0005 := range z.MRF {
		o = msgp.AppendString(o, za0004)
		// map header, size 2
		// string "bytes_healed"
		o = append(o, 0x82, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
		o = msgp.AppendUint64(o, za0005.BytesHealed)
		// string "items_healed"
		o = append(o, 0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
		o = msgp.AppendUint64(o, za0005.ItemsHealed)
	}
	// string "sc_parity"
	o = append(o, 0xa9, 0x73, 0x63, 0x5f, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendMapHeader(o, uint32(len(z.SCParity)))
	for za0006, za0007 := range z.SCParity {
		o = msgp.AppendString(o, za0006)
		o = msgp.AppendInt(o, za0007)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BgHealState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "offline_nodes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OfflineEndpoints")
				return
			}
			if cap(z.OfflineEndpoints) >= int(zb0002) {
				z.OfflineEndpoints = (z.OfflineEndpoints)[:zb0002]
			} else {
				z.OfflineEndpoints = make([]string, zb0002)
			}
			for za0001 := range z.OfflineEndpoints {
				z.OfflineEndpoints[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OfflineEndpoints", za0001)
					return
				}
			}
		case "ScannedItemsCount":
			z.ScannedItemsCount, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ScannedItemsCount")
				return
			}
		case "HealDisks":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealDisks")
				return
			}
			if cap(z.HealDisks) >= int(zb0003) {
				z.HealDisks = (z.HealDisks)[:zb0003]
			} else {
				z.HealDisks = make([]string, zb0003)
			}
			for za0002 := range z.HealDisks {
				z.HealDisks[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HealDisks", za0002)
					return
				}
			}
		case "sets":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sets")
				return
			}
			if cap(z.Sets) >= int(zb0004) {
				z.Sets = (z.Sets)[:zb0004]
			} else {
				z.Sets = make([]SetStatus, zb0004)
			}
			for za0003 := range z.Sets {
				bts, err = z.Sets[za0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sets", za0003)
					return
				}
			}
		case "mrf":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MRF")
				return
			}
			if z.MRF == nil {
				z.MRF = make(map[string]MRFStatus, zb0005)
			} else if len(z.MRF) > 0 {
				for key := range z.MRF {
					delete(z.MRF, key)
				}
			}
			for zb0005 > 0 {
				var za0004 string
				var za0005 MRFStatus
				zb0005--
				za0004, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MRF")
					return
				}
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MRF", za0004)
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "MRF", za0004)
						return
					}
					switch msgp.UnsafeString(field) {
					case "bytes_healed":
						za0005.BytesHealed, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004, "BytesHealed")
							return
						}
					case "items_healed":
						za0005.ItemsHealed, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004, "ItemsHealed")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004)
							return
						}
					}
				}
				z.MRF[za0004] = za0005
			}
		case "sc_parity":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SCParity")
				return
			}
			if z.SCParity == nil {
				z.SCParity = make(map[string]int, zb0007)
			} else if len(z.SCParity) > 0 {
				for key := range z.SCParity {
					delete(z.SCParity, key)
				}
			}
			for zb0007 > 0 {
				var za0006 string
				var za0007 int
				zb0007--
				za0006, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SCParity")
					return
				}
				za0007, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SCParity", za0006)
					return
				}
				z.SCParity[za0006] = za0007
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BgHealState) Msgsize() (s int) {
	s = 1 + 14 + msgp.ArrayHeaderSize
	for za0001 := range z.OfflineEndpoints {
		s += msgp.StringPrefixSize + len(z.OfflineEndpoints[za0001])
	}
	s += 18 + msgp.Int64Size + 10 + msgp.ArrayHeaderSize
	for za0002 := range z.HealDisks {
		s += msgp.StringPrefixSize + len(z.HealDisks[za0002])
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0003 := range z.Sets {
		s += z.Sets[za0003].Msgsize()
	}
	s += 4 + msgp.MapHeaderSize
	if z.MRF != nil {
		for za0004, za0005 := range z.MRF {
			_ = za0005
			s += msgp.StringPrefixSize + len(za0004) + 1 + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size
		}
	}
	s += 10 + msgp.MapHeaderSize
	if z.SCParity != nil {
		for za0006, za0007 := range z.SCParity {
			_ = za0007
			s += msgp.StringPrefixSize + len(za0006) + msgp.IntSize
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealDriveInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uuid":
			z.UUID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UUID")
				return
			}
		case "endpoint":
			z.Endpoint, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "state":
			z.State, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealDriveInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "uuid"
	err = en.Append(0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.UUID)
	if err != nil {
		err = msgp.WrapError(err, "UUID")
		return
	}
	// write "endpoint"
	err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Endpoint)
	if err != nil {
		err = msgp.WrapError(err, "Endpoint")
		return
	}
	// write "state"
	err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.State)
	if err != nil {
		err = msgp.WrapError(err, "State")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealDriveInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "uuid"
	o = append(o, 0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
	o = msgp.AppendString(o, z.UUID)
	// string "endpoint"
	o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Endpoint)
	// string "state"
	o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
	o = msgp.AppendString(o, z.State)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealDriveInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uuid":
			z.UUID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UUID")
				return
			}
		case "endpoint":
			z.Endpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "state":
			z.State, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealDriveInfo) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.UUID) + 9 + msgp.StringPrefixSize + len(z.Endpoint) + 6 + msgp.StringPrefixSize + len(z.State)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealItemType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealItemType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealItemType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealItemType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealItemType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealItemType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealItemType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealOpts) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "recursive":
			z.Recursive, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Recursive")
				return
			}
		case "dryRun":
			z.DryRun, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "DryRun")
				return
			}
		case "remove":
			z.Remove, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
		case "recreate":
			z.Recreate, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Recreate")
				return
			}
		case "scanMode":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ScanMode")
					return
				}
				z.ScanMode = HealScanMode(zb0002)
			}
		case "updateParity":
			z.UpdateParity, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "UpdateParity")
				return
			}
		case "nolock":
			z.NoLock, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "NoLock")
				return
			}
		case "pool":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Pool")
					return
				}
				z.Pool = nil
			} else {
				if z.Pool == nil {
					z.Pool = new(int)
				}
				*z.Pool, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Pool")
					return
				}
			}
			zb0001Mask |= 0x1
		case "set":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Set")
					return
				}
				z.Set = nil
			} else {
				if z.Set == nil {
					z.Set = new(int)
				}
				*z.Set, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Set")
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Pool = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Set = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HealOpts) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.Pool == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Set == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "recursive"
		err = en.Append(0xa9, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Recursive)
		if err != nil {
			err = msgp.WrapError(err, "Recursive")
			return
		}
		// write "dryRun"
		err = en.Append(0xa6, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteBool(z.DryRun)
		if err != nil {
			err = msgp.WrapError(err, "DryRun")
			return
		}
		// write "remove"
		err = en.Append(0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Remove)
		if err != nil {
			err = msgp.WrapError(err, "Remove")
			return
		}
		// write "recreate"
		err = en.Append(0xa8, 0x72, 0x65, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Recreate)
		if err != nil {
			err = msgp.WrapError(err, "Recreate")
			return
		}
		// write "scanMode"
		err = en.Append(0xa8, 0x73, 0x63, 0x61, 0x6e, 0x4d, 0x6f, 0x64, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt(int(z.ScanMode))
		if err != nil {
			err = msgp.WrapError(err, "ScanMode")
			return
		}
		// write "updateParity"
		err = en.Append(0xac, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
		if err != nil {
			return
		}
		err = en.WriteBool(z.UpdateParity)
		if err != nil {
			err = msgp.WrapError(err, "UpdateParity")
			return
		}
		// write "nolock"
		err = en.Append(0xa6, 0x6e, 0x6f, 0x6c, 0x6f, 0x63, 0x6b)
		if err != nil {
			return
		}
		err = en.WriteBool(z.NoLock)
		if err != nil {
			err = msgp.WrapError(err, "NoLock")
			return
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "pool"
			err = en.Append(0xa4, 0x70, 0x6f, 0x6f, 0x6c)
			if err != nil {
				return
			}
			if z.Pool == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteInt(*z.Pool)
				if err != nil {
					err = msgp.WrapError(err, "Pool")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "set"
			err = en.Append(0xa3, 0x73, 0x65, 0x74)
			if err != nil {
				return
			}
			if z.Set == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteInt(*z.Set)
				if err != nil {
					err = msgp.WrapError(err, "Set")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HealOpts) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.Pool == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Set == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "recursive"
		o = append(o, 0xa9, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65)
		o = msgp.AppendBool(o, z.Recursive)
		// string "dryRun"
		o = append(o, 0xa6, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e)
		o = msgp.AppendBool(o, z.DryRun)
		// string "remove"
		o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
		o = msgp.AppendBool(o, z.Remove)
		// string "recreate"
		o = append(o, 0xa8, 0x72, 0x65, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65)
		o = msgp.AppendBool(o, z.Recreate)
		// string "scanMode"
		o = append(o, 0xa8, 0x73, 0x63, 0x61, 0x6e, 0x4d, 0x6f, 0x64, 0x65)
		o = msgp.AppendInt(o, int(z.ScanMode))
		// string "updateParity"
		o = append(o, 0xac, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
		o = msgp.AppendBool(o, z.UpdateParity)
		// string "nolock"
		o = append(o, 0xa6, 0x6e, 0x6f, 0x6c, 0x6f, 0x63, 0x6b)
		o = msgp.AppendBool(o, z.NoLock)
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "pool"
			o = append(o, 0xa4, 0x70, 0x6f, 0x6f, 0x6c)
			if z.Pool == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendInt(o, *z.Pool)
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "set"
			o = append(o, 0xa3, 0x73, 0x65, 0x74)
			if z.Set == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendInt(o, *z.Set)
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealOpts) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "recursive":
			z.Recursive, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Recursive")
				return
			}
		case "dryRun":
			z.DryRun, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DryRun")
				return
			}
		case "remove":
			z.Remove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
		case "recreate":
			z.Recreate, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Recreate")
				return
			}
		case "scanMode":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ScanMode")
					return
				}
				z.ScanMode = HealScanMode(zb0002)
			}
		case "updateParity":
			z.UpdateParity, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UpdateParity")
				return
			}
		case "nolock":
			z.NoLock, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NoLock")
				return
			}
		case "pool":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Pool = nil
			} else {
				if z.Pool == nil {
					z.Pool = new(int)
				}
				*z.Pool, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pool")
					return
				}
			}
			zb0001Mask |= 0x1
		case "set":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Set = nil
			} else {
				if z.Set == nil {
					z.Set = new(int)
				}
				*z.Set, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Set")
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Pool = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Set = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HealOpts) Msgsize() (s int) {
	s = 1 + 10 + msgp.BoolSize + 7 + msgp.BoolSize + 7 + msgp.BoolSize + 9 + msgp.BoolSize + 9 + msgp.IntSize + 13 + msgp.BoolSize + 7 + msgp.BoolSize + 5
	if z.Pool == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 4
	if z.Set == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealResultItem) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "resultId":
			z.ResultIndex, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ResultIndex")
				return
			}
		case "type":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = HealItemType(zb0002)
			}
		case "bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "object":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "versionId":
			z.VersionID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "detail":
			z.Detail, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Detail")
				return
			}
		case "parityBlocks":
			z.ParityBlocks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ParityBlocks")
				return
			}
			zb0001Mask |= 0x1
		case "dataBlocks":
			z.DataBlocks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DataBlocks")
				return
			}
			zb0001Mask |= 0x2
		case "diskCount":
			z.DiskCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DiskCount")
				return
			}
		case "setCount":
			z.SetCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SetCount")
				return
			}
		case "before":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Before")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Before")
					return
				}
				switch msgp.UnsafeString(field) {
				case "drives":
					var zb0004 uint32
					zb0004, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Before", "Drives")
						return
					}
					if cap(z.Before.Drives) >= int(zb0004) {
						z.Before.Drives = (z.Before.Drives)[:zb0004]
					} else {
						z.Before.Drives = make([]HealDriveInfo, zb0004)
					}
					for za0001 := range z.Before.Drives {
						var zb0005 uint32
						zb0005, err = dc.ReadMapHeader()
						if err != nil {
							err = msgp.WrapError(err, "Before", "Drives", za0001)
							return
						}
						for zb0005 > 0 {
							zb0005--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								err = msgp.WrapError(err, "Before", "Drives", za0001)
								return
							}
							switch msgp.UnsafeString(field) {
							case "uuid":
								z.Before.Drives[za0001].UUID, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "UUID")
									return
								}
							case "endpoint":
								z.Before.Drives[za0001].Endpoint, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "Endpoint")
									return
								}
							case "state":
								z.Before.Drives[za0001].State, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "State")
									return
								}
							default:
								err = dc.Skip()
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001)
									return
								}
							}
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Before")
						return
					}
				}
			}
		case "after":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "After")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "After")
					return
				}
				switch msgp.UnsafeString(field) {
				case "drives":
					var zb0007 uint32
					zb0007, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "After", "Drives")
						return
					}
					if cap(z.After.Drives) >= int(zb0007) {
						z.After.Drives = (z.After.Drives)[:zb0007]
					} else {
						z.After.Drives = make([]HealDriveInfo, zb0007)
					}
					for za0002 := range z.After.Drives {
						var zb0008 uint32
						zb0008, err = dc.ReadMapHeader()
						if err != nil {
							err = msgp.WrapError(err, "After", "Drives", za0002)
							return
						}
						for zb0008 > 0 {
							zb0008--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								err = msgp.WrapError(err, "After", "Drives", za0002)
								return
							}
							switch msgp.UnsafeString(field) {
							case "uuid":
								z.After.Drives[za0002].UUID, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "UUID")
									return
								}
							case "endpoint":
								z.After.Drives[za0002].Endpoint, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "Endpoint")
									return
								}
							case "state":
								z.After.Drives[za0002].State, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "State")
									return
								}
							default:
								err = dc.Skip()
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002)
									return
								}
							}
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "After")
						return
					}
				}
			}
		case "objectSize":
			z.ObjectSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectSize")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.ParityBlocks = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.DataBlocks = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HealResultItem) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.ParityBlocks == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.DataBlocks == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "resultId"
		err = en.Append(0xa8, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x49, 0x64)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.ResultIndex)
		if err != nil {
			err = msgp.WrapError(err, "ResultIndex")
			return
		}
		// write "type"
		err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(string(z.Type))
		if err != nil {
			err = msgp.WrapError(err, "Type")
			return
		}
		// write "bucket"
		err = en.Append(0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Bucket)
		if err != nil {
			err = msgp.WrapError(err, "Bucket")
			return
		}
		// write "object"
		err = en.Append(0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Object)
		if err != nil {
			err = msgp.WrapError(err, "Object")
			return
		}
		// write "versionId"
		err = en.Append(0xa9, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.VersionID)
		if err != nil {
			err = msgp.WrapError(err, "VersionID")
			return
		}
		// write "detail"
		err = en.Append(0xa6, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteString(z.Detail)
		if err != nil {
			err = msgp.WrapError(err, "Detail")
			return
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "parityBlocks"
			err = en.Append(0xac, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.ParityBlocks)
			if err != nil {
				err = msgp.WrapError(err, "ParityBlocks")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "dataBlocks"
			err = en.Append(0xaa, 0x64, 0x61, 0x74, 0x61, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.DataBlocks)
			if err != nil {
				err = msgp.WrapError(err, "DataBlocks")
				return
			}
		}
		// write "diskCount"
		err = en.Append(0xa9, 0x64, 0x69, 0x73, 0x6b, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.DiskCount)
		if err != nil {
			err = msgp.WrapError(err, "DiskCount")
			return
		}
		// write "setCount"
		err = en.Append(0xa8, 0x73, 0x65, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.SetCount)
		if err != nil {
			err = msgp.WrapError(err, "SetCount")
			return
		}
		// write "before"
		err = en.Append(0xa6, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
		if err != nil {
			return
		}
		// map header, size 1
		// write "drives"
		err = en.Append(0x81, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Before.Drives)))
		if err != nil {
			err = msgp.WrapError(err, "Before", "Drives")
			return
		}
		for za0001 := range z.Before.Drives {
			// map header, size 3
			// write "uuid"
			err = en.Append(0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
			if err != nil {
				return
			}
			err = en.WriteString(z.Before.Drives[za0001].UUID)
			if err != nil {
				err = msgp.WrapError(err, "Before", "Drives", za0001, "UUID")
				return
			}
			// write "endpoint"
			err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteString(z.Before.Drives[za0001].Endpoint)
			if err != nil {
				err = msgp.WrapError(err, "Before", "Drives", za0001, "Endpoint")
				return
			}
			// write "state"
			err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
			if err != nil {
				return
			}
			err = en.WriteString(z.Before.Drives[za0001].State)
			if err != nil {
				err = msgp.WrapError(err, "Before", "Drives", za0001, "State")
				return
			}
		}
		// write "after"
		err = en.Append(0xa5, 0x61, 0x66, 0x74, 0x65, 0x72)
		if err != nil {
			return
		}
		// map header, size 1
		// write "drives"
		err = en.Append(0x81, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.After.Drives)))
		if err != nil {
			err = msgp.WrapError(err, "After", "Drives")
			return
		}
		for za0002 := range z.After.Drives {
			// map header, size 3
			// write "uuid"
			err = en.Append(0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
			if err != nil {
				return
			}
			err = en.WriteString(z.After.Drives[za0002].UUID)
			if err != nil {
				err = msgp.WrapError(err, "After", "Drives", za0002, "UUID")
				return
			}
			// write "endpoint"
			err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteString(z.After.Drives[za0002].Endpoint)
			if err != nil {
				err = msgp.WrapError(err, "After", "Drives", za0002, "Endpoint")
				return
			}
			// write "state"
			err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
			if err != nil {
				return
			}
			err = en.WriteString(z.After.Drives[za0002].State)
			if err != nil {
				err = msgp.WrapError(err, "After", "Drives", za0002, "State")
				return
			}
		}
		// write "objectSize"
		err = en.Append(0xaa, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.ObjectSize)
		if err != nil {
			err = msgp.WrapError(err, "ObjectSize")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HealResultItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.ParityBlocks == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.DataBlocks == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "resultId"
		o = append(o, 0xa8, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x49, 0x64)
		o = msgp.AppendInt64(o, z.ResultIndex)
		// string "type"
		o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, string(z.Type))
		// string "bucket"
		o = append(o, 0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
		o = msgp.AppendString(o, z.Bucket)
		// string "object"
		o = append(o, 0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
		o = msgp.AppendString(o, z.Object)
		// string "versionId"
		o = append(o, 0xa9, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64)
		o = msgp.AppendString(o, z.VersionID)
		// string "detail"
		o = append(o, 0xa6, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c)
		o = msgp.AppendString(o, z.Detail)
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "parityBlocks"
			o = append(o, 0xac, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73)
			o = msgp.AppendInt(o, z.ParityBlocks)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "dataBlocks"
			o = append(o, 0xaa, 0x64, 0x61, 0x74, 0x61, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73)
			o = msgp.AppendInt(o, z.DataBlocks)
		}
		// string "diskCount"
		o = append(o, 0xa9, 0x64, 0x69, 0x73, 0x6b, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt(o, z.DiskCount)
		// string "setCount"
		o = append(o, 0xa8, 0x73, 0x65, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt(o, z.SetCount)
		// string "before"
		o = append(o, 0xa6, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
		// map header, size 1
		// string "drives"
		o = append(o, 0x81, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Before.Drives)))
		for za0001 := range z.Before.Drives {
			// map header, size 3
			// string "uuid"
			o = append(o, 0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
			o = msgp.AppendString(o, z.Before.Drives[za0001].UUID)
			// string "endpoint"
			o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
			o = msgp.AppendString(o, z.Before.Drives[za0001].Endpoint)
			// string "state"
			o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
			o = msgp.AppendString(o, z.Before.Drives[za0001].State)
		}
		// string "after"
		o = append(o, 0xa5, 0x61, 0x66, 0x74, 0x65, 0x72)
		// map header, size 1
		// string "drives"
		o = append(o, 0x81, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.After.Drives)))
		for za0002 := range z.After.Drives {
			// map header, size 3
			// string "uuid"
			o = append(o, 0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
			o = msgp.AppendString(o, z.After.Drives[za0002].UUID)
			// string "endpoint"
			o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
			o = msgp.AppendString(o, z.After.Drives[za0002].Endpoint)
			// string "state"
			o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
			o = msgp.AppendString(o, z.After.Drives[za0002].State)
		}
		// string "objectSize"
		o = append(o, 0xaa, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt64(o, z.ObjectSize)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealResultItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "resultId":
			z.ResultIndex, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResultIndex")
				return
			}
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = HealItemType(zb0002)
			}
		case "bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "object":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "versionId":
			z.VersionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "detail":
			z.Detail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Detail")
				return
			}
		case "parityBlocks":
			z.ParityBlocks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ParityBlocks")
				return
			}
			zb0001Mask |= 0x1
		case "dataBlocks":
			z.DataBlocks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DataBlocks")
				return
			}
			zb0001Mask |= 0x2
		case "diskCount":
			z.DiskCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiskCount")
				return
			}
		case "setCount":
			z.SetCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SetCount")
				return
			}
		case "before":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Before")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Before")
					return
				}
				switch msgp.UnsafeString(field) {
				case "drives":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Before", "Drives")
						return
					}
					if cap(z.Before.Drives) >= int(zb0004) {
						z.Before.Drives = (z.Before.Drives)[:zb0004]
					} else {
						z.Before.Drives = make([]HealDriveInfo, zb0004)
					}
					for za0001 := range z.Before.Drives {
						var zb0005 uint32
						zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Before", "Drives", za0001)
							return
						}
						for zb0005 > 0 {
							zb0005--
							field, bts, err = msgp.ReadMapKeyZC(bts)
							if err != nil {
								err = msgp.WrapError(err, "Before", "Drives", za0001)
								return
							}
							switch msgp.UnsafeString(field) {
							case "uuid":
								z.Before.Drives[za0001].UUID, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "UUID")
									return
								}
							case "endpoint":
								z.Before.Drives[za0001].Endpoint, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "Endpoint")
									return
								}
							case "state":
								z.Before.Drives[za0001].State, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "State")
									return
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001)
									return
								}
							}
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Before")
						return
					}
				}
			}
		case "after":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "After")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "After")
					return
				}
				switch msgp.UnsafeString(field) {
				case "drives":
					var zb0007 uint32
					zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "After", "Drives")
						return
					}
					if cap(z.After.Drives) >= int(zb0007) {
						z.After.Drives = (z.After.Drives)[:zb0007]
					} else {
						z.After.Drives = make([]HealDriveInfo, zb0007)
					}
					for za0002 := range z.After.Drives {
						var zb0008 uint32
						zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "After", "Drives", za0002)
							return
						}
						for zb0008 > 0 {
							zb0008--
							field, bts, err = msgp.ReadMapKeyZC(bts)
							if err != nil {
								err = msgp.WrapError(err, "After", "Drives", za0002)
								return
							}
							switch msgp.UnsafeString(field) {
							case "uuid":
								z.After.Drives[za0002].UUID, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "UUID")
									return
								}
							case "endpoint":
								z.After.Drives[za0002].Endpoint, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "Endpoint")
									return
								}
							case "state":
								z.After.Drives[za0002].State, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "State")
									return
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002)
									return
								}
							}
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "After")
						return
					}
				}
			}
		case "objectSize":
			z.ObjectSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectSize")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.ParityBlocks = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.DataBlocks = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HealResultItem) Msgsize() (s int) {
	s = 1 + 9 + msgp.Int64Size + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 7 + msgp.StringPrefixSize + len(z.Bucket) + 7 + msgp.StringPrefixSize + len(z.Object) + 10 + msgp.StringPrefixSize + len(z.VersionID) + 7 + msgp.StringPrefixSize + len(z.Detail) + 13 + msgp.IntSize + 11 + msgp.IntSize + 10 + msgp.IntSize + 9 + msgp.IntSize + 7 + 1 + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Before.Drives {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Before.Drives[za0001].UUID) + 9 + msgp.StringPrefixSize + len(z.Before.Drives[za0001].Endpoint) + 6 + msgp.StringPrefixSize + len(z.Before.Drives[za0001].State)
	}
	s += 6 + 1 + 7 + msgp.ArrayHeaderSize
	for za0002 := range z.After.Drives {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.After.Drives[za0002].UUID) + 9 + msgp.StringPrefixSize + len(z.After.Drives[za0002].Endpoint) + 6 + msgp.StringPrefixSize + len(z.After.Drives[za0002].State)
	}
	s += 11 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealScanMode) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealScanMode(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealScanMode) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealScanMode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealScanMode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealScanMode(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealScanMode) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealStartSuccess) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "clientToken":
			z.ClientToken, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientToken")
				return
			}
		case "clientAddress":
			z.ClientAddress, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientAddress")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealStartSuccess) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "clientToken"
	err = en.Append(0x83, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientToken)
	if err != nil {
		err = msgp.WrapError(err, "ClientToken")
		return
	}
	// write "clientAddress"
	err = en.Append(0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientAddress)
	if err != nil {
		err = msgp.WrapError(err, "ClientAddress")
		return
	}
	// write "startTime"
	err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealStartSuccess) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "clientToken"
	o = append(o, 0x83, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.ClientToken)
	// string "clientAddress"
	o = append(o, 0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	o = msgp.AppendString(o, z.ClientAddress)
	// string "startTime"
	o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.StartTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealStartSuccess) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "clientToken":
			z.ClientToken, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientToken")
				return
			}
		case "clientAddress":
			z.ClientAddress, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientAddress")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealStartSuccess) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ClientToken) + 14 + msgp.StringPrefixSize + len(z.ClientAddress) + 10 + msgp.TimeSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealStopSuccess) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "clientToken":
			z.ClientToken, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientToken")
				return
			}
		case "clientAddress":
			z.ClientAddress, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientAddress")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealStopSuccess) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "clientToken"
	err = en.Append(0x83, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientToken)
	if err != nil {
		err = msgp.WrapError(err, "ClientToken")
		return
	}
	// write "clientAddress"
	err = en.Append(0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientAddress)
	if err != nil {
		err = msgp.WrapError(err, "ClientAddress")
		return
	}
	// write "startTime"
	err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealStopSuccess) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "clientToken"
	o = append(o, 0x83, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.ClientToken)
	// string "clientAddress"
	o = append(o, 0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	o = msgp.AppendString(o, z.ClientAddress)
	// string "startTime"
	o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.StartTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealStopSuccess) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "clientToken":
			z.ClientToken, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientToken")
				return
			}
		case "clientAddress":
			z.ClientAddress, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientAddress")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealStopSuccess) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ClientToken) + 14 + msgp.StringPrefixSize + len(z.ClientAddress) + 10 + msgp.TimeSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealTaskStatus) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "summary":
			z.Summary, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Summary")
				return
			}
		case "detail":
			z.FailureDetail, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FailureDetail")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "settings":
			err = z.HealSettings.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "HealSettings")
				return
			}
		case "items":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Items")
				return
			}
			if cap(z.Items) >= int(zb0002) {
				z.Items = (z.Items)[:zb0002]
			} else {
				z.Items = make([]HealResultItem, zb0002)
			}
			for za0001 := range z.Items {
				err = z.Items[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Items", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.Items = nil
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *HealTaskStatus) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Items == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "summary"
		err = en.Append(0xa7, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79)
		if err != nil {
			return
		}
		err = en.WriteString(z.Summary)
		if err != nil {
			err = msgp.WrapError(err, "Summary")
			return
		}
		// write "detail"
		err = en.Append(0xa6, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteString(z.FailureDetail)
		if err != nil {
			err = msgp.WrapError(err, "FailureDetail")
			return
		}
		// write "startTime"
		err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.StartTime)
		if err != nil {
			err = msgp.WrapError(err, "StartTime")
			return
		}
		// write "settings"
		err = en.Append(0xa8, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
		if err != nil {
			return
		}
		err = z.HealSettings.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "HealSettings")
			return
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "items"
			err = en.Append(0xa5, 0x69, 0x74, 0x65, 0x6d, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Items)))
			if err != nil {
				err = msgp.WrapError(err, "Items")
				return
			}
			for za0001 := range z.Items {
				err = z.Items[za0001].EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Items", za0001)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HealTaskStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Items == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "summary"
		o = append(o, 0xa7, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79)
		o = msgp.AppendString(o, z.Summary)
		// string "detail"
		o = append(o, 0xa6, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c)
		o = msgp.AppendString(o, z.FailureDetail)
		// string "startTime"
		o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.StartTime)
		// string "settings"
		o = append(o, 0xa8, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
		o, err = z.HealSettings.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "HealSettings")
			return
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "items"
			o = append(o, 0xa5, 0x69, 0x74, 0x65, 0x6d, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Items)))
			for za0001 := range z.Items {
				o, err = z.Items[za0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Items", za0001)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealTaskStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "summary":
			z.Summary, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Summary")
				return
			}
		case "detail":
			z.FailureDetail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailureDetail")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "settings":
			bts, err = z.HealSettings.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealSettings")
				return
			}
		case "items":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Items")
				return
			}
			if cap(z.Items) >= int(zb0002) {
				z.Items = (z.Items)[:zb0002]
			} else {
				z.Items = make([]HealResultItem, zb0002)
			}
			for za0001 := range z.Items {
				bts, err = z.Items[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Items", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.Items = nil
	}

	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HealTaskStatus) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Summary) + 7 + msgp.StringPrefixSize + len(z.FailureDetail) + 10 + msgp.TimeSize + 9 + z.HealSettings.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Items {
		s += z.Items[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealingDisk) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "heal_id":
			z.HealID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HealID")
				return
			}
		case "pool_index":
			z.PoolIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "disk_index":
			z.DiskIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DiskIndex")
				return
			}
		case "endpoint":
			z.Endpoint, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "path":
			z.Path, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "started":
			z.Started, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "Started")
				return
			}
		case "last_update":
			z.LastUpdate, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retry_attempts":
			z.RetryAttempts, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "objects_total_count":
			z.ObjectsTotalCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalCount")
				return
			}
		case "objects_total_size":
			z.ObjectsTotalSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalSize")
				return
			}
		case "items_healed":
			z.ItemsHealed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		case "items_failed":
			z.ItemsFailed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsFailed")
				return
			}
		case "items_skipped":
			z.ItemsSkipped, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsSkipped")
				return
			}
		case "bytes_done":
			z.BytesDone, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BytesDone")
				return
			}
		case "bytes_failed":
			z.BytesFailed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		case "bytes_skipped":
			z.BytesSkipped, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BytesSkipped")
				return
			}
		case "current_bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "current_object":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "queued_buckets":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "QueuedBuckets")
				return
			}
			if cap(z.QueuedBuckets) >= int(zb0002) {
				z.QueuedBuckets = (z.QueuedBuckets)[:zb0002]
			} else {
				z.QueuedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.QueuedBuckets {
				z.QueuedBuckets[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "QueuedBuckets", za0001)
					return
				}
			}
		case "healed_buckets":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HealedBuckets")
				return
			}
			if cap(z.HealedBuckets) >= int(zb0003) {
				z.HealedBuckets = (z.HealedBuckets)[:zb0003]
			} else {
				z.HealedBuckets = make([]string, zb0003)
			}
			for za0002 := range z.HealedBuckets {
				z.HealedBuckets[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HealedBuckets", za0002)
					return
				}
			}
		case "finished":
			z.Finished, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Finished")
				return
			}
		case "reason":
			{
				var zb0004 int8
				zb0004, err = dc.ReadInt8()
				if err != nil {
					err = msgp.WrapError(err, "Reason")
					return
				}
				z.Reason = HealingDriveReason(zb0004)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HealingDisk) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 24
	// write "id"
	err = en.Append(0xde, 0x0, 0x18, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "heal_id"
	err = en.Append(0xa7, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.HealID)
	if err != nil {
		err = msgp.WrapError(err, "HealID")
		return
	}
	// write "pool_index"
	err = en.Append(0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PoolIndex)
	if err != nil {
		err = msgp.WrapError(err, "PoolIndex")
		return
	}
	// write "set_index"
	err = en.Append(0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SetIndex)
	if err != nil {
		err = msgp.WrapError(err, "SetIndex")
		return
	}
	// write "disk_index"
	err = en.Append(0xaa, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DiskIndex)
	if err != nil {
		err = msgp.WrapError(err, "DiskIndex")
		return
	}
	// write "endpoint"
	err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Endpoint)
	if err != nil {
		err = msgp.WrapError(err, "Endpoint")
		return
	}
	// write "path"
	err = en.Append(0xa4, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Path)
	if err != nil {
		err = msgp.WrapError(err, "Path")
		return
	}
	// write "started"
	err = en.Append(0xa7, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Started)
	if err != nil {
		err = msgp.WrapError(err, "Started")
		return
	}
	// write "last_update"
	err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastUpdate)
	if err != nil {
		err = msgp.WrapError(err, "LastUpdate")
		return
	}
	// write "retry_attempts"
	err = en.Append(0xae, 0x72, 0x65, 0x74, 0x72, 0x79, 0x5f, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.RetryAttempts)
	if err != nil {
		err = msgp.WrapError(err, "RetryAttempts")
		return
	}
	// write "objects_total_count"
	err = en.Append(0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsTotalCount)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsTotalCount")
		return
	}
	// write "objects_total_size"
	err = en.Append(0xb2, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsTotalSize)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsTotalSize")
		return
	}
	// write "items_healed"
	err = en.Append(0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsHealed)
	if err != nil {
		err = msgp.WrapError(err, "ItemsHealed")
		return
	}
	// write "items_failed"
	err = en.Append(0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ItemsFailed")
		return
	}
	// write "items_skipped"
	err = en.Append(0xad, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsSkipped)
	if err != nil {
		err = msgp.WrapError(err, "ItemsSkipped")
		return
	}
	// write "bytes_done"
	err = en.Append(0xaa, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x64, 0x6f, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesDone)
	if err != nil {
		err = msgp.WrapError(err, "BytesDone")
		return
	}
	// write "bytes_failed"
	err = en.Append(0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesFailed)
	if err != nil {
		err = msgp.WrapError(err, "BytesFailed")
		return
	}
	// write "bytes_skipped"
	err = en.Append(0xad, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesSkipped)
	if err != nil {
		err = msgp.WrapError(err, "BytesSkipped")
		return
	}
	// write "current_bucket"
	err = en.Append(0xae, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "current_object"
	err = en.Append(0xae, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "queued_buckets"
	err = en.Append(0xae, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.QueuedBuckets)))
	if err != nil {
		err = msgp.WrapError(err, "QueuedBuckets")
		return
	}
	for za0001 := range z.QueuedBuckets {
		err = en.WriteString(z.QueuedBuckets[za0001])
		if err != nil {
			err = msgp.WrapError(err, "QueuedBuckets", za0001)
			return
		}
	}
	// write "healed_buckets"
	err = en.Append(0xae, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.HealedBuckets)))
	if err != nil {
		err = msgp.WrapError(err, "HealedBuckets")
		return
	}
	for za0002 := range z.HealedBuckets {
		err = en.WriteString(z.HealedBuckets[za0002])
		if err != nil {
			err = msgp.WrapError(err, "HealedBuckets", za0002)
			return
		}
	}
	// write "finished"
	err = en.Append(0xa8, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Finished)
	if err != nil {
		err = msgp.WrapError(err, "Finished")
		return
	}
	// write "reason"
	err = en.Append(0xa6, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt8(int8(z.Reason))
	if err != nil {
		err = msgp.WrapError(err, "Reason")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HealingDisk) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 24
	// string "id"
	o = append(o, 0xde, 0x0, 0x18, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "heal_id"
	o = append(o, 0xa7, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.HealID)
	// string "pool_index"
	o = append(o, 0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.PoolIndex)
	// string "set_index"
	o = append(o, 0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.SetIndex)
	// string "disk_index"
	o = append(o, 0xaa, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.DiskIndex)
	// string "endpoint"
	o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Endpoint)
	// string "path"
	o = append(o, 0xa4, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "started"
	o = append(o, 0xa7, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.Started)
	// string "last_update"
	o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65)
	o = msgp.AppendTime(o, z.LastUpdate)
	// string "retry_attempts"
	o = append(o, 0xae, 0x72, 0x65, 0x74, 0x72, 0x79, 0x5f, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
	o = msgp.AppendUint64(o, z.RetryAttempts)
	// string "objects_total_count"
	o = append(o, 0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ObjectsTotalCount)
	// string "objects_total_size"
	o = append(o, 0xb2, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ObjectsTotalSize)
	// string "items_healed"
	o = append(o, 0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsHealed)
	// string "items_failed"
	o = append(o, 0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsFailed)
	// string "items_skipped"
	o = append(o, 0xad, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsSkipped)
	// string "bytes_done"
	o = append(o, 0xaa, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x64, 0x6f, 0x6e, 0x65)
	o = msgp.AppendUint64(o, z.BytesDone)
	// string "bytes_failed"
	o = append(o, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.BytesFailed)
	// string "bytes_skipped"
	o = append(o, 0xad, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.BytesSkipped)
	// string "current_bucket"
	o = append(o, 0xae, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "current_object"
	o = append(o, 0xae, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "queued_buckets"
	o = append(o, 0xae, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.QueuedBuckets)))
	for za0001 := range z.QueuedBuckets {
		o = msgp.AppendString(o, z.QueuedBuckets[za0001])
	}
	// string "healed_buckets"
	o = append(o, 0xae, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.HealedBuckets)))
	for za0002 := range z.HealedBuckets {
		o = msgp.AppendString(o, z.HealedBuckets[za0002])
	}
	// string "finished"
	o = append(o, 0xa8, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Finished)
	// string "reason"
	o = append(o, 0xa6, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendInt8(o, int8(z.Reason))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealingDisk) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "heal_id":
			z.HealID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealID")
				return
			}
		case "pool_index":
			z.PoolIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "disk_index":
			z.DiskIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiskIndex")
				return
			}
		case "endpoint":
			z.Endpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "started":
			z.Started, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Started")
				return
			}
		case "last_update":
			z.LastUpdate, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retry_attempts":
			z.RetryAttempts, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "objects_total_count":
			z.ObjectsTotalCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalCount")
				return
			}
		case "objects_total_size":
			z.ObjectsTotalSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalSize")
				return
			}
		case "items_healed":
			z.ItemsHealed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		case "items_failed":
			z.ItemsFailed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsFailed")
				return
			}
		case "items_skipped":
			z.ItemsSkipped, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsSkipped")
				return
			}
		case "bytes_done":
			z.BytesDone, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesDone")
				return
			}
		case "bytes_failed":
			z.BytesFailed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		case "bytes_skipped":
			z.BytesSkipped, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesSkipped")
				return
			}
		case "current_bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "current_object":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "queued_buckets":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QueuedBuckets")
				return
			}
			if cap(z.QueuedBuckets) >= int(zb0002) {
				z.QueuedBuckets = (z.QueuedBuckets)[:zb0002]
			} else {
				z.QueuedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.QueuedBuckets {
				z.QueuedBuckets[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "QueuedBuckets", za0001)
					return
				}
			}
		case "healed_buckets":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealedBuckets")
				return
			}
			if cap(z.HealedBuckets) >= int(zb0003) {
				z.HealedBuckets = (z.HealedBuckets)[:zb0003]
			} else {
				z.HealedBuckets = make([]string, zb0003)
			}
			for za0002 := range z.HealedBuckets {
				z.HealedBuckets[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HealedBuckets", za0002)
					return
				}
			}
		case "finished":
			z.Finished, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Finished")
				return
			}
		case "reason":
			{
				var zb0004 int8
				zb0004, bts, err = msgp.ReadInt8Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reason")
					return
				}
				z.Reason = HealingDriveReason(zb0004)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HealingDisk) Msgsize() (s int) {
	s = 3 + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.HealID) + 11 + msgp.IntSize + 10 + msgp.IntSize + 11 + msgp.IntSize + 9 + msgp.StringPrefixSize + len(z.Endpoint) + 5 + msgp.StringPrefixSize + len(z.Path) + 8 + msgp.TimeSize + 12 + msgp.TimeSize + 15 + msgp.Uint64Size + 20 + msgp.Uint64Size + 19 + msgp.Uint64Size + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size + 14 + msgp.Uint64Size + 11 + msgp.Uint64Size + 13 + msgp.Uint64Size + 14 + msgp.Uint64Size + 15 + msgp.StringPrefixSize + len(z.Bucket) + 15 + msgp.StringPrefixSize + len(z.Object) + 15 + msgp.ArrayHeaderSize
	for za0001 := range z.QueuedBuckets {
		s += msgp.StringPrefixSize + len(z.QueuedBuckets[za0001])
	}
	s += 15 + msgp.ArrayHeaderSize
	for za0002 := range z.HealedBuckets {
		s += msgp.StringPrefixSize + len(z.HealedBuckets[za0002])
	}
	s += 9 + msgp.BoolSize + 7 + msgp.Int8Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealingDriveReason) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int8
		zb0001, err = dc.ReadInt8()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealingDriveReason(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealingDriveReason) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt8(int8(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealingDriveReason) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt8(o, int8(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealingDriveReason) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int8
		zb0001, bts, err = msgp.ReadInt8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealingDriveReason(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealingDriveReason) Msgsize() (s int) {
	s = msgp.Int8Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MRFStatus) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bytes_healed":
			z.BytesHealed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BytesHealed")
				return
			}
		case "items_healed":
			z.ItemsHealed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MRFStatus) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "bytes_healed"
	err = en.Append(0x82, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesHealed)
	if err != nil {
		err = msgp.WrapError(err, "BytesHealed")
		return
	}
	// write "items_healed"
	err = en.Append(0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsHealed)
	if err != nil {
		err = msgp.WrapError(err, "ItemsHealed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MRFStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "bytes_healed"
	o = append(o, 0x82, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.BytesHealed)
	// string "items_healed"
	o = append(o, 0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsHealed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MRFStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bytes_healed":
			z.BytesHealed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesHealed")
				return
			}
		case "items_healed":
			z.ItemsHealed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MRFStatus) Msgsize() (s int) {
	s = 1 + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OfflineDecision) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int8
		zb0001, err = dc.ReadInt8()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = OfflineDecision(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z OfflineDecision) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt8(int8(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z OfflineDecision) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt8(o, int8(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OfflineDecision) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int8
		zb0001, bts, err = msgp.ReadInt8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = OfflineDecision(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OfflineDecision) Msgsize() (s int) {
	s = msgp.Int8Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OfflineEvent) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "from_time":
			z.FromTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "FromTime")
				return
			}
		case "to_time":
			z.ToTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "ToTime")
				return
			}
		case "reason":
			{
				var zb0002 int8
				zb0002, err = dc.ReadInt8()
				if err != nil {
					err = msgp.WrapError(err, "Reason")
					return
				}
				z.Reason = OfflineReason(zb0002)
			}
		case "decision":
			{
				var zb0003 int8
				zb0003, err = dc.ReadInt8()
				if err != nil {
					err = msgp.WrapError(err, "Decision")
					return
				}
				z.Decision = OfflineDecision(zb0003)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OfflineEvent) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "from_time"
	err = en.Append(0x84, 0xa9, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.FromTime)
	if err != nil {
		err = msgp.WrapError(err, "FromTime")
		return
	}
	// write "to_time"
	err = en.Append(0xa7, 0x74, 0x6f, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ToTime)
	if err != nil {
		err = msgp.WrapError(err, "ToTime")
		return
	}
	// write "reason"
	err = en.Append(0xa6, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt8(int8(z.Reason))
	if err != nil {
		err = msgp.WrapError(err, "Reason")
		return
	}
	// write "decision"
	err = en.Append(0xa8, 0x64, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt8(int8(z.Decision))
	if err != nil {
		err = msgp.WrapError(err, "Decision")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OfflineEvent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "from_time"
	o = append(o, 0x84, 0xa9, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.FromTime)
	// string "to_time"
	o = append(o, 0xa7, 0x74, 0x6f, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.ToTime)
	// string "reason"
	o = append(o, 0xa6, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e)
	o = msgp.AppendInt8(o, int8(z.Reason))
	// string "decision"
	o = append(o, 0xa8, 0x64, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt8(o, int8(z.Decision))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OfflineEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "from_time":
			z.FromTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FromTime")
				return
			}
		case "to_time":
			z.ToTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ToTime")
				return
			}
		case "reason":
			{
				var zb0002 int8
				zb0002, bts, err = msgp.ReadInt8Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Reason")
					return
				}
				z.Reason = OfflineReason(zb0002)
			}
		case "decision":
			{
				var zb0003 int8
				zb0003, bts, err = msgp.ReadInt8Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Decision")
					return
				}
				z.Decision = OfflineDecision(zb0003)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OfflineEvent) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 8 + msgp.TimeSize + 7 + msgp.Int8Size + 9 + msgp.Int8Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OfflineInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "events":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Events")
				return
			}
			if cap(z.Events) >= int(zb0002) {
				z.Events = (z.Events)[:zb0002]
			} else {
				z.Events = make([]OfflineEvent, zb0002)
			}
			for za0001 := range z.Events {
				err = z.Events[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Events", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OfflineInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "events"
	err = en.Append(0x81, 0xa6, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Events)))
	if err != nil {
		err = msgp.WrapError(err, "Events")
		return
	}
	for za0001 := range z.Events {
		err = z.Events[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Events", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OfflineInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "events"
	o = append(o, 0x81, 0xa6, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Events)))
	for za0001 := range z.Events {
		o, err = z.Events[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Events", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OfflineInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "events":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Events")
				return
			}
			if cap(z.Events) >= int(zb0002) {
				z.Events = (z.Events)[:zb0002]
			} else {
				z.Events = make([]OfflineEvent, zb0002)
			}
			for za0001 := range z.Events {
				bts, err = z.Events[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Events", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OfflineInfo) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Events {
		s += z.Events[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OfflineReason) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int8
		zb0001, err = dc.ReadInt8()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = OfflineReason(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z OfflineReason) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt8(int8(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z OfflineReason) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt8(o, int8(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OfflineReason) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int8
		zb0001, bts, err = msgp.ReadInt8Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = OfflineReason(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z OfflineReason) Msgsize() (s int) {
	s = msgp.Int8Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SetStatus) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "pool_index":
			z.PoolIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "heal_status":
			z.HealStatus, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HealStatus")
				return
			}
		case "heal_priority":
			z.HealPriority, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HealPriority")
				return
			}
		case "total_objects":
			z.TotalObjects, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TotalObjects")
				return
			}
		case "disks":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0002) {
				z.Disks = (z.Disks)[:zb0002]
			} else {
				z.Disks = make([]Disk, zb0002)
			}
			for za0001 := range z.Disks {
				err = z.Disks[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SetStatus) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "id"
	err = en.Append(0x87, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "pool_index"
	err = en.Append(0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PoolIndex)
	if err != nil {
		err = msgp.WrapError(err, "PoolIndex")
		return
	}
	// write "set_index"
	err = en.Append(0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SetIndex)
	if err != nil {
		err = msgp.WrapError(err, "SetIndex")
		return
	}
	// write "heal_status"
	err = en.Append(0xab, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.HealStatus)
	if err != nil {
		err = msgp.WrapError(err, "HealStatus")
		return
	}
	// write "heal_priority"
	err = en.Append(0xad, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.HealPriority)
	if err != nil {
		err = msgp.WrapError(err, "HealPriority")
		return
	}
	// write "total_objects"
	err = en.Append(0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TotalObjects)
	if err != nil {
		err = msgp.WrapError(err, "TotalObjects")
		return
	}
	// write "disks"
	err = en.Append(0xa5, 0x64, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Disks)))
	if err != nil {
		err = msgp.WrapError(err, "Disks")
		return
	}
	for za0001 := range z.Disks {
		err = z.Disks[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SetStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "id"
	o = append(o, 0x87, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "pool_index"
	o = append(o, 0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.PoolIndex)
	// string "set_index"
	o = append(o, 0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.SetIndex)
	// string "heal_status"
	o = append(o, 0xab, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendString(o, z.HealStatus)
	// string "heal_priority"
	o = append(o, 0xad, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendString(o, z.HealPriority)
	// string "total_objects"
	o = append(o, 0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt(o, z.TotalObjects)
	// string "disks"
	o = append(o, 0xa5, 0x64, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Disks)))
	for za0001 := range z.Disks {
		o, err = z.Disks[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SetStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "pool_index":
			z.PoolIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "heal_status":
			z.HealStatus, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealStatus")
				return
			}
		case "heal_priority":
			z.HealPriority, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealPriority")
				return
			}
		case "total_objects":
			z.TotalObjects, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalObjects")
				return
			}
		case "disks":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0002) {
				z.Disks = (z.Disks)[:zb0002]
			} else {
				z.Disks = make([]Disk, zb0002)
			}
			for za0001 := range z.Disks {
				bts, err = z.Disks[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SetStatus) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 11 + msgp.IntSize + 10 + msgp.IntSize + 12 + msgp.StringPrefixSize + len(z.HealStatus) + 14 + msgp.StringPrefixSize + len(z.HealPriority) + 14 + msgp.IntSize + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Disks {
		s += z.Disks[za0001].Msgsize()
	}
	return
}
