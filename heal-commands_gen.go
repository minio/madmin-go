package madmin

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *BgHealState) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "offline_nodes":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OfflineEndpoints")
				return
			}
			if cap(z.OfflineEndpoints) >= int(zb0002) {
				z.OfflineEndpoints = (z.OfflineEndpoints)[:zb0002]
			} else {
				z.OfflineEndpoints = make([]string, zb0002)
			}
			for za0001 := range z.OfflineEndpoints {
				z.OfflineEndpoints[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "OfflineEndpoints", za0001)
					return
				}
			}
		case "ScannedItemsCount":
			z.ScannedItemsCount, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ScannedItemsCount")
				return
			}
		case "HealDisks":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HealDisks")
				return
			}
			if cap(z.HealDisks) >= int(zb0003) {
				z.HealDisks = (z.HealDisks)[:zb0003]
			} else {
				z.HealDisks = make([]string, zb0003)
			}
			for za0002 := range z.HealDisks {
				z.HealDisks[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HealDisks", za0002)
					return
				}
			}
		case "sets":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Sets")
				return
			}
			if cap(z.Sets) >= int(zb0004) {
				z.Sets = (z.Sets)[:zb0004]
			} else {
				z.Sets = make([]SetStatus, zb0004)
			}
			for za0003 := range z.Sets {
				err = z.Sets[za0003].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Sets", za0003)
					return
				}
			}
		case "mrf":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "MRF")
				return
			}
			if z.MRF == nil {
				z.MRF = make(map[string]MRFStatus, zb0005)
			} else if len(z.MRF) > 0 {
				for key := range z.MRF {
					delete(z.MRF, key)
				}
			}
			for zb0005 > 0 {
				zb0005--
				var za0004 string
				var za0005 MRFStatus
				za0004, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "MRF")
					return
				}
				var zb0006 uint32
				zb0006, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "MRF", za0004)
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "MRF", za0004)
						return
					}
					switch msgp.UnsafeString(field) {
					case "bytes_healed":
						za0005.BytesHealed, err = dc.ReadUint64()
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004, "BytesHealed")
							return
						}
					case "items_healed":
						za0005.ItemsHealed, err = dc.ReadUint64()
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004, "ItemsHealed")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004)
							return
						}
					}
				}
				z.MRF[za0004] = za0005
			}
		case "sc_parity":
			var zb0007 uint32
			zb0007, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "SCParity")
				return
			}
			if z.SCParity == nil {
				z.SCParity = make(map[string]int, zb0007)
			} else if len(z.SCParity) > 0 {
				for key := range z.SCParity {
					delete(z.SCParity, key)
				}
			}
			for zb0007 > 0 {
				zb0007--
				var za0006 string
				var za0007 int
				za0006, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "SCParity")
					return
				}
				za0007, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SCParity", za0006)
					return
				}
				z.SCParity[za0006] = za0007
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BgHealState) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "offline_nodes"
	err = en.Append(0x86, 0xad, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.OfflineEndpoints)))
	if err != nil {
		err = msgp.WrapError(err, "OfflineEndpoints")
		return
	}
	for za0001 := range z.OfflineEndpoints {
		err = en.WriteString(z.OfflineEndpoints[za0001])
		if err != nil {
			err = msgp.WrapError(err, "OfflineEndpoints", za0001)
			return
		}
	}
	// write "ScannedItemsCount"
	err = en.Append(0xb1, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ScannedItemsCount)
	if err != nil {
		err = msgp.WrapError(err, "ScannedItemsCount")
		return
	}
	// write "HealDisks"
	err = en.Append(0xa9, 0x48, 0x65, 0x61, 0x6c, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.HealDisks)))
	if err != nil {
		err = msgp.WrapError(err, "HealDisks")
		return
	}
	for za0002 := range z.HealDisks {
		err = en.WriteString(z.HealDisks[za0002])
		if err != nil {
			err = msgp.WrapError(err, "HealDisks", za0002)
			return
		}
	}
	// write "sets"
	err = en.Append(0xa4, 0x73, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Sets)))
	if err != nil {
		err = msgp.WrapError(err, "Sets")
		return
	}
	for za0003 := range z.Sets {
		err = z.Sets[za0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Sets", za0003)
			return
		}
	}
	// write "mrf"
	err = en.Append(0xa3, 0x6d, 0x72, 0x66)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.MRF)))
	if err != nil {
		err = msgp.WrapError(err, "MRF")
		return
	}
	for za0004, za0005 := range z.MRF {
		err = en.WriteString(za0004)
		if err != nil {
			err = msgp.WrapError(err, "MRF")
			return
		}
		// map header, size 2
		// write "bytes_healed"
		err = en.Append(0x82, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(za0005.BytesHealed)
		if err != nil {
			err = msgp.WrapError(err, "MRF", za0004, "BytesHealed")
			return
		}
		// write "items_healed"
		err = en.Append(0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(za0005.ItemsHealed)
		if err != nil {
			err = msgp.WrapError(err, "MRF", za0004, "ItemsHealed")
			return
		}
	}
	// write "sc_parity"
	err = en.Append(0xa9, 0x73, 0x63, 0x5f, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.SCParity)))
	if err != nil {
		err = msgp.WrapError(err, "SCParity")
		return
	}
	for za0006, za0007 := range z.SCParity {
		err = en.WriteString(za0006)
		if err != nil {
			err = msgp.WrapError(err, "SCParity")
			return
		}
		err = en.WriteInt(za0007)
		if err != nil {
			err = msgp.WrapError(err, "SCParity", za0006)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BgHealState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "offline_nodes"
	o = append(o, 0x86, 0xad, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OfflineEndpoints)))
	for za0001 := range z.OfflineEndpoints {
		o = msgp.AppendString(o, z.OfflineEndpoints[za0001])
	}
	// string "ScannedItemsCount"
	o = append(o, 0xb1, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt64(o, z.ScannedItemsCount)
	// string "HealDisks"
	o = append(o, 0xa9, 0x48, 0x65, 0x61, 0x6c, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.HealDisks)))
	for za0002 := range z.HealDisks {
		o = msgp.AppendString(o, z.HealDisks[za0002])
	}
	// string "sets"
	o = append(o, 0xa4, 0x73, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Sets)))
	for za0003 := range z.Sets {
		o, err = z.Sets[za0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Sets", za0003)
			return
		}
	}
	// string "mrf"
	o = append(o, 0xa3, 0x6d, 0x72, 0x66)
	o = msgp.AppendMapHeader(o, uint32(len(z.MRF)))
	for za0004, za0005 := range z.MRF {
		o = msgp.AppendString(o, za0004)
		// map header, size 2
		// string "bytes_healed"
		o = append(o, 0x82, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
		o = msgp.AppendUint64(o, za0005.BytesHealed)
		// string "items_healed"
		o = append(o, 0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
		o = msgp.AppendUint64(o, za0005.ItemsHealed)
	}
	// string "sc_parity"
	o = append(o, 0xa9, 0x73, 0x63, 0x5f, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendMapHeader(o, uint32(len(z.SCParity)))
	for za0006, za0007 := range z.SCParity {
		o = msgp.AppendString(o, za0006)
		o = msgp.AppendInt(o, za0007)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BgHealState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "offline_nodes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OfflineEndpoints")
				return
			}
			if cap(z.OfflineEndpoints) >= int(zb0002) {
				z.OfflineEndpoints = (z.OfflineEndpoints)[:zb0002]
			} else {
				z.OfflineEndpoints = make([]string, zb0002)
			}
			for za0001 := range z.OfflineEndpoints {
				z.OfflineEndpoints[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OfflineEndpoints", za0001)
					return
				}
			}
		case "ScannedItemsCount":
			z.ScannedItemsCount, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ScannedItemsCount")
				return
			}
		case "HealDisks":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealDisks")
				return
			}
			if cap(z.HealDisks) >= int(zb0003) {
				z.HealDisks = (z.HealDisks)[:zb0003]
			} else {
				z.HealDisks = make([]string, zb0003)
			}
			for za0002 := range z.HealDisks {
				z.HealDisks[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HealDisks", za0002)
					return
				}
			}
		case "sets":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sets")
				return
			}
			if cap(z.Sets) >= int(zb0004) {
				z.Sets = (z.Sets)[:zb0004]
			} else {
				z.Sets = make([]SetStatus, zb0004)
			}
			for za0003 := range z.Sets {
				bts, err = z.Sets[za0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sets", za0003)
					return
				}
			}
		case "mrf":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MRF")
				return
			}
			if z.MRF == nil {
				z.MRF = make(map[string]MRFStatus, zb0005)
			} else if len(z.MRF) > 0 {
				for key := range z.MRF {
					delete(z.MRF, key)
				}
			}
			for zb0005 > 0 {
				var za0004 string
				var za0005 MRFStatus
				zb0005--
				za0004, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MRF")
					return
				}
				var zb0006 uint32
				zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MRF", za0004)
					return
				}
				for zb0006 > 0 {
					zb0006--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "MRF", za0004)
						return
					}
					switch msgp.UnsafeString(field) {
					case "bytes_healed":
						za0005.BytesHealed, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004, "BytesHealed")
							return
						}
					case "items_healed":
						za0005.ItemsHealed, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004, "ItemsHealed")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "MRF", za0004)
							return
						}
					}
				}
				z.MRF[za0004] = za0005
			}
		case "sc_parity":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SCParity")
				return
			}
			if z.SCParity == nil {
				z.SCParity = make(map[string]int, zb0007)
			} else if len(z.SCParity) > 0 {
				for key := range z.SCParity {
					delete(z.SCParity, key)
				}
			}
			for zb0007 > 0 {
				var za0006 string
				var za0007 int
				zb0007--
				za0006, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SCParity")
					return
				}
				za0007, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SCParity", za0006)
					return
				}
				z.SCParity[za0006] = za0007
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BgHealState) Msgsize() (s int) {
	s = 1 + 14 + msgp.ArrayHeaderSize
	for za0001 := range z.OfflineEndpoints {
		s += msgp.StringPrefixSize + len(z.OfflineEndpoints[za0001])
	}
	s += 18 + msgp.Int64Size + 10 + msgp.ArrayHeaderSize
	for za0002 := range z.HealDisks {
		s += msgp.StringPrefixSize + len(z.HealDisks[za0002])
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0003 := range z.Sets {
		s += z.Sets[za0003].Msgsize()
	}
	s += 4 + msgp.MapHeaderSize
	if z.MRF != nil {
		for za0004, za0005 := range z.MRF {
			_ = za0005
			s += msgp.StringPrefixSize + len(za0004) + 1 + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size
		}
	}
	s += 10 + msgp.MapHeaderSize
	if z.SCParity != nil {
		for za0006, za0007 := range z.SCParity {
			_ = za0007
			s += msgp.StringPrefixSize + len(za0006) + msgp.IntSize
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealDriveInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uuid":
			z.UUID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "UUID")
				return
			}
		case "endpoint":
			z.Endpoint, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "state":
			z.State, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealDriveInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "uuid"
	err = en.Append(0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.UUID)
	if err != nil {
		err = msgp.WrapError(err, "UUID")
		return
	}
	// write "endpoint"
	err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Endpoint)
	if err != nil {
		err = msgp.WrapError(err, "Endpoint")
		return
	}
	// write "state"
	err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.State)
	if err != nil {
		err = msgp.WrapError(err, "State")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealDriveInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "uuid"
	o = append(o, 0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
	o = msgp.AppendString(o, z.UUID)
	// string "endpoint"
	o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Endpoint)
	// string "state"
	o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
	o = msgp.AppendString(o, z.State)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealDriveInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uuid":
			z.UUID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UUID")
				return
			}
		case "endpoint":
			z.Endpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "state":
			z.State, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealDriveInfo) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.UUID) + 9 + msgp.StringPrefixSize + len(z.Endpoint) + 6 + msgp.StringPrefixSize + len(z.State)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealItemType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealItemType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealItemType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealItemType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealItemType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealItemType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealItemType) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealOpts) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "recursive":
			z.Recursive, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Recursive")
				return
			}
		case "dryRun":
			z.DryRun, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "DryRun")
				return
			}
		case "remove":
			z.Remove, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
		case "recreate":
			z.Recreate, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Recreate")
				return
			}
		case "scanMode":
			{
				var zb0002 int
				zb0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ScanMode")
					return
				}
				z.ScanMode = HealScanMode(zb0002)
			}
		case "updateParity":
			z.UpdateParity, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "UpdateParity")
				return
			}
		case "nolock":
			z.NoLock, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "NoLock")
				return
			}
		case "pool":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Pool")
					return
				}
				z.Pool = nil
			} else {
				if z.Pool == nil {
					z.Pool = new(int)
				}
				*z.Pool, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Pool")
					return
				}
			}
			zb0001Mask |= 0x1
		case "set":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Set")
					return
				}
				z.Set = nil
			} else {
				if z.Set == nil {
					z.Set = new(int)
				}
				*z.Set, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Set")
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Pool = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Set = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HealOpts) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.Pool == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Set == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "recursive"
	err = en.Append(0xa9, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Recursive)
	if err != nil {
		err = msgp.WrapError(err, "Recursive")
		return
	}
	// write "dryRun"
	err = en.Append(0xa6, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.DryRun)
	if err != nil {
		err = msgp.WrapError(err, "DryRun")
		return
	}
	// write "remove"
	err = en.Append(0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Remove)
	if err != nil {
		err = msgp.WrapError(err, "Remove")
		return
	}
	// write "recreate"
	err = en.Append(0xa8, 0x72, 0x65, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Recreate)
	if err != nil {
		err = msgp.WrapError(err, "Recreate")
		return
	}
	// write "scanMode"
	err = en.Append(0xa8, 0x73, 0x63, 0x61, 0x6e, 0x4d, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(int(z.ScanMode))
	if err != nil {
		err = msgp.WrapError(err, "ScanMode")
		return
	}
	// write "updateParity"
	err = en.Append(0xac, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBool(z.UpdateParity)
	if err != nil {
		err = msgp.WrapError(err, "UpdateParity")
		return
	}
	// write "nolock"
	err = en.Append(0xa6, 0x6e, 0x6f, 0x6c, 0x6f, 0x63, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteBool(z.NoLock)
	if err != nil {
		err = msgp.WrapError(err, "NoLock")
		return
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// write "pool"
		err = en.Append(0xa4, 0x70, 0x6f, 0x6f, 0x6c)
		if err != nil {
			return
		}
		if z.Pool == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.Pool)
			if err != nil {
				err = msgp.WrapError(err, "Pool")
				return
			}
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not omitted
		// write "set"
		err = en.Append(0xa3, 0x73, 0x65, 0x74)
		if err != nil {
			return
		}
		if z.Set == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = en.WriteInt(*z.Set)
			if err != nil {
				err = msgp.WrapError(err, "Set")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HealOpts) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.Pool == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Set == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "recursive"
	o = append(o, 0xa9, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65)
	o = msgp.AppendBool(o, z.Recursive)
	// string "dryRun"
	o = append(o, 0xa6, 0x64, 0x72, 0x79, 0x52, 0x75, 0x6e)
	o = msgp.AppendBool(o, z.DryRun)
	// string "remove"
	o = append(o, 0xa6, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65)
	o = msgp.AppendBool(o, z.Remove)
	// string "recreate"
	o = append(o, 0xa8, 0x72, 0x65, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65)
	o = msgp.AppendBool(o, z.Recreate)
	// string "scanMode"
	o = append(o, 0xa8, 0x73, 0x63, 0x61, 0x6e, 0x4d, 0x6f, 0x64, 0x65)
	o = msgp.AppendInt(o, int(z.ScanMode))
	// string "updateParity"
	o = append(o, 0xac, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendBool(o, z.UpdateParity)
	// string "nolock"
	o = append(o, 0xa6, 0x6e, 0x6f, 0x6c, 0x6f, 0x63, 0x6b)
	o = msgp.AppendBool(o, z.NoLock)
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// string "pool"
		o = append(o, 0xa4, 0x70, 0x6f, 0x6f, 0x6c)
		if z.Pool == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Pool)
		}
	}
	if (zb0001Mask & 0x100) == 0 { // if not omitted
		// string "set"
		o = append(o, 0xa3, 0x73, 0x65, 0x74)
		if z.Set == nil {
			o = msgp.AppendNil(o)
		} else {
			o = msgp.AppendInt(o, *z.Set)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealOpts) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "recursive":
			z.Recursive, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Recursive")
				return
			}
		case "dryRun":
			z.DryRun, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DryRun")
				return
			}
		case "remove":
			z.Remove, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Remove")
				return
			}
		case "recreate":
			z.Recreate, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Recreate")
				return
			}
		case "scanMode":
			{
				var zb0002 int
				zb0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ScanMode")
					return
				}
				z.ScanMode = HealScanMode(zb0002)
			}
		case "updateParity":
			z.UpdateParity, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UpdateParity")
				return
			}
		case "nolock":
			z.NoLock, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NoLock")
				return
			}
		case "pool":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Pool = nil
			} else {
				if z.Pool == nil {
					z.Pool = new(int)
				}
				*z.Pool, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Pool")
					return
				}
			}
			zb0001Mask |= 0x1
		case "set":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Set = nil
			} else {
				if z.Set == nil {
					z.Set = new(int)
				}
				*z.Set, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Set")
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Pool = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Set = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HealOpts) Msgsize() (s int) {
	s = 1 + 10 + msgp.BoolSize + 7 + msgp.BoolSize + 7 + msgp.BoolSize + 9 + msgp.BoolSize + 9 + msgp.IntSize + 13 + msgp.BoolSize + 7 + msgp.BoolSize + 5
	if z.Pool == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 4
	if z.Set == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealResultItem) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "resultId":
			z.ResultIndex, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ResultIndex")
				return
			}
		case "type":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = HealItemType(zb0002)
			}
		case "bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "object":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "versionId":
			z.VersionID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "detail":
			z.Detail, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Detail")
				return
			}
		case "parityBlocks":
			z.ParityBlocks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ParityBlocks")
				return
			}
			zb0001Mask |= 0x1
		case "dataBlocks":
			z.DataBlocks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DataBlocks")
				return
			}
			zb0001Mask |= 0x2
		case "diskCount":
			z.DiskCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DiskCount")
				return
			}
		case "setCount":
			z.SetCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SetCount")
				return
			}
		case "before":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Before")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Before")
					return
				}
				switch msgp.UnsafeString(field) {
				case "drives":
					var zb0004 uint32
					zb0004, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "Before", "Drives")
						return
					}
					if cap(z.Before.Drives) >= int(zb0004) {
						z.Before.Drives = (z.Before.Drives)[:zb0004]
					} else {
						z.Before.Drives = make([]HealDriveInfo, zb0004)
					}
					for za0001 := range z.Before.Drives {
						var zb0005 uint32
						zb0005, err = dc.ReadMapHeader()
						if err != nil {
							err = msgp.WrapError(err, "Before", "Drives", za0001)
							return
						}
						for zb0005 > 0 {
							zb0005--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								err = msgp.WrapError(err, "Before", "Drives", za0001)
								return
							}
							switch msgp.UnsafeString(field) {
							case "uuid":
								z.Before.Drives[za0001].UUID, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "UUID")
									return
								}
							case "endpoint":
								z.Before.Drives[za0001].Endpoint, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "Endpoint")
									return
								}
							case "state":
								z.Before.Drives[za0001].State, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "State")
									return
								}
							default:
								err = dc.Skip()
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001)
									return
								}
							}
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Before")
						return
					}
				}
			}
		case "after":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "After")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "After")
					return
				}
				switch msgp.UnsafeString(field) {
				case "drives":
					var zb0007 uint32
					zb0007, err = dc.ReadArrayHeader()
					if err != nil {
						err = msgp.WrapError(err, "After", "Drives")
						return
					}
					if cap(z.After.Drives) >= int(zb0007) {
						z.After.Drives = (z.After.Drives)[:zb0007]
					} else {
						z.After.Drives = make([]HealDriveInfo, zb0007)
					}
					for za0002 := range z.After.Drives {
						var zb0008 uint32
						zb0008, err = dc.ReadMapHeader()
						if err != nil {
							err = msgp.WrapError(err, "After", "Drives", za0002)
							return
						}
						for zb0008 > 0 {
							zb0008--
							field, err = dc.ReadMapKeyPtr()
							if err != nil {
								err = msgp.WrapError(err, "After", "Drives", za0002)
								return
							}
							switch msgp.UnsafeString(field) {
							case "uuid":
								z.After.Drives[za0002].UUID, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "UUID")
									return
								}
							case "endpoint":
								z.After.Drives[za0002].Endpoint, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "Endpoint")
									return
								}
							case "state":
								z.After.Drives[za0002].State, err = dc.ReadString()
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "State")
									return
								}
							default:
								err = dc.Skip()
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002)
									return
								}
							}
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "After")
						return
					}
				}
			}
		case "objectSize":
			z.ObjectSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectSize")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.ParityBlocks = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.DataBlocks = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HealResultItem) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.ParityBlocks == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.DataBlocks == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "resultId"
	err = en.Append(0xa8, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ResultIndex)
	if err != nil {
		err = msgp.WrapError(err, "ResultIndex")
		return
	}
	// write "type"
	err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "bucket"
	err = en.Append(0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "object"
	err = en.Append(0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "versionId"
	err = en.Append(0xa9, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.VersionID)
	if err != nil {
		err = msgp.WrapError(err, "VersionID")
		return
	}
	// write "detail"
	err = en.Append(0xa6, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.Detail)
	if err != nil {
		err = msgp.WrapError(err, "Detail")
		return
	}
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// write "parityBlocks"
		err = en.Append(0xac, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.ParityBlocks)
		if err != nil {
			err = msgp.WrapError(err, "ParityBlocks")
			return
		}
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// write "dataBlocks"
		err = en.Append(0xaa, 0x64, 0x61, 0x74, 0x61, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.DataBlocks)
		if err != nil {
			err = msgp.WrapError(err, "DataBlocks")
			return
		}
	}
	// write "diskCount"
	err = en.Append(0xa9, 0x64, 0x69, 0x73, 0x6b, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DiskCount)
	if err != nil {
		err = msgp.WrapError(err, "DiskCount")
		return
	}
	// write "setCount"
	err = en.Append(0xa8, 0x73, 0x65, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SetCount)
	if err != nil {
		err = msgp.WrapError(err, "SetCount")
		return
	}
	// write "before"
	err = en.Append(0xa6, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
	if err != nil {
		return
	}
	// map header, size 1
	// write "drives"
	err = en.Append(0x81, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Before.Drives)))
	if err != nil {
		err = msgp.WrapError(err, "Before", "Drives")
		return
	}
	for za0001 := range z.Before.Drives {
		// map header, size 3
		// write "uuid"
		err = en.Append(0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.Before.Drives[za0001].UUID)
		if err != nil {
			err = msgp.WrapError(err, "Before", "Drives", za0001, "UUID")
			return
		}
		// write "endpoint"
		err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Before.Drives[za0001].Endpoint)
		if err != nil {
			err = msgp.WrapError(err, "Before", "Drives", za0001, "Endpoint")
			return
		}
		// write "state"
		err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.Before.Drives[za0001].State)
		if err != nil {
			err = msgp.WrapError(err, "Before", "Drives", za0001, "State")
			return
		}
	}
	// write "after"
	err = en.Append(0xa5, 0x61, 0x66, 0x74, 0x65, 0x72)
	if err != nil {
		return
	}
	// map header, size 1
	// write "drives"
	err = en.Append(0x81, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.After.Drives)))
	if err != nil {
		err = msgp.WrapError(err, "After", "Drives")
		return
	}
	for za0002 := range z.After.Drives {
		// map header, size 3
		// write "uuid"
		err = en.Append(0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.After.Drives[za0002].UUID)
		if err != nil {
			err = msgp.WrapError(err, "After", "Drives", za0002, "UUID")
			return
		}
		// write "endpoint"
		err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.After.Drives[za0002].Endpoint)
		if err != nil {
			err = msgp.WrapError(err, "After", "Drives", za0002, "Endpoint")
			return
		}
		// write "state"
		err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.After.Drives[za0002].State)
		if err != nil {
			err = msgp.WrapError(err, "After", "Drives", za0002, "State")
			return
		}
	}
	// write "objectSize"
	err = en.Append(0xaa, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectSize)
	if err != nil {
		err = msgp.WrapError(err, "ObjectSize")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HealResultItem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.ParityBlocks == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.DataBlocks == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "resultId"
	o = append(o, 0xa8, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x49, 0x64)
	o = msgp.AppendInt64(o, z.ResultIndex)
	// string "type"
	o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, string(z.Type))
	// string "bucket"
	o = append(o, 0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "object"
	o = append(o, 0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "versionId"
	o = append(o, 0xa9, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64)
	o = msgp.AppendString(o, z.VersionID)
	// string "detail"
	o = append(o, 0xa6, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.Detail)
	if (zb0001Mask & 0x40) == 0 { // if not omitted
		// string "parityBlocks"
		o = append(o, 0xac, 0x70, 0x61, 0x72, 0x69, 0x74, 0x79, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73)
		o = msgp.AppendInt(o, z.ParityBlocks)
	}
	if (zb0001Mask & 0x80) == 0 { // if not omitted
		// string "dataBlocks"
		o = append(o, 0xaa, 0x64, 0x61, 0x74, 0x61, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73)
		o = msgp.AppendInt(o, z.DataBlocks)
	}
	// string "diskCount"
	o = append(o, 0xa9, 0x64, 0x69, 0x73, 0x6b, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.DiskCount)
	// string "setCount"
	o = append(o, 0xa8, 0x73, 0x65, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.SetCount)
	// string "before"
	o = append(o, 0xa6, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65)
	// map header, size 1
	// string "drives"
	o = append(o, 0x81, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Before.Drives)))
	for za0001 := range z.Before.Drives {
		// map header, size 3
		// string "uuid"
		o = append(o, 0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
		o = msgp.AppendString(o, z.Before.Drives[za0001].UUID)
		// string "endpoint"
		o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		o = msgp.AppendString(o, z.Before.Drives[za0001].Endpoint)
		// string "state"
		o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
		o = msgp.AppendString(o, z.Before.Drives[za0001].State)
	}
	// string "after"
	o = append(o, 0xa5, 0x61, 0x66, 0x74, 0x65, 0x72)
	// map header, size 1
	// string "drives"
	o = append(o, 0x81, 0xa6, 0x64, 0x72, 0x69, 0x76, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.After.Drives)))
	for za0002 := range z.After.Drives {
		// map header, size 3
		// string "uuid"
		o = append(o, 0x83, 0xa4, 0x75, 0x75, 0x69, 0x64)
		o = msgp.AppendString(o, z.After.Drives[za0002].UUID)
		// string "endpoint"
		o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
		o = msgp.AppendString(o, z.After.Drives[za0002].Endpoint)
		// string "state"
		o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
		o = msgp.AppendString(o, z.After.Drives[za0002].State)
	}
	// string "objectSize"
	o = append(o, 0xaa, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt64(o, z.ObjectSize)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealResultItem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "resultId":
			z.ResultIndex, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResultIndex")
				return
			}
		case "type":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = HealItemType(zb0002)
			}
		case "bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "object":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "versionId":
			z.VersionID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VersionID")
				return
			}
		case "detail":
			z.Detail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Detail")
				return
			}
		case "parityBlocks":
			z.ParityBlocks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ParityBlocks")
				return
			}
			zb0001Mask |= 0x1
		case "dataBlocks":
			z.DataBlocks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DataBlocks")
				return
			}
			zb0001Mask |= 0x2
		case "diskCount":
			z.DiskCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiskCount")
				return
			}
		case "setCount":
			z.SetCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SetCount")
				return
			}
		case "before":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Before")
				return
			}
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Before")
					return
				}
				switch msgp.UnsafeString(field) {
				case "drives":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Before", "Drives")
						return
					}
					if cap(z.Before.Drives) >= int(zb0004) {
						z.Before.Drives = (z.Before.Drives)[:zb0004]
					} else {
						z.Before.Drives = make([]HealDriveInfo, zb0004)
					}
					for za0001 := range z.Before.Drives {
						var zb0005 uint32
						zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Before", "Drives", za0001)
							return
						}
						for zb0005 > 0 {
							zb0005--
							field, bts, err = msgp.ReadMapKeyZC(bts)
							if err != nil {
								err = msgp.WrapError(err, "Before", "Drives", za0001)
								return
							}
							switch msgp.UnsafeString(field) {
							case "uuid":
								z.Before.Drives[za0001].UUID, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "UUID")
									return
								}
							case "endpoint":
								z.Before.Drives[za0001].Endpoint, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "Endpoint")
									return
								}
							case "state":
								z.Before.Drives[za0001].State, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001, "State")
									return
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									err = msgp.WrapError(err, "Before", "Drives", za0001)
									return
								}
							}
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Before")
						return
					}
				}
			}
		case "after":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "After")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "After")
					return
				}
				switch msgp.UnsafeString(field) {
				case "drives":
					var zb0007 uint32
					zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "After", "Drives")
						return
					}
					if cap(z.After.Drives) >= int(zb0007) {
						z.After.Drives = (z.After.Drives)[:zb0007]
					} else {
						z.After.Drives = make([]HealDriveInfo, zb0007)
					}
					for za0002 := range z.After.Drives {
						var zb0008 uint32
						zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "After", "Drives", za0002)
							return
						}
						for zb0008 > 0 {
							zb0008--
							field, bts, err = msgp.ReadMapKeyZC(bts)
							if err != nil {
								err = msgp.WrapError(err, "After", "Drives", za0002)
								return
							}
							switch msgp.UnsafeString(field) {
							case "uuid":
								z.After.Drives[za0002].UUID, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "UUID")
									return
								}
							case "endpoint":
								z.After.Drives[za0002].Endpoint, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "Endpoint")
									return
								}
							case "state":
								z.After.Drives[za0002].State, bts, err = msgp.ReadStringBytes(bts)
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002, "State")
									return
								}
							default:
								bts, err = msgp.Skip(bts)
								if err != nil {
									err = msgp.WrapError(err, "After", "Drives", za0002)
									return
								}
							}
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "After")
						return
					}
				}
			}
		case "objectSize":
			z.ObjectSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectSize")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.ParityBlocks = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.DataBlocks = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HealResultItem) Msgsize() (s int) {
	s = 1 + 9 + msgp.Int64Size + 5 + msgp.StringPrefixSize + len(string(z.Type)) + 7 + msgp.StringPrefixSize + len(z.Bucket) + 7 + msgp.StringPrefixSize + len(z.Object) + 10 + msgp.StringPrefixSize + len(z.VersionID) + 7 + msgp.StringPrefixSize + len(z.Detail) + 13 + msgp.IntSize + 11 + msgp.IntSize + 10 + msgp.IntSize + 9 + msgp.IntSize + 7 + 1 + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Before.Drives {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.Before.Drives[za0001].UUID) + 9 + msgp.StringPrefixSize + len(z.Before.Drives[za0001].Endpoint) + 6 + msgp.StringPrefixSize + len(z.Before.Drives[za0001].State)
	}
	s += 6 + 1 + 7 + msgp.ArrayHeaderSize
	for za0002 := range z.After.Drives {
		s += 1 + 5 + msgp.StringPrefixSize + len(z.After.Drives[za0002].UUID) + 9 + msgp.StringPrefixSize + len(z.After.Drives[za0002].Endpoint) + 6 + msgp.StringPrefixSize + len(z.After.Drives[za0002].State)
	}
	s += 11 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealScanMode) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int
		zb0001, err = dc.ReadInt()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealScanMode(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealScanMode) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt(int(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealScanMode) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt(o, int(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealScanMode) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int
		zb0001, bts, err = msgp.ReadIntBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = HealScanMode(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealScanMode) Msgsize() (s int) {
	s = msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealStartSuccess) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "clientToken":
			z.ClientToken, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientToken")
				return
			}
		case "clientAddress":
			z.ClientAddress, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientAddress")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealStartSuccess) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "clientToken"
	err = en.Append(0x83, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientToken)
	if err != nil {
		err = msgp.WrapError(err, "ClientToken")
		return
	}
	// write "clientAddress"
	err = en.Append(0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientAddress)
	if err != nil {
		err = msgp.WrapError(err, "ClientAddress")
		return
	}
	// write "startTime"
	err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealStartSuccess) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "clientToken"
	o = append(o, 0x83, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.ClientToken)
	// string "clientAddress"
	o = append(o, 0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	o = msgp.AppendString(o, z.ClientAddress)
	// string "startTime"
	o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.StartTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealStartSuccess) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "clientToken":
			z.ClientToken, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientToken")
				return
			}
		case "clientAddress":
			z.ClientAddress, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientAddress")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealStartSuccess) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ClientToken) + 14 + msgp.StringPrefixSize + len(z.ClientAddress) + 10 + msgp.TimeSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealStopSuccess) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "clientToken":
			z.ClientToken, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientToken")
				return
			}
		case "clientAddress":
			z.ClientAddress, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ClientAddress")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HealStopSuccess) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "clientToken"
	err = en.Append(0x83, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientToken)
	if err != nil {
		err = msgp.WrapError(err, "ClientToken")
		return
	}
	// write "clientAddress"
	err = en.Append(0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.ClientAddress)
	if err != nil {
		err = msgp.WrapError(err, "ClientAddress")
		return
	}
	// write "startTime"
	err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HealStopSuccess) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "clientToken"
	o = append(o, 0x83, 0xab, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x6f, 0x6b, 0x65, 0x6e)
	o = msgp.AppendString(o, z.ClientToken)
	// string "clientAddress"
	o = append(o, 0xad, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73)
	o = msgp.AppendString(o, z.ClientAddress)
	// string "startTime"
	o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.StartTime)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealStopSuccess) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "clientToken":
			z.ClientToken, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientToken")
				return
			}
		case "clientAddress":
			z.ClientAddress, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClientAddress")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HealStopSuccess) Msgsize() (s int) {
	s = 1 + 12 + msgp.StringPrefixSize + len(z.ClientToken) + 14 + msgp.StringPrefixSize + len(z.ClientAddress) + 10 + msgp.TimeSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealTaskStatus) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "summary":
			z.Summary, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Summary")
				return
			}
		case "detail":
			z.FailureDetail, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FailureDetail")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "settings":
			err = z.HealSettings.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "HealSettings")
				return
			}
		case "items":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Items")
				return
			}
			if cap(z.Items) >= int(zb0002) {
				z.Items = (z.Items)[:zb0002]
			} else {
				z.Items = make([]HealResultItem, zb0002)
			}
			for za0001 := range z.Items {
				err = z.Items[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Items", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Items = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HealTaskStatus) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Items == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "summary"
	err = en.Append(0xa7, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.Summary)
	if err != nil {
		err = msgp.WrapError(err, "Summary")
		return
	}
	// write "detail"
	err = en.Append(0xa6, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.FailureDetail)
	if err != nil {
		err = msgp.WrapError(err, "FailureDetail")
		return
	}
	// write "startTime"
	err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.StartTime)
	if err != nil {
		err = msgp.WrapError(err, "StartTime")
		return
	}
	// write "settings"
	err = en.Append(0xa8, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	if err != nil {
		return
	}
	err = z.HealSettings.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "HealSettings")
		return
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// write "items"
		err = en.Append(0xa5, 0x69, 0x74, 0x65, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Items)))
		if err != nil {
			err = msgp.WrapError(err, "Items")
			return
		}
		for za0001 := range z.Items {
			err = z.Items[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Items", za0001)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HealTaskStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Items == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "summary"
	o = append(o, 0xa7, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79)
	o = msgp.AppendString(o, z.Summary)
	// string "detail"
	o = append(o, 0xa6, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c)
	o = msgp.AppendString(o, z.FailureDetail)
	// string "startTime"
	o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.StartTime)
	// string "settings"
	o = append(o, 0xa8, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73)
	o, err = z.HealSettings.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "HealSettings")
		return
	}
	if (zb0001Mask & 0x10) == 0 { // if not omitted
		// string "items"
		o = append(o, 0xa5, 0x69, 0x74, 0x65, 0x6d, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Items)))
		for za0001 := range z.Items {
			o, err = z.Items[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Items", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealTaskStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "summary":
			z.Summary, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Summary")
				return
			}
		case "detail":
			z.FailureDetail, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailureDetail")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "settings":
			bts, err = z.HealSettings.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealSettings")
				return
			}
		case "items":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Items")
				return
			}
			if cap(z.Items) >= int(zb0002) {
				z.Items = (z.Items)[:zb0002]
			} else {
				z.Items = make([]HealResultItem, zb0002)
			}
			for za0001 := range z.Items {
				bts, err = z.Items[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Items", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1 {
		if (zb0001Mask & 0x1) == 0 {
			z.Items = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HealTaskStatus) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.Summary) + 7 + msgp.StringPrefixSize + len(z.FailureDetail) + 10 + msgp.TimeSize + 9 + z.HealSettings.Msgsize() + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Items {
		s += z.Items[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HealingDisk) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "heal_id":
			z.HealID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HealID")
				return
			}
		case "pool_index":
			z.PoolIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "disk_index":
			z.DiskIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DiskIndex")
				return
			}
		case "endpoint":
			z.Endpoint, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "path":
			z.Path, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "started":
			z.Started, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "Started")
				return
			}
		case "last_update":
			z.LastUpdate, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retry_attempts":
			z.RetryAttempts, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "objects_total_count":
			z.ObjectsTotalCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalCount")
				return
			}
		case "objects_total_size":
			z.ObjectsTotalSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalSize")
				return
			}
		case "items_healed":
			z.ItemsHealed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		case "items_failed":
			z.ItemsFailed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsFailed")
				return
			}
		case "items_skipped":
			z.ItemsSkipped, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsSkipped")
				return
			}
		case "bytes_done":
			z.BytesDone, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BytesDone")
				return
			}
		case "bytes_failed":
			z.BytesFailed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		case "bytes_skipped":
			z.BytesSkipped, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BytesSkipped")
				return
			}
		case "objects_healed":
			z.ObjectsHealed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsHealed")
				return
			}
		case "objects_failed":
			z.ObjectsFailed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "current_bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "current_object":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "queued_buckets":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "QueuedBuckets")
				return
			}
			if cap(z.QueuedBuckets) >= int(zb0002) {
				z.QueuedBuckets = (z.QueuedBuckets)[:zb0002]
			} else {
				z.QueuedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.QueuedBuckets {
				z.QueuedBuckets[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "QueuedBuckets", za0001)
					return
				}
			}
		case "healed_buckets":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "HealedBuckets")
				return
			}
			if cap(z.HealedBuckets) >= int(zb0003) {
				z.HealedBuckets = (z.HealedBuckets)[:zb0003]
			} else {
				z.HealedBuckets = make([]string, zb0003)
			}
			for za0002 := range z.HealedBuckets {
				z.HealedBuckets[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HealedBuckets", za0002)
					return
				}
			}
		case "finished":
			z.Finished, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Finished")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *HealingDisk) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 25
	// write "id"
	err = en.Append(0xde, 0x0, 0x19, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "heal_id"
	err = en.Append(0xa7, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.HealID)
	if err != nil {
		err = msgp.WrapError(err, "HealID")
		return
	}
	// write "pool_index"
	err = en.Append(0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PoolIndex)
	if err != nil {
		err = msgp.WrapError(err, "PoolIndex")
		return
	}
	// write "set_index"
	err = en.Append(0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SetIndex)
	if err != nil {
		err = msgp.WrapError(err, "SetIndex")
		return
	}
	// write "disk_index"
	err = en.Append(0xaa, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DiskIndex)
	if err != nil {
		err = msgp.WrapError(err, "DiskIndex")
		return
	}
	// write "endpoint"
	err = en.Append(0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Endpoint)
	if err != nil {
		err = msgp.WrapError(err, "Endpoint")
		return
	}
	// write "path"
	err = en.Append(0xa4, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.Path)
	if err != nil {
		err = msgp.WrapError(err, "Path")
		return
	}
	// write "started"
	err = en.Append(0xa7, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Started)
	if err != nil {
		err = msgp.WrapError(err, "Started")
		return
	}
	// write "last_update"
	err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.LastUpdate)
	if err != nil {
		err = msgp.WrapError(err, "LastUpdate")
		return
	}
	// write "retry_attempts"
	err = en.Append(0xae, 0x72, 0x65, 0x74, 0x72, 0x79, 0x5f, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.RetryAttempts)
	if err != nil {
		err = msgp.WrapError(err, "RetryAttempts")
		return
	}
	// write "objects_total_count"
	err = en.Append(0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsTotalCount)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsTotalCount")
		return
	}
	// write "objects_total_size"
	err = en.Append(0xb2, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsTotalSize)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsTotalSize")
		return
	}
	// write "items_healed"
	err = en.Append(0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsHealed)
	if err != nil {
		err = msgp.WrapError(err, "ItemsHealed")
		return
	}
	// write "items_failed"
	err = en.Append(0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ItemsFailed")
		return
	}
	// write "items_skipped"
	err = en.Append(0xad, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsSkipped)
	if err != nil {
		err = msgp.WrapError(err, "ItemsSkipped")
		return
	}
	// write "bytes_done"
	err = en.Append(0xaa, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x64, 0x6f, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesDone)
	if err != nil {
		err = msgp.WrapError(err, "BytesDone")
		return
	}
	// write "bytes_failed"
	err = en.Append(0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesFailed)
	if err != nil {
		err = msgp.WrapError(err, "BytesFailed")
		return
	}
	// write "bytes_skipped"
	err = en.Append(0xad, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesSkipped)
	if err != nil {
		err = msgp.WrapError(err, "BytesSkipped")
		return
	}
	// write "objects_healed"
	err = en.Append(0xae, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsHealed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsHealed")
		return
	}
	// write "objects_failed"
	err = en.Append(0xae, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	// write "current_bucket"
	err = en.Append(0xae, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "current_object"
	err = en.Append(0xae, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "queued_buckets"
	err = en.Append(0xae, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.QueuedBuckets)))
	if err != nil {
		err = msgp.WrapError(err, "QueuedBuckets")
		return
	}
	for za0001 := range z.QueuedBuckets {
		err = en.WriteString(z.QueuedBuckets[za0001])
		if err != nil {
			err = msgp.WrapError(err, "QueuedBuckets", za0001)
			return
		}
	}
	// write "healed_buckets"
	err = en.Append(0xae, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.HealedBuckets)))
	if err != nil {
		err = msgp.WrapError(err, "HealedBuckets")
		return
	}
	for za0002 := range z.HealedBuckets {
		err = en.WriteString(z.HealedBuckets[za0002])
		if err != nil {
			err = msgp.WrapError(err, "HealedBuckets", za0002)
			return
		}
	}
	// write "finished"
	err = en.Append(0xa8, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Finished)
	if err != nil {
		err = msgp.WrapError(err, "Finished")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *HealingDisk) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 25
	// string "id"
	o = append(o, 0xde, 0x0, 0x19, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "heal_id"
	o = append(o, 0xa7, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.HealID)
	// string "pool_index"
	o = append(o, 0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.PoolIndex)
	// string "set_index"
	o = append(o, 0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.SetIndex)
	// string "disk_index"
	o = append(o, 0xaa, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.DiskIndex)
	// string "endpoint"
	o = append(o, 0xa8, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74)
	o = msgp.AppendString(o, z.Endpoint)
	// string "path"
	o = append(o, 0xa4, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.Path)
	// string "started"
	o = append(o, 0xa7, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.Started)
	// string "last_update"
	o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65)
	o = msgp.AppendTime(o, z.LastUpdate)
	// string "retry_attempts"
	o = append(o, 0xae, 0x72, 0x65, 0x74, 0x72, 0x79, 0x5f, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
	o = msgp.AppendUint64(o, z.RetryAttempts)
	// string "objects_total_count"
	o = append(o, 0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ObjectsTotalCount)
	// string "objects_total_size"
	o = append(o, 0xb2, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint64(o, z.ObjectsTotalSize)
	// string "items_healed"
	o = append(o, 0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsHealed)
	// string "items_failed"
	o = append(o, 0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsFailed)
	// string "items_skipped"
	o = append(o, 0xad, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsSkipped)
	// string "bytes_done"
	o = append(o, 0xaa, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x64, 0x6f, 0x6e, 0x65)
	o = msgp.AppendUint64(o, z.BytesDone)
	// string "bytes_failed"
	o = append(o, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.BytesFailed)
	// string "bytes_skipped"
	o = append(o, 0xad, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x73, 0x6b, 0x69, 0x70, 0x70, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.BytesSkipped)
	// string "objects_healed"
	o = append(o, 0xae, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ObjectsHealed)
	// string "objects_failed"
	o = append(o, 0xae, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ObjectsFailed)
	// string "current_bucket"
	o = append(o, 0xae, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "current_object"
	o = append(o, 0xae, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "queued_buckets"
	o = append(o, 0xae, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.QueuedBuckets)))
	for za0001 := range z.QueuedBuckets {
		o = msgp.AppendString(o, z.QueuedBuckets[za0001])
	}
	// string "healed_buckets"
	o = append(o, 0xae, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.HealedBuckets)))
	for za0002 := range z.HealedBuckets {
		o = msgp.AppendString(o, z.HealedBuckets[za0002])
	}
	// string "finished"
	o = append(o, 0xa8, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Finished)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HealingDisk) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "heal_id":
			z.HealID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealID")
				return
			}
		case "pool_index":
			z.PoolIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "disk_index":
			z.DiskIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiskIndex")
				return
			}
		case "endpoint":
			z.Endpoint, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Endpoint")
				return
			}
		case "path":
			z.Path, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Path")
				return
			}
		case "started":
			z.Started, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Started")
				return
			}
		case "last_update":
			z.LastUpdate, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retry_attempts":
			z.RetryAttempts, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "objects_total_count":
			z.ObjectsTotalCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalCount")
				return
			}
		case "objects_total_size":
			z.ObjectsTotalSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsTotalSize")
				return
			}
		case "items_healed":
			z.ItemsHealed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		case "items_failed":
			z.ItemsFailed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsFailed")
				return
			}
		case "items_skipped":
			z.ItemsSkipped, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsSkipped")
				return
			}
		case "bytes_done":
			z.BytesDone, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesDone")
				return
			}
		case "bytes_failed":
			z.BytesFailed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		case "bytes_skipped":
			z.BytesSkipped, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesSkipped")
				return
			}
		case "objects_healed":
			z.ObjectsHealed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsHealed")
				return
			}
		case "objects_failed":
			z.ObjectsFailed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "current_bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "current_object":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "queued_buckets":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QueuedBuckets")
				return
			}
			if cap(z.QueuedBuckets) >= int(zb0002) {
				z.QueuedBuckets = (z.QueuedBuckets)[:zb0002]
			} else {
				z.QueuedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.QueuedBuckets {
				z.QueuedBuckets[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "QueuedBuckets", za0001)
					return
				}
			}
		case "healed_buckets":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealedBuckets")
				return
			}
			if cap(z.HealedBuckets) >= int(zb0003) {
				z.HealedBuckets = (z.HealedBuckets)[:zb0003]
			} else {
				z.HealedBuckets = make([]string, zb0003)
			}
			for za0002 := range z.HealedBuckets {
				z.HealedBuckets[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HealedBuckets", za0002)
					return
				}
			}
		case "finished":
			z.Finished, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Finished")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *HealingDisk) Msgsize() (s int) {
	s = 3 + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.StringPrefixSize + len(z.HealID) + 11 + msgp.IntSize + 10 + msgp.IntSize + 11 + msgp.IntSize + 9 + msgp.StringPrefixSize + len(z.Endpoint) + 5 + msgp.StringPrefixSize + len(z.Path) + 8 + msgp.TimeSize + 12 + msgp.TimeSize + 15 + msgp.Uint64Size + 20 + msgp.Uint64Size + 19 + msgp.Uint64Size + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size + 14 + msgp.Uint64Size + 11 + msgp.Uint64Size + 13 + msgp.Uint64Size + 14 + msgp.Uint64Size + 15 + msgp.Uint64Size + 15 + msgp.Uint64Size + 15 + msgp.StringPrefixSize + len(z.Bucket) + 15 + msgp.StringPrefixSize + len(z.Object) + 15 + msgp.ArrayHeaderSize
	for za0001 := range z.QueuedBuckets {
		s += msgp.StringPrefixSize + len(z.QueuedBuckets[za0001])
	}
	s += 15 + msgp.ArrayHeaderSize
	for za0002 := range z.HealedBuckets {
		s += msgp.StringPrefixSize + len(z.HealedBuckets[za0002])
	}
	s += 9 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MRFStatus) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bytes_healed":
			z.BytesHealed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "BytesHealed")
				return
			}
		case "items_healed":
			z.ItemsHealed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MRFStatus) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "bytes_healed"
	err = en.Append(0x82, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.BytesHealed)
	if err != nil {
		err = msgp.WrapError(err, "BytesHealed")
		return
	}
	// write "items_healed"
	err = en.Append(0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsHealed)
	if err != nil {
		err = msgp.WrapError(err, "ItemsHealed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MRFStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "bytes_healed"
	o = append(o, 0x82, 0xac, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.BytesHealed)
	// string "items_healed"
	o = append(o, 0xac, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x5f, 0x68, 0x65, 0x61, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsHealed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MRFStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bytes_healed":
			z.BytesHealed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesHealed")
				return
			}
		case "items_healed":
			z.ItemsHealed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MRFStatus) Msgsize() (s int) {
	s = 1 + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SetStatus) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "pool_index":
			z.PoolIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "heal_status":
			z.HealStatus, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HealStatus")
				return
			}
		case "heal_priority":
			z.HealPriority, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HealPriority")
				return
			}
		case "total_objects":
			z.TotalObjects, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TotalObjects")
				return
			}
		case "disks":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0002) {
				z.Disks = (z.Disks)[:zb0002]
			} else {
				z.Disks = make([]Disk, zb0002)
			}
			for za0001 := range z.Disks {
				err = z.Disks[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SetStatus) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "id"
	err = en.Append(0x87, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "pool_index"
	err = en.Append(0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PoolIndex)
	if err != nil {
		err = msgp.WrapError(err, "PoolIndex")
		return
	}
	// write "set_index"
	err = en.Append(0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SetIndex)
	if err != nil {
		err = msgp.WrapError(err, "SetIndex")
		return
	}
	// write "heal_status"
	err = en.Append(0xab, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.HealStatus)
	if err != nil {
		err = msgp.WrapError(err, "HealStatus")
		return
	}
	// write "heal_priority"
	err = en.Append(0xad, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.HealPriority)
	if err != nil {
		err = msgp.WrapError(err, "HealPriority")
		return
	}
	// write "total_objects"
	err = en.Append(0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TotalObjects)
	if err != nil {
		err = msgp.WrapError(err, "TotalObjects")
		return
	}
	// write "disks"
	err = en.Append(0xa5, 0x64, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Disks)))
	if err != nil {
		err = msgp.WrapError(err, "Disks")
		return
	}
	for za0001 := range z.Disks {
		err = z.Disks[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SetStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "id"
	o = append(o, 0x87, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "pool_index"
	o = append(o, 0xaa, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.PoolIndex)
	// string "set_index"
	o = append(o, 0xa9, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendInt(o, z.SetIndex)
	// string "heal_status"
	o = append(o, 0xab, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendString(o, z.HealStatus)
	// string "heal_priority"
	o = append(o, 0xad, 0x68, 0x65, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79)
	o = msgp.AppendString(o, z.HealPriority)
	// string "total_objects"
	o = append(o, 0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt(o, z.TotalObjects)
	// string "disks"
	o = append(o, 0xa5, 0x64, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Disks)))
	for za0001 := range z.Disks {
		o, err = z.Disks[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SetStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "pool_index":
			z.PoolIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolIndex")
				return
			}
		case "set_index":
			z.SetIndex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SetIndex")
				return
			}
		case "heal_status":
			z.HealStatus, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealStatus")
				return
			}
		case "heal_priority":
			z.HealPriority, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealPriority")
				return
			}
		case "total_objects":
			z.TotalObjects, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalObjects")
				return
			}
		case "disks":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0002) {
				z.Disks = (z.Disks)[:zb0002]
			} else {
				z.Disks = make([]Disk, zb0002)
			}
			for za0001 := range z.Disks {
				bts, err = z.Disks[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SetStatus) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 11 + msgp.IntSize + 10 + msgp.IntSize + 12 + msgp.StringPrefixSize + len(z.HealStatus) + 14 + msgp.StringPrefixSize + len(z.HealPriority) + 14 + msgp.IntSize + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Disks {
		s += z.Disks[za0001].Msgsize()
	}
	return
}
