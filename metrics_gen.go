package madmin

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"runtime/metrics"
	"time"

	"github.com/shirou/gopsutil/v3/cpu"
	"github.com/shirou/gopsutil/v3/load"
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *BatchJobMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "Jobs":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Jobs")
				return
			}
			if z.Jobs == nil {
				z.Jobs = make(map[string]JobMetric, zb0002)
			} else if len(z.Jobs) > 0 {
				for key := range z.Jobs {
					delete(z.Jobs, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 JobMetric
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Jobs")
					return
				}
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Jobs", za0001)
					return
				}
				z.Jobs[za0001] = za0002
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BatchJobMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "collected"
	err = en.Append(0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "Jobs"
	err = en.Append(0xa4, 0x4a, 0x6f, 0x62, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Jobs)))
	if err != nil {
		err = msgp.WrapError(err, "Jobs")
		return
	}
	for za0001, za0002 := range z.Jobs {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Jobs")
			return
		}
		err = za0002.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Jobs", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BatchJobMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "collected"
	o = append(o, 0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "Jobs"
	o = append(o, 0xa4, 0x4a, 0x6f, 0x62, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Jobs)))
	for za0001, za0002 := range z.Jobs {
		o = msgp.AppendString(o, za0001)
		o, err = za0002.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Jobs", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BatchJobMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "Jobs":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Jobs")
				return
			}
			if z.Jobs == nil {
				z.Jobs = make(map[string]JobMetric, zb0002)
			} else if len(z.Jobs) > 0 {
				for key := range z.Jobs {
					delete(z.Jobs, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 JobMetric
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Jobs")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Jobs", za0001)
					return
				}
				z.Jobs[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BatchJobMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 5 + msgp.MapHeaderSize
	if z.Jobs != nil {
		for za0001, za0002 := range z.Jobs {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CPUMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "timesStat":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
				z.TimesStat = nil
			} else {
				if z.TimesStat == nil {
					z.TimesStat = new(cpu.TimesStat)
				}
				err = (*cpuTimesStat)(z.TimesStat).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
			}
		case "loadStat":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
				z.LoadStat = nil
			} else {
				if z.LoadStat == nil {
					z.LoadStat = new(load.AvgStat)
				}
				err = (*loadAvgStat)(z.LoadStat).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
			}
		case "cpuCount":
			z.CPUCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CPUCount")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CPUMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "collected"
	err = en.Append(0x84, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "timesStat"
	err = en.Append(0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74)
	if err != nil {
		return
	}
	if z.TimesStat == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = (*cpuTimesStat)(z.TimesStat).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "TimesStat")
			return
		}
	}
	// write "loadStat"
	err = en.Append(0xa8, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74)
	if err != nil {
		return
	}
	if z.LoadStat == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = (*loadAvgStat)(z.LoadStat).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "LoadStat")
			return
		}
	}
	// write "cpuCount"
	err = en.Append(0xa8, 0x63, 0x70, 0x75, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CPUCount)
	if err != nil {
		err = msgp.WrapError(err, "CPUCount")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CPUMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "collected"
	o = append(o, 0x84, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "timesStat"
	o = append(o, 0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74)
	if z.TimesStat == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = (*cpuTimesStat)(z.TimesStat).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "TimesStat")
			return
		}
	}
	// string "loadStat"
	o = append(o, 0xa8, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74)
	if z.LoadStat == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = (*loadAvgStat)(z.LoadStat).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LoadStat")
			return
		}
	}
	// string "cpuCount"
	o = append(o, 0xa8, 0x63, 0x70, 0x75, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.CPUCount)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CPUMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "timesStat":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TimesStat = nil
			} else {
				if z.TimesStat == nil {
					z.TimesStat = new(cpu.TimesStat)
				}
				bts, err = (*cpuTimesStat)(z.TimesStat).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
			}
		case "loadStat":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LoadStat = nil
			} else {
				if z.LoadStat == nil {
					z.LoadStat = new(load.AvgStat)
				}
				bts, err = (*loadAvgStat)(z.LoadStat).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
			}
		case "cpuCount":
			z.CPUCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CPUCount")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CPUMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 10
	if z.TimesStat == nil {
		s += msgp.NilSize
	} else {
		s += (*cpuTimesStat)(z.TimesStat).Msgsize()
	}
	s += 9
	if z.LoadStat == nil {
		s += msgp.NilSize
	} else {
		s += (*loadAvgStat)(z.LoadStat).Msgsize()
	}
	s += 9 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CatalogInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucketScanned":
			z.LastBucketScanned, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastBucketScanned")
				return
			}
		case "lastObjectScanned":
			z.LastObjectScanned, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastObjectScanned")
				return
			}
		case "lastBucketMatched":
			z.LastBucketMatched, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastBucketMatched")
				return
			}
		case "lastObjectMatched":
			z.LastObjectMatched, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastObjectMatched")
				return
			}
		case "objectsScannedCount":
			z.ObjectsScannedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsScannedCount")
				return
			}
		case "objectsMatchedCount":
			z.ObjectsMatchedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsMatchedCount")
				return
			}
		case "recordsWrittenCount":
			z.RecordsWrittenCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RecordsWrittenCount")
				return
			}
		case "outputObjectsCount":
			z.OutputObjectsCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "OutputObjectsCount")
				return
			}
		case "manifestPathBucket":
			z.ManifestPathBucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathBucket")
				return
			}
		case "manifestPathObject":
			z.ManifestPathObject, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathObject")
				return
			}
		case "errorMsg":
			z.ErrorMsg, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ErrorMsg")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CatalogInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "lastBucketScanned"
	err = en.Append(0x8b, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.LastBucketScanned)
	if err != nil {
		err = msgp.WrapError(err, "LastBucketScanned")
		return
	}
	// write "lastObjectScanned"
	err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.LastObjectScanned)
	if err != nil {
		err = msgp.WrapError(err, "LastObjectScanned")
		return
	}
	// write "lastBucketMatched"
	err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.LastBucketMatched)
	if err != nil {
		err = msgp.WrapError(err, "LastBucketMatched")
		return
	}
	// write "lastObjectMatched"
	err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.LastObjectMatched)
	if err != nil {
		err = msgp.WrapError(err, "LastObjectMatched")
		return
	}
	// write "objectsScannedCount"
	err = en.Append(0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsScannedCount)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsScannedCount")
		return
	}
	// write "objectsMatchedCount"
	err = en.Append(0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ObjectsMatchedCount)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsMatchedCount")
		return
	}
	// write "recordsWrittenCount"
	err = en.Append(0xb3, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.RecordsWrittenCount)
	if err != nil {
		err = msgp.WrapError(err, "RecordsWrittenCount")
		return
	}
	// write "outputObjectsCount"
	err = en.Append(0xb2, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.OutputObjectsCount)
	if err != nil {
		err = msgp.WrapError(err, "OutputObjectsCount")
		return
	}
	// write "manifestPathBucket"
	err = en.Append(0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.ManifestPathBucket)
	if err != nil {
		err = msgp.WrapError(err, "ManifestPathBucket")
		return
	}
	// write "manifestPathObject"
	err = en.Append(0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.ManifestPathObject)
	if err != nil {
		err = msgp.WrapError(err, "ManifestPathObject")
		return
	}
	// write "errorMsg"
	err = en.Append(0xa8, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x73, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.ErrorMsg)
	if err != nil {
		err = msgp.WrapError(err, "ErrorMsg")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CatalogInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "lastBucketScanned"
	o = append(o, 0x8b, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendString(o, z.LastBucketScanned)
	// string "lastObjectScanned"
	o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
	o = msgp.AppendString(o, z.LastObjectScanned)
	// string "lastBucketMatched"
	o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
	o = msgp.AppendString(o, z.LastBucketMatched)
	// string "lastObjectMatched"
	o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
	o = msgp.AppendString(o, z.LastObjectMatched)
	// string "objectsScannedCount"
	o = append(o, 0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ObjectsScannedCount)
	// string "objectsMatchedCount"
	o = append(o, 0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.ObjectsMatchedCount)
	// string "recordsWrittenCount"
	o = append(o, 0xb3, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.RecordsWrittenCount)
	// string "outputObjectsCount"
	o = append(o, 0xb2, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint64(o, z.OutputObjectsCount)
	// string "manifestPathBucket"
	o = append(o, 0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.ManifestPathBucket)
	// string "manifestPathObject"
	o = append(o, 0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.ManifestPathObject)
	// string "errorMsg"
	o = append(o, 0xa8, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x73, 0x67)
	o = msgp.AppendString(o, z.ErrorMsg)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CatalogInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucketScanned":
			z.LastBucketScanned, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketScanned")
				return
			}
		case "lastObjectScanned":
			z.LastObjectScanned, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectScanned")
				return
			}
		case "lastBucketMatched":
			z.LastBucketMatched, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketMatched")
				return
			}
		case "lastObjectMatched":
			z.LastObjectMatched, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectMatched")
				return
			}
		case "objectsScannedCount":
			z.ObjectsScannedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsScannedCount")
				return
			}
		case "objectsMatchedCount":
			z.ObjectsMatchedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsMatchedCount")
				return
			}
		case "recordsWrittenCount":
			z.RecordsWrittenCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RecordsWrittenCount")
				return
			}
		case "outputObjectsCount":
			z.OutputObjectsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutputObjectsCount")
				return
			}
		case "manifestPathBucket":
			z.ManifestPathBucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathBucket")
				return
			}
		case "manifestPathObject":
			z.ManifestPathObject, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathObject")
				return
			}
		case "errorMsg":
			z.ErrorMsg, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ErrorMsg")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CatalogInfo) Msgsize() (s int) {
	s = 1 + 18 + msgp.StringPrefixSize + len(z.LastBucketScanned) + 18 + msgp.StringPrefixSize + len(z.LastObjectScanned) + 18 + msgp.StringPrefixSize + len(z.LastBucketMatched) + 18 + msgp.StringPrefixSize + len(z.LastObjectMatched) + 20 + msgp.Uint64Size + 20 + msgp.Uint64Size + 20 + msgp.Uint64Size + 19 + msgp.Uint64Size + 19 + msgp.StringPrefixSize + len(z.ManifestPathBucket) + 19 + msgp.StringPrefixSize + len(z.ManifestPathObject) + 9 + msgp.StringPrefixSize + len(z.ErrorMsg)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DiskIOStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "read_ios":
			z.ReadIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
		case "read_merges":
			z.ReadMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
		case "read_sectors":
			z.ReadSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
		case "read_ticks":
			z.ReadTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
		case "write_ios":
			z.WriteIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
		case "write_merges":
			z.WriteMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
		case "wrte_sectors":
			z.WriteSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
		case "write_ticks":
			z.WriteTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
		case "current_ios":
			z.CurrentIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
		case "total_ticks":
			z.TotalTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
		case "req_ticks":
			z.ReqTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
		case "discard_ios":
			z.DiscardIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
		case "discard_merges":
			z.DiscardMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
		case "discard_secotrs":
			z.DiscardSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
		case "discard_ticks":
			z.DiscardTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
		case "flush_ios":
			z.FlushIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
		case "flush_ticks":
			z.FlushTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DiskIOStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 17
	// write "read_ios"
	err = en.Append(0xde, 0x0, 0x11, 0xa8, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69, 0x6f, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReadIOs)
	if err != nil {
		err = msgp.WrapError(err, "ReadIOs")
		return
	}
	// write "read_merges"
	err = en.Append(0xab, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReadMerges)
	if err != nil {
		err = msgp.WrapError(err, "ReadMerges")
		return
	}
	// write "read_sectors"
	err = en.Append(0xac, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReadSectors)
	if err != nil {
		err = msgp.WrapError(err, "ReadSectors")
		return
	}
	// write "read_ticks"
	err = en.Append(0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReadTicks)
	if err != nil {
		err = msgp.WrapError(err, "ReadTicks")
		return
	}
	// write "write_ios"
	err = en.Append(0xa9, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6f, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.WriteIOs)
	if err != nil {
		err = msgp.WrapError(err, "WriteIOs")
		return
	}
	// write "write_merges"
	err = en.Append(0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.WriteMerges)
	if err != nil {
		err = msgp.WrapError(err, "WriteMerges")
		return
	}
	// write "wrte_sectors"
	err = en.Append(0xac, 0x77, 0x72, 0x74, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.WriteSectors)
	if err != nil {
		err = msgp.WrapError(err, "WriteSectors")
		return
	}
	// write "write_ticks"
	err = en.Append(0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.WriteTicks)
	if err != nil {
		err = msgp.WrapError(err, "WriteTicks")
		return
	}
	// write "current_ios"
	err = en.Append(0xab, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CurrentIOs)
	if err != nil {
		err = msgp.WrapError(err, "CurrentIOs")
		return
	}
	// write "total_ticks"
	err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TotalTicks)
	if err != nil {
		err = msgp.WrapError(err, "TotalTicks")
		return
	}
	// write "req_ticks"
	err = en.Append(0xa9, 0x72, 0x65, 0x71, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ReqTicks)
	if err != nil {
		err = msgp.WrapError(err, "ReqTicks")
		return
	}
	// write "discard_ios"
	err = en.Append(0xab, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6f, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.DiscardIOs)
	if err != nil {
		err = msgp.WrapError(err, "DiscardIOs")
		return
	}
	// write "discard_merges"
	err = en.Append(0xae, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.DiscardMerges)
	if err != nil {
		err = msgp.WrapError(err, "DiscardMerges")
		return
	}
	// write "discard_secotrs"
	err = en.Append(0xaf, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x74, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.DiscardSectors)
	if err != nil {
		err = msgp.WrapError(err, "DiscardSectors")
		return
	}
	// write "discard_ticks"
	err = en.Append(0xad, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.DiscardTicks)
	if err != nil {
		err = msgp.WrapError(err, "DiscardTicks")
		return
	}
	// write "flush_ios"
	err = en.Append(0xa9, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x69, 0x6f, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.FlushIOs)
	if err != nil {
		err = msgp.WrapError(err, "FlushIOs")
		return
	}
	// write "flush_ticks"
	err = en.Append(0xab, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.FlushTicks)
	if err != nil {
		err = msgp.WrapError(err, "FlushTicks")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DiskIOStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 17
	// string "read_ios"
	o = append(o, 0xde, 0x0, 0x11, 0xa8, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69, 0x6f, 0x73)
	o = msgp.AppendUint64(o, z.ReadIOs)
	// string "read_merges"
	o = append(o, 0xab, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.ReadMerges)
	// string "read_sectors"
	o = append(o, 0xac, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
	o = msgp.AppendUint64(o, z.ReadSectors)
	// string "read_ticks"
	o = append(o, 0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	o = msgp.AppendUint64(o, z.ReadTicks)
	// string "write_ios"
	o = append(o, 0xa9, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6f, 0x73)
	o = msgp.AppendUint64(o, z.WriteIOs)
	// string "write_merges"
	o = append(o, 0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.WriteMerges)
	// string "wrte_sectors"
	o = append(o, 0xac, 0x77, 0x72, 0x74, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
	o = msgp.AppendUint64(o, z.WriteSectors)
	// string "write_ticks"
	o = append(o, 0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	o = msgp.AppendUint64(o, z.WriteTicks)
	// string "current_ios"
	o = append(o, 0xab, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x73)
	o = msgp.AppendUint64(o, z.CurrentIOs)
	// string "total_ticks"
	o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	o = msgp.AppendUint64(o, z.TotalTicks)
	// string "req_ticks"
	o = append(o, 0xa9, 0x72, 0x65, 0x71, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	o = msgp.AppendUint64(o, z.ReqTicks)
	// string "discard_ios"
	o = append(o, 0xab, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6f, 0x73)
	o = msgp.AppendUint64(o, z.DiscardIOs)
	// string "discard_merges"
	o = append(o, 0xae, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
	o = msgp.AppendUint64(o, z.DiscardMerges)
	// string "discard_secotrs"
	o = append(o, 0xaf, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x74, 0x72, 0x73)
	o = msgp.AppendUint64(o, z.DiscardSectors)
	// string "discard_ticks"
	o = append(o, 0xad, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	o = msgp.AppendUint64(o, z.DiscardTicks)
	// string "flush_ios"
	o = append(o, 0xa9, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x69, 0x6f, 0x73)
	o = msgp.AppendUint64(o, z.FlushIOs)
	// string "flush_ticks"
	o = append(o, 0xab, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
	o = msgp.AppendUint64(o, z.FlushTicks)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DiskIOStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "read_ios":
			z.ReadIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
		case "read_merges":
			z.ReadMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
		case "read_sectors":
			z.ReadSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
		case "read_ticks":
			z.ReadTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
		case "write_ios":
			z.WriteIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
		case "write_merges":
			z.WriteMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
		case "wrte_sectors":
			z.WriteSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
		case "write_ticks":
			z.WriteTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
		case "current_ios":
			z.CurrentIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
		case "total_ticks":
			z.TotalTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
		case "req_ticks":
			z.ReqTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
		case "discard_ios":
			z.DiscardIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
		case "discard_merges":
			z.DiscardMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
		case "discard_secotrs":
			z.DiscardSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
		case "discard_ticks":
			z.DiscardTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
		case "flush_ios":
			z.FlushIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
		case "flush_ticks":
			z.FlushTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DiskIOStats) Msgsize() (s int) {
	s = 3 + 9 + msgp.Uint64Size + 12 + msgp.Uint64Size + 13 + msgp.Uint64Size + 11 + msgp.Uint64Size + 10 + msgp.Uint64Size + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 10 + msgp.Uint64Size + 12 + msgp.Uint64Size + 15 + msgp.Uint64Size + 16 + msgp.Uint64Size + 14 + msgp.Uint64Size + 10 + msgp.Uint64Size + 12 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DiskMetric) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "n_disks":
			z.NDisks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NDisks")
				return
			}
		case "offline":
			z.Offline, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
			zb0001Mask |= 0x1
		case "healing":
			z.Healing, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
			zb0001Mask |= 0x2
		case "life_time_ops":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 uint64
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x4
		case "last_minute":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						for key := range z.LastMinute.Operations {
							delete(z.LastMinute.Operations, key)
						}
					}
					for zb0004 > 0 {
						zb0004--
						var za0003 string
						var za0004 TimedAction
						za0003, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						err = za0004.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		case "iostats":
			err = z.IOStats.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "IOStats")
				return
			}
			zb0001Mask |= 0x8
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Offline = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Healing = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.IOStats = DiskIOStats{}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DiskMetric) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.Offline == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Healing == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "n_disks"
		err = en.Append(0xa7, 0x6e, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.NDisks)
		if err != nil {
			err = msgp.WrapError(err, "NDisks")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "offline"
			err = en.Append(0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Offline)
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "healing"
			err = en.Append(0xa7, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Healing)
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "life_time_ops"
			err = en.Append(0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			for za0001, za0002 := range z.LifeTimeOps {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				err = en.WriteUint64(za0002)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
			}
		}
		// write "last_minute"
		err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// write "operations"
			err = en.Append(0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinute.Operations)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinute", "Operations")
				return
			}
			for za0003, za0004 := range z.LastMinute.Operations {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
		// write "iostats"
		err = en.Append(0xa7, 0x69, 0x6f, 0x73, 0x74, 0x61, 0x74, 0x73)
		if err != nil {
			return
		}
		err = z.IOStats.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "IOStats")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DiskMetric) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.Offline == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Healing == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "n_disks"
		o = append(o, 0xa7, 0x6e, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x73)
		o = msgp.AppendInt(o, z.NDisks)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "offline"
			o = append(o, 0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
			o = msgp.AppendInt(o, z.Offline)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "healing"
			o = append(o, 0xa7, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67)
			o = msgp.AppendInt(o, z.Healing)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "life_time_ops"
			o = append(o, 0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeOps)))
			for za0001, za0002 := range z.LifeTimeOps {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendUint64(o, za0002)
			}
		}
		// string "last_minute"
		o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// string "operations"
			o = append(o, 0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.Operations)))
			for za0003, za0004 := range z.LastMinute.Operations {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
		// string "iostats"
		o = append(o, 0xa7, 0x69, 0x6f, 0x73, 0x74, 0x61, 0x74, 0x73)
		o, err = z.IOStats.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "IOStats")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DiskMetric) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "n_disks":
			z.NDisks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NDisks")
				return
			}
		case "offline":
			z.Offline, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
			zb0001Mask |= 0x1
		case "healing":
			z.Healing, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
			zb0001Mask |= 0x2
		case "life_time_ops":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 uint64
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x4
		case "last_minute":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						for key := range z.LastMinute.Operations {
							delete(z.LastMinute.Operations, key)
						}
					}
					for zb0004 > 0 {
						var za0003 string
						var za0004 TimedAction
						zb0004--
						za0003, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						bts, err = za0004.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		case "iostats":
			bts, err = z.IOStats.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "IOStats")
				return
			}
			zb0001Mask |= 0x8
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Offline = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Healing = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.IOStats = DiskIOStats{}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DiskMetric) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 8 + msgp.IntSize + 8 + msgp.IntSize + 8 + msgp.IntSize + 14 + msgp.MapHeaderSize
	if z.LifeTimeOps != nil {
		for za0001, za0002 := range z.LifeTimeOps {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 12 + 1 + 11 + msgp.MapHeaderSize
	if z.LastMinute.Operations != nil {
		for za0003, za0004 := range z.LastMinute.Operations {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += 8 + z.IOStats.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ExpirationInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ExpirationInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "lastBucket"
	err = en.Append(0x86, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	// write "deleteMarkers"
	err = en.Append(0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkers)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkers")
		return
	}
	// write "deleteMarkersFailed"
	err = en.Append(0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkersFailed)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkersFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ExpirationInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "lastBucket"
	o = append(o, 0x86, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	// string "deleteMarkers"
	o = append(o, 0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	o = msgp.AppendInt64(o, z.DeleteMarkers)
	// string "deleteMarkersFailed"
	o = append(o, 0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.DeleteMarkersFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ExpirationInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ExpirationInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 20 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *JobMetric) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "jobID":
			z.JobID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "JobID")
				return
			}
		case "jobType":
			z.JobType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "JobType")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retryAttempts":
			z.RetryAttempts, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "complete":
			z.Complete, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Complete")
				return
			}
		case "failed":
			z.Failed, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Failed")
				return
			}
		case "replicate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
				z.Replicate = nil
			} else {
				if z.Replicate == nil {
					z.Replicate = new(ReplicateInfo)
				}
				err = z.Replicate.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
			zb0001Mask |= 0x1
		case "rotation":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
				z.KeyRotate = nil
			} else {
				if z.KeyRotate == nil {
					z.KeyRotate = new(KeyRotationInfo)
				}
				err = z.KeyRotate.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
			zb0001Mask |= 0x2
		case "expired":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
				z.Expired = nil
			} else {
				if z.Expired == nil {
					z.Expired = new(ExpirationInfo)
				}
				err = z.Expired.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
			zb0001Mask |= 0x4
		case "catalog":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
				z.Catalog = nil
			} else {
				if z.Catalog == nil {
					z.Catalog = new(CatalogInfo)
				}
				err = z.Catalog.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Replicate = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.KeyRotate = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Expired = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Catalog = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *JobMetric) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Replicate == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.KeyRotate == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Expired == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Catalog == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "jobID"
		err = en.Append(0xa5, 0x6a, 0x6f, 0x62, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.JobID)
		if err != nil {
			err = msgp.WrapError(err, "JobID")
			return
		}
		// write "jobType"
		err = en.Append(0xa7, 0x6a, 0x6f, 0x62, 0x54, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.JobType)
		if err != nil {
			err = msgp.WrapError(err, "JobType")
			return
		}
		// write "startTime"
		err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.StartTime)
		if err != nil {
			err = msgp.WrapError(err, "StartTime")
			return
		}
		// write "lastUpdate"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastUpdate)
		if err != nil {
			err = msgp.WrapError(err, "LastUpdate")
			return
		}
		// write "retryAttempts"
		err = en.Append(0xad, 0x72, 0x65, 0x74, 0x72, 0x79, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.RetryAttempts)
		if err != nil {
			err = msgp.WrapError(err, "RetryAttempts")
			return
		}
		// write "complete"
		err = en.Append(0xa8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Complete)
		if err != nil {
			err = msgp.WrapError(err, "Complete")
			return
		}
		// write "failed"
		err = en.Append(0xa6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Failed)
		if err != nil {
			err = msgp.WrapError(err, "Failed")
			return
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "replicate"
			err = en.Append(0xa9, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65)
			if err != nil {
				return
			}
			if z.Replicate == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Replicate.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "rotation"
			err = en.Append(0xa8, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if err != nil {
				return
			}
			if z.KeyRotate == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.KeyRotate.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "expired"
			err = en.Append(0xa7, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64)
			if err != nil {
				return
			}
			if z.Expired == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Expired.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "catalog"
			err = en.Append(0xa7, 0x63, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67)
			if err != nil {
				return
			}
			if z.Catalog == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Catalog.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *JobMetric) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Replicate == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.KeyRotate == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Expired == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Catalog == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "jobID"
		o = append(o, 0xa5, 0x6a, 0x6f, 0x62, 0x49, 0x44)
		o = msgp.AppendString(o, z.JobID)
		// string "jobType"
		o = append(o, 0xa7, 0x6a, 0x6f, 0x62, 0x54, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.JobType)
		// string "startTime"
		o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.StartTime)
		// string "lastUpdate"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		o = msgp.AppendTime(o, z.LastUpdate)
		// string "retryAttempts"
		o = append(o, 0xad, 0x72, 0x65, 0x74, 0x72, 0x79, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
		o = msgp.AppendInt(o, z.RetryAttempts)
		// string "complete"
		o = append(o, 0xa8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65)
		o = msgp.AppendBool(o, z.Complete)
		// string "failed"
		o = append(o, 0xa6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
		o = msgp.AppendBool(o, z.Failed)
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "replicate"
			o = append(o, 0xa9, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65)
			if z.Replicate == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Replicate.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "rotation"
			o = append(o, 0xa8, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if z.KeyRotate == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.KeyRotate.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "expired"
			o = append(o, 0xa7, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64)
			if z.Expired == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Expired.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "catalog"
			o = append(o, 0xa7, 0x63, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67)
			if z.Catalog == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Catalog.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *JobMetric) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "jobID":
			z.JobID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "JobID")
				return
			}
		case "jobType":
			z.JobType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "JobType")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retryAttempts":
			z.RetryAttempts, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "complete":
			z.Complete, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Complete")
				return
			}
		case "failed":
			z.Failed, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Failed")
				return
			}
		case "replicate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Replicate = nil
			} else {
				if z.Replicate == nil {
					z.Replicate = new(ReplicateInfo)
				}
				bts, err = z.Replicate.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
			zb0001Mask |= 0x1
		case "rotation":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.KeyRotate = nil
			} else {
				if z.KeyRotate == nil {
					z.KeyRotate = new(KeyRotationInfo)
				}
				bts, err = z.KeyRotate.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
			zb0001Mask |= 0x2
		case "expired":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Expired = nil
			} else {
				if z.Expired == nil {
					z.Expired = new(ExpirationInfo)
				}
				bts, err = z.Expired.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
			zb0001Mask |= 0x4
		case "catalog":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Catalog = nil
			} else {
				if z.Catalog == nil {
					z.Catalog = new(CatalogInfo)
				}
				bts, err = z.Catalog.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Replicate = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.KeyRotate = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Expired = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Catalog = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *JobMetric) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.JobID) + 8 + msgp.StringPrefixSize + len(z.JobType) + 10 + msgp.TimeSize + 11 + msgp.TimeSize + 14 + msgp.IntSize + 9 + msgp.BoolSize + 7 + msgp.BoolSize + 10
	if z.Replicate == nil {
		s += msgp.NilSize
	} else {
		s += z.Replicate.Msgsize()
	}
	s += 9
	if z.KeyRotate == nil {
		s += msgp.NilSize
	} else {
		s += z.KeyRotate.Msgsize()
	}
	s += 8
	if z.Expired == nil {
		s += msgp.NilSize
	} else {
		s += z.Expired.Msgsize()
	}
	s += 8
	if z.Catalog == nil {
		s += msgp.NilSize
	} else {
		s += z.Catalog.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *KeyRotationInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *KeyRotationInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "lastBucket"
	err = en.Append(0x84, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *KeyRotationInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "lastBucket"
	o = append(o, 0x84, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *KeyRotationInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *KeyRotationInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MemInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "NodeCommon":
			err = (*nodeCommon)(&z.NodeCommon).DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "NodeCommon")
				return
			}
		case "total":
			z.Total, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
			zb0001Mask |= 0x1
		case "used":
			z.Used, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
			zb0001Mask |= 0x2
		case "free":
			z.Free, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
			zb0001Mask |= 0x4
		case "available":
			z.Available, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
			zb0001Mask |= 0x8
		case "shared":
			z.Shared, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
			zb0001Mask |= 0x10
		case "cache":
			z.Cache, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
			zb0001Mask |= 0x20
		case "buffer":
			z.Buffers, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
			zb0001Mask |= 0x40
		case "swap_space_total":
			z.SwapSpaceTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
			zb0001Mask |= 0x80
		case "swap_space_free":
			z.SwapSpaceFree, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
			zb0001Mask |= 0x100
		case "limit":
			z.Limit, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
			zb0001Mask |= 0x200
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Total = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Used = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Free = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Available = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Shared = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Cache = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Buffers = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.SwapSpaceTotal = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.SwapSpaceFree = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Limit = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MemInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Total == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Used == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Free == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Available == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Shared == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Cache == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Buffers == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.SwapSpaceTotal == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.SwapSpaceFree == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Limit == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "NodeCommon"
		err = en.Append(0xaa, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = (*nodeCommon)(&z.NodeCommon).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "NodeCommon")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "total"
			err = en.Append(0xa5, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Total)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "used"
			err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Used)
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "free"
			err = en.Append(0xa4, 0x66, 0x72, 0x65, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Free)
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "available"
			err = en.Append(0xa9, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Available)
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "shared"
			err = en.Append(0xa6, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Shared)
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "cache"
			err = en.Append(0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Cache)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "buffer"
			err = en.Append(0xa6, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Buffers)
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "swap_space_total"
			err = en.Append(0xb0, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.SwapSpaceTotal)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "swap_space_free"
			err = en.Append(0xaf, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x66, 0x72, 0x65, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.SwapSpaceFree)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "limit"
			err = en.Append(0xa5, 0x6c, 0x69, 0x6d, 0x69, 0x74)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Limit)
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MemInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Total == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Used == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Free == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Available == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Shared == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Cache == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Buffers == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.SwapSpaceTotal == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.SwapSpaceFree == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Limit == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "NodeCommon"
		o = append(o, 0xaa, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e)
		o, err = (*nodeCommon)(&z.NodeCommon).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "NodeCommon")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "total"
			o = append(o, 0xa5, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			o = msgp.AppendUint64(o, z.Total)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "used"
			o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.Used)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "free"
			o = append(o, 0xa4, 0x66, 0x72, 0x65, 0x65)
			o = msgp.AppendUint64(o, z.Free)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "available"
			o = append(o, 0xa9, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
			o = msgp.AppendUint64(o, z.Available)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "shared"
			o = append(o, 0xa6, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.Shared)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "cache"
			o = append(o, 0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			o = msgp.AppendUint64(o, z.Cache)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "buffer"
			o = append(o, 0xa6, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72)
			o = msgp.AppendUint64(o, z.Buffers)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "swap_space_total"
			o = append(o, 0xb0, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			o = msgp.AppendUint64(o, z.SwapSpaceTotal)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "swap_space_free"
			o = append(o, 0xaf, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x66, 0x72, 0x65, 0x65)
			o = msgp.AppendUint64(o, z.SwapSpaceFree)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "limit"
			o = append(o, 0xa5, 0x6c, 0x69, 0x6d, 0x69, 0x74)
			o = msgp.AppendUint64(o, z.Limit)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MemInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "NodeCommon":
			bts, err = (*nodeCommon)(&z.NodeCommon).UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "NodeCommon")
				return
			}
		case "total":
			z.Total, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
			zb0001Mask |= 0x1
		case "used":
			z.Used, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
			zb0001Mask |= 0x2
		case "free":
			z.Free, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
			zb0001Mask |= 0x4
		case "available":
			z.Available, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
			zb0001Mask |= 0x8
		case "shared":
			z.Shared, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
			zb0001Mask |= 0x10
		case "cache":
			z.Cache, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
			zb0001Mask |= 0x20
		case "buffer":
			z.Buffers, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
			zb0001Mask |= 0x40
		case "swap_space_total":
			z.SwapSpaceTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
			zb0001Mask |= 0x80
		case "swap_space_free":
			z.SwapSpaceFree, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
			zb0001Mask |= 0x100
		case "limit":
			z.Limit, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
			zb0001Mask |= 0x200
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Total = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Used = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Free = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Available = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Shared = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Cache = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Buffers = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.SwapSpaceTotal = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.SwapSpaceFree = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Limit = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MemInfo) Msgsize() (s int) {
	s = 1 + 11 + (*nodeCommon)(&z.NodeCommon).Msgsize() + 6 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 10 + msgp.Uint64Size + 7 + msgp.Uint64Size + 6 + msgp.Uint64Size + 7 + msgp.Uint64Size + 17 + msgp.Uint64Size + 16 + msgp.Uint64Size + 6 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MemMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "memInfo":
			err = z.Info.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MemMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "collected"
	err = en.Append(0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "memInfo"
	err = en.Append(0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
	if err != nil {
		return
	}
	err = z.Info.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Info")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MemMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "collected"
	o = append(o, 0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "memInfo"
	o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
	o, err = z.Info.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Info")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MemMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "memInfo":
			bts, err = z.Info.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MemMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 8 + z.Info.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MetricType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint32
		zb0001, err = dc.ReadUint32()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MetricType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MetricType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint32(uint32(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MetricType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint32(o, uint32(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MetricType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint32
		zb0001, bts, err = msgp.ReadUint32Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MetricType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MetricType) Msgsize() (s int) {
	s = msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Metrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "scanner":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
				z.Scanner = nil
			} else {
				if z.Scanner == nil {
					z.Scanner = new(ScannerMetrics)
				}
				err = z.Scanner.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
			zb0001Mask |= 0x1
		case "disk":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
				z.Disk = nil
			} else {
				if z.Disk == nil {
					z.Disk = new(DiskMetric)
				}
				err = z.Disk.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
			zb0001Mask |= 0x2
		case "os":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
				z.OS = nil
			} else {
				if z.OS == nil {
					z.OS = new(OSMetrics)
				}
				err = z.OS.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
			zb0001Mask |= 0x4
		case "batchJobs":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
				z.BatchJobs = nil
			} else {
				if z.BatchJobs == nil {
					z.BatchJobs = new(BatchJobMetrics)
				}
				err = z.BatchJobs.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
			zb0001Mask |= 0x8
		case "siteResync":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
				z.SiteResync = nil
			} else {
				if z.SiteResync == nil {
					z.SiteResync = new(SiteResyncMetrics)
				}
				err = z.SiteResync.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
			zb0001Mask |= 0x10
		case "net":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
				z.Net = nil
			} else {
				if z.Net == nil {
					z.Net = new(NetMetrics)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Net")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Net.CollectedAt, err = dc.ReadTime()
						if err != nil {
							err = msgp.WrapError(err, "Net", "CollectedAt")
							return
						}
					case "interfaceName":
						z.Net.InterfaceName, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Net", "InterfaceName")
							return
						}
					case "netstats":
						err = (*procfsNetDevLine)(&z.Net.NetStats).DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Net", "NetStats")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Net")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x20
		case "mem":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				z.Mem = nil
			} else {
				if z.Mem == nil {
					z.Mem = new(MemMetrics)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Mem")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Mem.CollectedAt, err = dc.ReadTime()
						if err != nil {
							err = msgp.WrapError(err, "Mem", "CollectedAt")
							return
						}
					case "memInfo":
						err = z.Mem.Info.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "Info")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Mem")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x40
		case "cpu":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
				z.CPU = nil
			} else {
				if z.CPU == nil {
					z.CPU = new(CPUMetrics)
				}
				err = z.CPU.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
			zb0001Mask |= 0x80
		case "rpc":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
				z.RPC = nil
			} else {
				if z.RPC == nil {
					z.RPC = new(RPCMetrics)
				}
				err = z.RPC.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
			zb0001Mask |= 0x100
		case "go":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
				z.Go = nil
			} else {
				if z.Go == nil {
					z.Go = new(RuntimeMetrics)
				}
				err = z.Go.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
			zb0001Mask |= 0x200
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Scanner = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Disk = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.OS = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.BatchJobs = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.SiteResync = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Net = nil
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Mem = nil
		}
		if (zb0001Mask & 0x80) == 0 {
			z.CPU = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.RPC = nil
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Go = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Metrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	if z.Scanner == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Disk == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.OS == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.BatchJobs == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.SiteResync == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Net == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mem == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.CPU == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.RPC == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Go == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "scanner"
			err = en.Append(0xa7, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x72)
			if err != nil {
				return
			}
			if z.Scanner == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Scanner.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "disk"
			err = en.Append(0xa4, 0x64, 0x69, 0x73, 0x6b)
			if err != nil {
				return
			}
			if z.Disk == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Disk.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "os"
			err = en.Append(0xa2, 0x6f, 0x73)
			if err != nil {
				return
			}
			if z.OS == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.OS.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "batchJobs"
			err = en.Append(0xa9, 0x62, 0x61, 0x74, 0x63, 0x68, 0x4a, 0x6f, 0x62, 0x73)
			if err != nil {
				return
			}
			if z.BatchJobs == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.BatchJobs.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "siteResync"
			err = en.Append(0xaa, 0x73, 0x69, 0x74, 0x65, 0x52, 0x65, 0x73, 0x79, 0x6e, 0x63)
			if err != nil {
				return
			}
			if z.SiteResync == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.SiteResync.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "net"
			err = en.Append(0xa3, 0x6e, 0x65, 0x74)
			if err != nil {
				return
			}
			if z.Net == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				// map header, size 3
				// write "collected"
				err = en.Append(0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				if err != nil {
					return
				}
				err = en.WriteTime(z.Net.CollectedAt)
				if err != nil {
					err = msgp.WrapError(err, "Net", "CollectedAt")
					return
				}
				// write "interfaceName"
				err = en.Append(0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
				if err != nil {
					return
				}
				err = en.WriteString(z.Net.InterfaceName)
				if err != nil {
					err = msgp.WrapError(err, "Net", "InterfaceName")
					return
				}
				// write "netstats"
				err = en.Append(0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
				if err != nil {
					return
				}
				err = (*procfsNetDevLine)(&z.Net.NetStats).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Net", "NetStats")
					return
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "mem"
			err = en.Append(0xa3, 0x6d, 0x65, 0x6d)
			if err != nil {
				return
			}
			if z.Mem == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				// map header, size 2
				// write "collected"
				err = en.Append(0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				if err != nil {
					return
				}
				err = en.WriteTime(z.Mem.CollectedAt)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "CollectedAt")
					return
				}
				// write "memInfo"
				err = en.Append(0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
				if err != nil {
					return
				}
				err = z.Mem.Info.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "Info")
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "cpu"
			err = en.Append(0xa3, 0x63, 0x70, 0x75)
			if err != nil {
				return
			}
			if z.CPU == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.CPU.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "rpc"
			err = en.Append(0xa3, 0x72, 0x70, 0x63)
			if err != nil {
				return
			}
			if z.RPC == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.RPC.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "go"
			err = en.Append(0xa2, 0x67, 0x6f)
			if err != nil {
				return
			}
			if z.Go == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Go.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Metrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	if z.Scanner == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Disk == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.OS == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.BatchJobs == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.SiteResync == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Net == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mem == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.CPU == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.RPC == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Go == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "scanner"
			o = append(o, 0xa7, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x72)
			if z.Scanner == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Scanner.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "disk"
			o = append(o, 0xa4, 0x64, 0x69, 0x73, 0x6b)
			if z.Disk == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Disk.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "os"
			o = append(o, 0xa2, 0x6f, 0x73)
			if z.OS == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.OS.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "batchJobs"
			o = append(o, 0xa9, 0x62, 0x61, 0x74, 0x63, 0x68, 0x4a, 0x6f, 0x62, 0x73)
			if z.BatchJobs == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.BatchJobs.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "siteResync"
			o = append(o, 0xaa, 0x73, 0x69, 0x74, 0x65, 0x52, 0x65, 0x73, 0x79, 0x6e, 0x63)
			if z.SiteResync == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.SiteResync.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "net"
			o = append(o, 0xa3, 0x6e, 0x65, 0x74)
			if z.Net == nil {
				o = msgp.AppendNil(o)
			} else {
				// map header, size 3
				// string "collected"
				o = append(o, 0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				o = msgp.AppendTime(o, z.Net.CollectedAt)
				// string "interfaceName"
				o = append(o, 0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
				o = msgp.AppendString(o, z.Net.InterfaceName)
				// string "netstats"
				o = append(o, 0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
				o, err = (*procfsNetDevLine)(&z.Net.NetStats).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Net", "NetStats")
					return
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "mem"
			o = append(o, 0xa3, 0x6d, 0x65, 0x6d)
			if z.Mem == nil {
				o = msgp.AppendNil(o)
			} else {
				// map header, size 2
				// string "collected"
				o = append(o, 0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				o = msgp.AppendTime(o, z.Mem.CollectedAt)
				// string "memInfo"
				o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
				o, err = z.Mem.Info.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "Info")
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "cpu"
			o = append(o, 0xa3, 0x63, 0x70, 0x75)
			if z.CPU == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.CPU.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "rpc"
			o = append(o, 0xa3, 0x72, 0x70, 0x63)
			if z.RPC == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.RPC.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "go"
			o = append(o, 0xa2, 0x67, 0x6f)
			if z.Go == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Go.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Metrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "scanner":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Scanner = nil
			} else {
				if z.Scanner == nil {
					z.Scanner = new(ScannerMetrics)
				}
				bts, err = z.Scanner.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
			zb0001Mask |= 0x1
		case "disk":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Disk = nil
			} else {
				if z.Disk == nil {
					z.Disk = new(DiskMetric)
				}
				bts, err = z.Disk.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
			zb0001Mask |= 0x2
		case "os":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OS = nil
			} else {
				if z.OS == nil {
					z.OS = new(OSMetrics)
				}
				bts, err = z.OS.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
			zb0001Mask |= 0x4
		case "batchJobs":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BatchJobs = nil
			} else {
				if z.BatchJobs == nil {
					z.BatchJobs = new(BatchJobMetrics)
				}
				bts, err = z.BatchJobs.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
			zb0001Mask |= 0x8
		case "siteResync":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SiteResync = nil
			} else {
				if z.SiteResync == nil {
					z.SiteResync = new(SiteResyncMetrics)
				}
				bts, err = z.SiteResync.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
			zb0001Mask |= 0x10
		case "net":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Net = nil
			} else {
				if z.Net == nil {
					z.Net = new(NetMetrics)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Net")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Net.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Net", "CollectedAt")
							return
						}
					case "interfaceName":
						z.Net.InterfaceName, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Net", "InterfaceName")
							return
						}
					case "netstats":
						bts, err = (*procfsNetDevLine)(&z.Net.NetStats).UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Net", "NetStats")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Net")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x20
		case "mem":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Mem = nil
			} else {
				if z.Mem == nil {
					z.Mem = new(MemMetrics)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Mem")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Mem.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "CollectedAt")
							return
						}
					case "memInfo":
						bts, err = z.Mem.Info.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "Info")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x40
		case "cpu":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CPU = nil
			} else {
				if z.CPU == nil {
					z.CPU = new(CPUMetrics)
				}
				bts, err = z.CPU.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
			zb0001Mask |= 0x80
		case "rpc":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RPC = nil
			} else {
				if z.RPC == nil {
					z.RPC = new(RPCMetrics)
				}
				bts, err = z.RPC.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
			zb0001Mask |= 0x100
		case "go":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Go = nil
			} else {
				if z.Go == nil {
					z.Go = new(RuntimeMetrics)
				}
				bts, err = z.Go.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
			zb0001Mask |= 0x200
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Scanner = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Disk = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.OS = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.BatchJobs = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.SiteResync = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Net = nil
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Mem = nil
		}
		if (zb0001Mask & 0x80) == 0 {
			z.CPU = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.RPC = nil
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Go = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Metrics) Msgsize() (s int) {
	s = 1 + 8
	if z.Scanner == nil {
		s += msgp.NilSize
	} else {
		s += z.Scanner.Msgsize()
	}
	s += 5
	if z.Disk == nil {
		s += msgp.NilSize
	} else {
		s += z.Disk.Msgsize()
	}
	s += 3
	if z.OS == nil {
		s += msgp.NilSize
	} else {
		s += z.OS.Msgsize()
	}
	s += 10
	if z.BatchJobs == nil {
		s += msgp.NilSize
	} else {
		s += z.BatchJobs.Msgsize()
	}
	s += 11
	if z.SiteResync == nil {
		s += msgp.NilSize
	} else {
		s += z.SiteResync.Msgsize()
	}
	s += 4
	if z.Net == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.TimeSize + 14 + msgp.StringPrefixSize + len(z.Net.InterfaceName) + 9 + (*procfsNetDevLine)(&z.Net.NetStats).Msgsize()
	}
	s += 4
	if z.Mem == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.TimeSize + 8 + z.Mem.Info.Msgsize()
	}
	s += 4
	if z.CPU == nil {
		s += msgp.NilSize
	} else {
		s += z.CPU.Msgsize()
	}
	s += 4
	if z.RPC == nil {
		s += msgp.NilSize
	} else {
		s += z.RPC.Msgsize()
	}
	s += 3
	if z.Go == nil {
		s += msgp.NilSize
	} else {
		s += z.Go.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MetricsOptions) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			{
				var zb0002 uint32
				zb0002, err = dc.ReadUint32()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = MetricType(zb0002)
			}
		case "N":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "Interval":
			z.Interval, err = dc.ReadDuration()
			if err != nil {
				err = msgp.WrapError(err, "Interval")
				return
			}
		case "Hosts":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0003) {
				z.Hosts = (z.Hosts)[:zb0003]
			} else {
				z.Hosts = make([]string, zb0003)
			}
			for za0001 := range z.Hosts {
				z.Hosts[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0001)
					return
				}
			}
		case "ByHost":
			z.ByHost, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
		case "Disks":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0004) {
				z.Disks = (z.Disks)[:zb0004]
			} else {
				z.Disks = make([]string, zb0004)
			}
			for za0002 := range z.Disks {
				z.Disks[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0002)
					return
				}
			}
		case "ByDisk":
			z.ByDisk, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
		case "ByJobID":
			z.ByJobID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ByJobID")
				return
			}
		case "ByDepID":
			z.ByDepID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ByDepID")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MetricsOptions) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "Type"
	err = en.Append(0x89, 0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(uint32(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "N"
	err = en.Append(0xa1, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.N)
	if err != nil {
		err = msgp.WrapError(err, "N")
		return
	}
	// write "Interval"
	err = en.Append(0xa8, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteDuration(z.Interval)
	if err != nil {
		err = msgp.WrapError(err, "Interval")
		return
	}
	// write "Hosts"
	err = en.Append(0xa5, 0x48, 0x6f, 0x73, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Hosts)))
	if err != nil {
		err = msgp.WrapError(err, "Hosts")
		return
	}
	for za0001 := range z.Hosts {
		err = en.WriteString(z.Hosts[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Hosts", za0001)
			return
		}
	}
	// write "ByHost"
	err = en.Append(0xa6, 0x42, 0x79, 0x48, 0x6f, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ByHost)
	if err != nil {
		err = msgp.WrapError(err, "ByHost")
		return
	}
	// write "Disks"
	err = en.Append(0xa5, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Disks)))
	if err != nil {
		err = msgp.WrapError(err, "Disks")
		return
	}
	for za0002 := range z.Disks {
		err = en.WriteString(z.Disks[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0002)
			return
		}
	}
	// write "ByDisk"
	err = en.Append(0xa6, 0x42, 0x79, 0x44, 0x69, 0x73, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ByDisk)
	if err != nil {
		err = msgp.WrapError(err, "ByDisk")
		return
	}
	// write "ByJobID"
	err = en.Append(0xa7, 0x42, 0x79, 0x4a, 0x6f, 0x62, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ByJobID)
	if err != nil {
		err = msgp.WrapError(err, "ByJobID")
		return
	}
	// write "ByDepID"
	err = en.Append(0xa7, 0x42, 0x79, 0x44, 0x65, 0x70, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ByDepID)
	if err != nil {
		err = msgp.WrapError(err, "ByDepID")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MetricsOptions) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "Type"
	o = append(o, 0x89, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendUint32(o, uint32(z.Type))
	// string "N"
	o = append(o, 0xa1, 0x4e)
	o = msgp.AppendInt(o, z.N)
	// string "Interval"
	o = append(o, 0xa8, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	o = msgp.AppendDuration(o, z.Interval)
	// string "Hosts"
	o = append(o, 0xa5, 0x48, 0x6f, 0x73, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Hosts)))
	for za0001 := range z.Hosts {
		o = msgp.AppendString(o, z.Hosts[za0001])
	}
	// string "ByHost"
	o = append(o, 0xa6, 0x42, 0x79, 0x48, 0x6f, 0x73, 0x74)
	o = msgp.AppendBool(o, z.ByHost)
	// string "Disks"
	o = append(o, 0xa5, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Disks)))
	for za0002 := range z.Disks {
		o = msgp.AppendString(o, z.Disks[za0002])
	}
	// string "ByDisk"
	o = append(o, 0xa6, 0x42, 0x79, 0x44, 0x69, 0x73, 0x6b)
	o = msgp.AppendBool(o, z.ByDisk)
	// string "ByJobID"
	o = append(o, 0xa7, 0x42, 0x79, 0x4a, 0x6f, 0x62, 0x49, 0x44)
	o = msgp.AppendString(o, z.ByJobID)
	// string "ByDepID"
	o = append(o, 0xa7, 0x42, 0x79, 0x44, 0x65, 0x70, 0x49, 0x44)
	o = msgp.AppendString(o, z.ByDepID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MetricsOptions) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			{
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = MetricType(zb0002)
			}
		case "N":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "Interval":
			z.Interval, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Interval")
				return
			}
		case "Hosts":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0003) {
				z.Hosts = (z.Hosts)[:zb0003]
			} else {
				z.Hosts = make([]string, zb0003)
			}
			for za0001 := range z.Hosts {
				z.Hosts[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0001)
					return
				}
			}
		case "ByHost":
			z.ByHost, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
		case "Disks":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0004) {
				z.Disks = (z.Disks)[:zb0004]
			} else {
				z.Disks = make([]string, zb0004)
			}
			for za0002 := range z.Disks {
				z.Disks[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0002)
					return
				}
			}
		case "ByDisk":
			z.ByDisk, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
		case "ByJobID":
			z.ByJobID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByJobID")
				return
			}
		case "ByDepID":
			z.ByDepID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDepID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MetricsOptions) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint32Size + 2 + msgp.IntSize + 9 + msgp.DurationSize + 6 + msgp.ArrayHeaderSize
	for za0001 := range z.Hosts {
		s += msgp.StringPrefixSize + len(z.Hosts[za0001])
	}
	s += 7 + msgp.BoolSize + 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Disks {
		s += msgp.StringPrefixSize + len(z.Disks[za0002])
	}
	s += 7 + msgp.BoolSize + 8 + msgp.StringPrefixSize + len(z.ByJobID) + 8 + msgp.StringPrefixSize + len(z.ByDepID)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NetMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "interfaceName":
			z.InterfaceName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InterfaceName")
				return
			}
		case "netstats":
			err = (*procfsNetDevLine)(&z.NetStats).DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "NetStats")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *NetMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "collected"
	err = en.Append(0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "interfaceName"
	err = en.Append(0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.InterfaceName)
	if err != nil {
		err = msgp.WrapError(err, "InterfaceName")
		return
	}
	// write "netstats"
	err = en.Append(0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = (*procfsNetDevLine)(&z.NetStats).EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "NetStats")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *NetMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "collected"
	o = append(o, 0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "interfaceName"
	o = append(o, 0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.InterfaceName)
	// string "netstats"
	o = append(o, 0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
	o, err = (*procfsNetDevLine)(&z.NetStats).MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "NetStats")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NetMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "interfaceName":
			z.InterfaceName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InterfaceName")
				return
			}
		case "netstats":
			bts, err = (*procfsNetDevLine)(&z.NetStats).UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetStats")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NetMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 14 + msgp.StringPrefixSize + len(z.InterfaceName) + 9 + (*procfsNetDevLine)(&z.NetStats).Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OSMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "life_time_ops":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 uint64
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "last_minute":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						for key := range z.LastMinute.Operations {
							delete(z.LastMinute.Operations, key)
						}
					}
					for zb0004 > 0 {
						zb0004--
						var za0003 string
						var za0004 TimedAction
						za0003, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						err = za0004.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.LifeTimeOps = nil
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *OSMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "life_time_ops"
			err = en.Append(0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			for za0001, za0002 := range z.LifeTimeOps {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				err = en.WriteUint64(za0002)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
			}
		}
		// write "last_minute"
		err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// write "operations"
			err = en.Append(0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinute.Operations)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinute", "Operations")
				return
			}
			for za0003, za0004 := range z.LastMinute.Operations {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OSMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "life_time_ops"
			o = append(o, 0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeOps)))
			for za0001, za0002 := range z.LifeTimeOps {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendUint64(o, za0002)
			}
		}
		// string "last_minute"
		o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// string "operations"
			o = append(o, 0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.Operations)))
			for za0003, za0004 := range z.LastMinute.Operations {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OSMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "life_time_ops":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 uint64
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "last_minute":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						for key := range z.LastMinute.Operations {
							delete(z.LastMinute.Operations, key)
						}
					}
					for zb0004 > 0 {
						var za0003 string
						var za0004 TimedAction
						zb0004--
						za0003, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						bts, err = za0004.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.LifeTimeOps = nil
	}

	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OSMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 14 + msgp.MapHeaderSize
	if z.LifeTimeOps != nil {
		for za0001, za0002 := range z.LifeTimeOps {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 12 + 1 + 11 + msgp.MapHeaderSize
	if z.LastMinute.Operations != nil {
		for za0003, za0004 := range z.LastMinute.Operations {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RPCMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collectedAt":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "connected":
			z.Connected, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
		case "reconnectCount":
			z.ReconnectCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
		case "disconnected":
			z.Disconnected, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
		case "outgoingStreams":
			z.OutgoingStreams, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
		case "incomingStreams":
			z.IncomingStreams, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
		case "outgoingBytes":
			z.OutgoingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		case "incomingBytes":
			z.IncomingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		case "outgoingMessages":
			z.OutgoingMessages, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
		case "incomingMessages":
			z.IncomingMessages, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
		case "outQueue":
			z.OutQueue, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
		case "lastPongTime":
			z.LastPongTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
		case "lastPingMS":
			z.LastPingMS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
		case "maxPingDurMS":
			z.MaxPingDurMS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
		case "lastConnectTime":
			z.LastConnectTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
		case "byDestination":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			if z.ByDestination == nil {
				z.ByDestination = make(map[string]RPCMetrics, zb0002)
			} else if len(z.ByDestination) > 0 {
				for key := range z.ByDestination {
					delete(z.ByDestination, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 RPCMetrics
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0001)
					return
				}
				z.ByDestination[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "byCaller":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			if z.ByCaller == nil {
				z.ByCaller = make(map[string]RPCMetrics, zb0003)
			} else if len(z.ByCaller) > 0 {
				for key := range z.ByCaller {
					delete(z.ByCaller, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 RPCMetrics
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				err = za0004.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0003)
					return
				}
				z.ByCaller[za0003] = za0004
			}
			zb0001Mask |= 0x2
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.ByDestination = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByCaller = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RPCMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.ByDestination == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.ByCaller == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collectedAt"
		err = en.Append(0xab, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x41, 0x74)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "connected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Connected)
		if err != nil {
			err = msgp.WrapError(err, "Connected")
			return
		}
		// write "reconnectCount"
		err = en.Append(0xae, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.ReconnectCount)
		if err != nil {
			err = msgp.WrapError(err, "ReconnectCount")
			return
		}
		// write "disconnected"
		err = en.Append(0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Disconnected)
		if err != nil {
			err = msgp.WrapError(err, "Disconnected")
			return
		}
		// write "outgoingStreams"
		err = en.Append(0xaf, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.OutgoingStreams)
		if err != nil {
			err = msgp.WrapError(err, "OutgoingStreams")
			return
		}
		// write "incomingStreams"
		err = en.Append(0xaf, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.IncomingStreams)
		if err != nil {
			err = msgp.WrapError(err, "IncomingStreams")
			return
		}
		// write "outgoingBytes"
		err = en.Append(0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.OutgoingBytes)
		if err != nil {
			err = msgp.WrapError(err, "OutgoingBytes")
			return
		}
		// write "incomingBytes"
		err = en.Append(0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.IncomingBytes)
		if err != nil {
			err = msgp.WrapError(err, "IncomingBytes")
			return
		}
		// write "outgoingMessages"
		err = en.Append(0xb0, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.OutgoingMessages)
		if err != nil {
			err = msgp.WrapError(err, "OutgoingMessages")
			return
		}
		// write "incomingMessages"
		err = en.Append(0xb0, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.IncomingMessages)
		if err != nil {
			err = msgp.WrapError(err, "IncomingMessages")
			return
		}
		// write "outQueue"
		err = en.Append(0xa8, 0x6f, 0x75, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt(z.OutQueue)
		if err != nil {
			err = msgp.WrapError(err, "OutQueue")
			return
		}
		// write "lastPongTime"
		err = en.Append(0xac, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x6f, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastPongTime)
		if err != nil {
			err = msgp.WrapError(err, "LastPongTime")
			return
		}
		// write "lastPingMS"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x4d, 0x53)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.LastPingMS)
		if err != nil {
			err = msgp.WrapError(err, "LastPingMS")
			return
		}
		// write "maxPingDurMS"
		err = en.Append(0xac, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x6e, 0x67, 0x44, 0x75, 0x72, 0x4d, 0x53)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.MaxPingDurMS)
		if err != nil {
			err = msgp.WrapError(err, "MaxPingDurMS")
			return
		}
		// write "lastConnectTime"
		err = en.Append(0xaf, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastConnectTime)
		if err != nil {
			err = msgp.WrapError(err, "LastConnectTime")
			return
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "byDestination"
			err = en.Append(0xad, 0x62, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByDestination)))
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			for za0001, za0002 := range z.ByDestination {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				err = za0002.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "byCaller"
			err = en.Append(0xa8, 0x62, 0x79, 0x43, 0x61, 0x6c, 0x6c, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByCaller)))
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			for za0003, za0004 := range z.ByCaller {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0003)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RPCMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.ByDestination == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.ByCaller == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collectedAt"
		o = append(o, 0xab, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x41, 0x74)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "connected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendInt(o, z.Connected)
		// string "reconnectCount"
		o = append(o, 0xae, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt(o, z.ReconnectCount)
		// string "disconnected"
		o = append(o, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendInt(o, z.Disconnected)
		// string "outgoingStreams"
		o = append(o, 0xaf, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
		o = msgp.AppendInt(o, z.OutgoingStreams)
		// string "incomingStreams"
		o = append(o, 0xaf, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
		o = msgp.AppendInt(o, z.IncomingStreams)
		// string "outgoingBytes"
		o = append(o, 0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
		o = msgp.AppendInt64(o, z.OutgoingBytes)
		// string "incomingBytes"
		o = append(o, 0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
		o = msgp.AppendInt64(o, z.IncomingBytes)
		// string "outgoingMessages"
		o = append(o, 0xb0, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
		o = msgp.AppendInt64(o, z.OutgoingMessages)
		// string "incomingMessages"
		o = append(o, 0xb0, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
		o = msgp.AppendInt64(o, z.IncomingMessages)
		// string "outQueue"
		o = append(o, 0xa8, 0x6f, 0x75, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65)
		o = msgp.AppendInt(o, z.OutQueue)
		// string "lastPongTime"
		o = append(o, 0xac, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x6f, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.LastPongTime)
		// string "lastPingMS"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x4d, 0x53)
		o = msgp.AppendFloat64(o, z.LastPingMS)
		// string "maxPingDurMS"
		o = append(o, 0xac, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x6e, 0x67, 0x44, 0x75, 0x72, 0x4d, 0x53)
		o = msgp.AppendFloat64(o, z.MaxPingDurMS)
		// string "lastConnectTime"
		o = append(o, 0xaf, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.LastConnectTime)
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "byDestination"
			o = append(o, 0xad, 0x62, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByDestination)))
			for za0001, za0002 := range z.ByDestination {
				o = msgp.AppendString(o, za0001)
				o, err = za0002.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "byCaller"
			o = append(o, 0xa8, 0x62, 0x79, 0x43, 0x61, 0x6c, 0x6c, 0x65, 0x72)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByCaller)))
			for za0003, za0004 := range z.ByCaller {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0003)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RPCMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collectedAt":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "connected":
			z.Connected, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
		case "reconnectCount":
			z.ReconnectCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
		case "disconnected":
			z.Disconnected, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
		case "outgoingStreams":
			z.OutgoingStreams, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
		case "incomingStreams":
			z.IncomingStreams, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
		case "outgoingBytes":
			z.OutgoingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		case "incomingBytes":
			z.IncomingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		case "outgoingMessages":
			z.OutgoingMessages, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
		case "incomingMessages":
			z.IncomingMessages, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
		case "outQueue":
			z.OutQueue, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
		case "lastPongTime":
			z.LastPongTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
		case "lastPingMS":
			z.LastPingMS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
		case "maxPingDurMS":
			z.MaxPingDurMS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
		case "lastConnectTime":
			z.LastConnectTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
		case "byDestination":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			if z.ByDestination == nil {
				z.ByDestination = make(map[string]RPCMetrics, zb0002)
			} else if len(z.ByDestination) > 0 {
				for key := range z.ByDestination {
					delete(z.ByDestination, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 RPCMetrics
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0001)
					return
				}
				z.ByDestination[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "byCaller":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			if z.ByCaller == nil {
				z.ByCaller = make(map[string]RPCMetrics, zb0003)
			} else if len(z.ByCaller) > 0 {
				for key := range z.ByCaller {
					delete(z.ByCaller, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 RPCMetrics
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				bts, err = za0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0003)
					return
				}
				z.ByCaller[za0003] = za0004
			}
			zb0001Mask |= 0x2
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.ByDestination = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByCaller = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RPCMetrics) Msgsize() (s int) {
	s = 3 + 12 + msgp.TimeSize + 10 + msgp.IntSize + 15 + msgp.IntSize + 13 + msgp.IntSize + 16 + msgp.IntSize + 16 + msgp.IntSize + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 17 + msgp.Int64Size + 17 + msgp.Int64Size + 9 + msgp.IntSize + 13 + msgp.TimeSize + 11 + msgp.Float64Size + 13 + msgp.Float64Size + 16 + msgp.TimeSize + 14 + msgp.MapHeaderSize
	if z.ByDestination != nil {
		for za0001, za0002 := range z.ByDestination {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += 9 + msgp.MapHeaderSize
	if z.ByCaller != nil {
		for za0003, za0004 := range z.ByCaller {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RealtimeMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "errors":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0002) {
				z.Errors = (z.Errors)[:zb0002]
			} else {
				z.Errors = make([]string, zb0002)
			}
			for za0001 := range z.Errors {
				z.Errors[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "hosts":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0003) {
				z.Hosts = (z.Hosts)[:zb0003]
			} else {
				z.Hosts = make([]string, zb0003)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "aggregated":
			err = z.Aggregated.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Aggregated")
				return
			}
		case "by_host":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			if z.ByHost == nil {
				z.ByHost = make(map[string]Metrics, zb0004)
			} else if len(z.ByHost) > 0 {
				for key := range z.ByHost {
					delete(z.ByHost, key)
				}
			}
			for zb0004 > 0 {
				zb0004--
				var za0003 string
				var za0004 Metrics
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				err = za0004.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
				z.ByHost[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "by_disk":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			if z.ByDisk == nil {
				z.ByDisk = make(map[string]DiskMetric, zb0005)
			} else if len(z.ByDisk) > 0 {
				for key := range z.ByDisk {
					delete(z.ByDisk, key)
				}
			}
			for zb0005 > 0 {
				zb0005--
				var za0005 string
				var za0006 DiskMetric
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				err = za0006.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
				z.ByDisk[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "final":
			z.Final, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Final")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.Errors = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByHost = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ByDisk = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RealtimeMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	if z.Errors == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ByHost == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ByDisk == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "errors"
			err = en.Append(0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Errors)))
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			for za0001 := range z.Errors {
				err = en.WriteString(z.Errors[za0001])
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
		}
		// write "hosts"
		err = en.Append(0xa5, 0x68, 0x6f, 0x73, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Hosts)))
		if err != nil {
			err = msgp.WrapError(err, "Hosts")
			return
		}
		for za0002 := range z.Hosts {
			err = en.WriteString(z.Hosts[za0002])
			if err != nil {
				err = msgp.WrapError(err, "Hosts", za0002)
				return
			}
		}
		// write "aggregated"
		err = en.Append(0xaa, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = z.Aggregated.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Aggregated")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "by_host"
			err = en.Append(0xa7, 0x62, 0x79, 0x5f, 0x68, 0x6f, 0x73, 0x74)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByHost)))
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			for za0003, za0004 := range z.ByHost {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "by_disk"
			err = en.Append(0xa7, 0x62, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByDisk)))
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			for za0005, za0006 := range z.ByDisk {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				err = za0006.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
			}
		}
		// write "final"
		err = en.Append(0xa5, 0x66, 0x69, 0x6e, 0x61, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Final)
		if err != nil {
			err = msgp.WrapError(err, "Final")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RealtimeMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(6)
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	if z.Errors == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ByHost == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ByDisk == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "errors"
			o = append(o, 0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Errors)))
			for za0001 := range z.Errors {
				o = msgp.AppendString(o, z.Errors[za0001])
			}
		}
		// string "hosts"
		o = append(o, 0xa5, 0x68, 0x6f, 0x73, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Hosts)))
		for za0002 := range z.Hosts {
			o = msgp.AppendString(o, z.Hosts[za0002])
		}
		// string "aggregated"
		o = append(o, 0xaa, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64)
		o, err = z.Aggregated.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Aggregated")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "by_host"
			o = append(o, 0xa7, 0x62, 0x79, 0x5f, 0x68, 0x6f, 0x73, 0x74)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByHost)))
			for za0003, za0004 := range z.ByHost {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "by_disk"
			o = append(o, 0xa7, 0x62, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByDisk)))
			for za0005, za0006 := range z.ByDisk {
				o = msgp.AppendString(o, za0005)
				o, err = za0006.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
			}
		}
		// string "final"
		o = append(o, 0xa5, 0x66, 0x69, 0x6e, 0x61, 0x6c)
		o = msgp.AppendBool(o, z.Final)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RealtimeMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "errors":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0002) {
				z.Errors = (z.Errors)[:zb0002]
			} else {
				z.Errors = make([]string, zb0002)
			}
			for za0001 := range z.Errors {
				z.Errors[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "hosts":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0003) {
				z.Hosts = (z.Hosts)[:zb0003]
			} else {
				z.Hosts = make([]string, zb0003)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "aggregated":
			bts, err = z.Aggregated.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Aggregated")
				return
			}
		case "by_host":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			if z.ByHost == nil {
				z.ByHost = make(map[string]Metrics, zb0004)
			} else if len(z.ByHost) > 0 {
				for key := range z.ByHost {
					delete(z.ByHost, key)
				}
			}
			for zb0004 > 0 {
				var za0003 string
				var za0004 Metrics
				zb0004--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				bts, err = za0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
				z.ByHost[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "by_disk":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			if z.ByDisk == nil {
				z.ByDisk = make(map[string]DiskMetric, zb0005)
			} else if len(z.ByDisk) > 0 {
				for key := range z.ByDisk {
					delete(z.ByDisk, key)
				}
			}
			for zb0005 > 0 {
				var za0005 string
				var za0006 DiskMetric
				zb0005--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				bts, err = za0006.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
				z.ByDisk[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "final":
			z.Final, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Final")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.Errors = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByHost = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ByDisk = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RealtimeMetrics) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Errors {
		s += msgp.StringPrefixSize + len(z.Errors[za0001])
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Hosts {
		s += msgp.StringPrefixSize + len(z.Hosts[za0002])
	}
	s += 11 + z.Aggregated.Msgsize() + 8 + msgp.MapHeaderSize
	if z.ByHost != nil {
		for za0003, za0004 := range z.ByHost {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.ByDisk != nil {
		for za0005, za0006 := range z.ByDisk {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + za0006.Msgsize()
		}
	}
	s += 6 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReplicateInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		case "bytesTransferred":
			z.BytesTransferred, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BytesTransferred")
				return
			}
		case "bytesFailed":
			z.BytesFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReplicateInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "lastBucket"
	err = en.Append(0x88, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	// write "deleteMarkers"
	err = en.Append(0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkers)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkers")
		return
	}
	// write "deleteMarkersFailed"
	err = en.Append(0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkersFailed)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkersFailed")
		return
	}
	// write "bytesTransferred"
	err = en.Append(0xb0, 0x62, 0x79, 0x74, 0x65, 0x73, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BytesTransferred)
	if err != nil {
		err = msgp.WrapError(err, "BytesTransferred")
		return
	}
	// write "bytesFailed"
	err = en.Append(0xab, 0x62, 0x79, 0x74, 0x65, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BytesFailed)
	if err != nil {
		err = msgp.WrapError(err, "BytesFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReplicateInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "lastBucket"
	o = append(o, 0x88, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	// string "deleteMarkers"
	o = append(o, 0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	o = msgp.AppendInt64(o, z.DeleteMarkers)
	// string "deleteMarkersFailed"
	o = append(o, 0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.DeleteMarkersFailed)
	// string "bytesTransferred"
	o = append(o, 0xb0, 0x62, 0x79, 0x74, 0x65, 0x73, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.BytesTransferred)
	// string "bytesFailed"
	o = append(o, 0xab, 0x62, 0x79, 0x74, 0x65, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.BytesFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReplicateInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		case "bytesTransferred":
			z.BytesTransferred, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesTransferred")
				return
			}
		case "bytesFailed":
			z.BytesFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReplicateInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 20 + msgp.Int64Size + 17 + msgp.Int64Size + 12 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RuntimeMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uintMetrics":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			if z.UintMetrics == nil {
				z.UintMetrics = make(map[string]uint64, zb0002)
			} else if len(z.UintMetrics) > 0 {
				for key := range z.UintMetrics {
					delete(z.UintMetrics, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 uint64
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
				z.UintMetrics[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "floatMetrics":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			if z.FloatMetrics == nil {
				z.FloatMetrics = make(map[string]float64, zb0003)
			} else if len(z.FloatMetrics) > 0 {
				for key := range z.FloatMetrics {
					delete(z.FloatMetrics, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 float64
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				za0004, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
				z.FloatMetrics[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "histMetrics":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			if z.HistMetrics == nil {
				z.HistMetrics = make(map[string]metrics.Float64Histogram, zb0004)
			} else if len(z.HistMetrics) > 0 {
				for key := range z.HistMetrics {
					delete(z.HistMetrics, key)
				}
			}
			for zb0004 > 0 {
				zb0004--
				var za0005 string
				var za0006 metrics.Float64Histogram
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				err = (*localF64H)(&za0006).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
				z.HistMetrics[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "n":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.UintMetrics = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.FloatMetrics = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.HistMetrics = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RuntimeMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.UintMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.FloatMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.HistMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "uintMetrics"
			err = en.Append(0xab, 0x75, 0x69, 0x6e, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.UintMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			for za0001, za0002 := range z.UintMetrics {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				err = en.WriteUint64(za0002)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "floatMetrics"
			err = en.Append(0xac, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.FloatMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			for za0003, za0004 := range z.FloatMetrics {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				err = en.WriteFloat64(za0004)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "histMetrics"
			err = en.Append(0xab, 0x68, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.HistMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			for za0005, za0006 := range z.HistMetrics {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				err = (*localF64H)(&za0006).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
			}
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteInt(z.N)
		if err != nil {
			err = msgp.WrapError(err, "N")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RuntimeMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.UintMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.FloatMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.HistMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "uintMetrics"
			o = append(o, 0xab, 0x75, 0x69, 0x6e, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.UintMetrics)))
			for za0001, za0002 := range z.UintMetrics {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendUint64(o, za0002)
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "floatMetrics"
			o = append(o, 0xac, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.FloatMetrics)))
			for za0003, za0004 := range z.FloatMetrics {
				o = msgp.AppendString(o, za0003)
				o = msgp.AppendFloat64(o, za0004)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "histMetrics"
			o = append(o, 0xab, 0x68, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.HistMetrics)))
			for za0005, za0006 := range z.HistMetrics {
				o = msgp.AppendString(o, za0005)
				o, err = (*localF64H)(&za0006).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
			}
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendInt(o, z.N)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RuntimeMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uintMetrics":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			if z.UintMetrics == nil {
				z.UintMetrics = make(map[string]uint64, zb0002)
			} else if len(z.UintMetrics) > 0 {
				for key := range z.UintMetrics {
					delete(z.UintMetrics, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 uint64
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
				z.UintMetrics[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "floatMetrics":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			if z.FloatMetrics == nil {
				z.FloatMetrics = make(map[string]float64, zb0003)
			} else if len(z.FloatMetrics) > 0 {
				for key := range z.FloatMetrics {
					delete(z.FloatMetrics, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 float64
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				za0004, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
				z.FloatMetrics[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "histMetrics":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			if z.HistMetrics == nil {
				z.HistMetrics = make(map[string]metrics.Float64Histogram, zb0004)
			} else if len(z.HistMetrics) > 0 {
				for key := range z.HistMetrics {
					delete(z.HistMetrics, key)
				}
			}
			for zb0004 > 0 {
				var za0005 string
				var za0006 metrics.Float64Histogram
				zb0004--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				bts, err = (*localF64H)(&za0006).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
				z.HistMetrics[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "n":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.UintMetrics = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.FloatMetrics = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.HistMetrics = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RuntimeMetrics) Msgsize() (s int) {
	s = 1 + 12 + msgp.MapHeaderSize
	if z.UintMetrics != nil {
		for za0001, za0002 := range z.UintMetrics {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 13 + msgp.MapHeaderSize
	if z.FloatMetrics != nil {
		for za0003, za0004 := range z.FloatMetrics {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.Float64Size
		}
	}
	s += 12 + msgp.MapHeaderSize
	if z.HistMetrics != nil {
		for za0005, za0006 := range z.HistMetrics {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + (*localF64H)(&za0006).Msgsize()
		}
	}
	s += 2 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ScannerMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "current_cycle":
			z.CurrentCycle, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CurrentCycle")
				return
			}
		case "current_started":
			z.CurrentStarted, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CurrentStarted")
				return
			}
		case "cycle_complete_times":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CyclesCompletedAt")
				return
			}
			if cap(z.CyclesCompletedAt) >= int(zb0002) {
				z.CyclesCompletedAt = (z.CyclesCompletedAt)[:zb0002]
			} else {
				z.CyclesCompletedAt = make([]time.Time, zb0002)
			}
			for za0001 := range z.CyclesCompletedAt {
				z.CyclesCompletedAt[za0001], err = dc.ReadTime()
				if err != nil {
					err = msgp.WrapError(err, "CyclesCompletedAt", za0001)
					return
				}
			}
		case "ongoing_buckets":
			z.OngoingBuckets, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OngoingBuckets")
				return
			}
		case "per_bucket_stats":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			if z.PerBucketStats == nil {
				z.PerBucketStats = make(map[string][]BucketScanInfo, zb0003)
			} else if len(z.PerBucketStats) > 0 {
				for key := range z.PerBucketStats {
					delete(z.PerBucketStats, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0002 string
				var za0003 []BucketScanInfo
				za0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				var zb0004 uint32
				zb0004, err = dc.ReadArrayHeader()
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0002)
					return
				}
				if cap(za0003) >= int(zb0004) {
					za0003 = (za0003)[:zb0004]
				} else {
					za0003 = make([]BucketScanInfo, zb0004)
				}
				for za0004 := range za0003 {
					err = za0003[za0004].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0002, za0004)
						return
					}
				}
				z.PerBucketStats[za0002] = za0003
			}
			zb0001Mask |= 0x1
		case "life_time_ops":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0005)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0005 > 0 {
				zb0005--
				var za0005 string
				var za0006 uint64
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0006, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0005)
					return
				}
				z.LifeTimeOps[za0005] = za0006
			}
			zb0001Mask |= 0x2
		case "ilm_ops":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			if z.LifeTimeILM == nil {
				z.LifeTimeILM = make(map[string]uint64, zb0006)
			} else if len(z.LifeTimeILM) > 0 {
				for key := range z.LifeTimeILM {
					delete(z.LifeTimeILM, key)
				}
			}
			for zb0006 > 0 {
				zb0006--
				var za0007 string
				var za0008 uint64
				za0007, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				za0008, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0007)
					return
				}
				z.LifeTimeILM[za0007] = za0008
			}
			zb0001Mask |= 0x4
		case "last_minute":
			var zb0007 uint32
			zb0007, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0007Mask uint8 /* 2 bits */
			_ = zb0007Mask
			for zb0007 > 0 {
				zb0007--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "actions":
					var zb0008 uint32
					zb0008, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					if z.LastMinute.Actions == nil {
						z.LastMinute.Actions = make(map[string]TimedAction, zb0008)
					} else if len(z.LastMinute.Actions) > 0 {
						for key := range z.LastMinute.Actions {
							delete(z.LastMinute.Actions, key)
						}
					}
					for zb0008 > 0 {
						zb0008--
						var za0009 string
						var za0010 TimedAction
						za0009, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions")
							return
						}
						err = za0010.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions", za0009)
							return
						}
						z.LastMinute.Actions[za0009] = za0010
					}
					zb0007Mask |= 0x1
				case "ilm":
					var zb0009 uint32
					zb0009, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					if z.LastMinute.ILM == nil {
						z.LastMinute.ILM = make(map[string]TimedAction, zb0009)
					} else if len(z.LastMinute.ILM) > 0 {
						for key := range z.LastMinute.ILM {
							delete(z.LastMinute.ILM, key)
						}
					}
					for zb0009 > 0 {
						zb0009--
						var za0011 string
						var za0012 TimedAction
						za0011, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM")
							return
						}
						err = za0012.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM", za0011)
							return
						}
						z.LastMinute.ILM[za0011] = za0012
					}
					zb0007Mask |= 0x2
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0007Mask != 0x3 {
				if (zb0007Mask & 0x1) == 0 {
					z.LastMinute.Actions = nil
				}
				if (zb0007Mask & 0x2) == 0 {
					z.LastMinute.ILM = nil
				}
			}
		case "active":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			if cap(z.ActivePaths) >= int(zb0010) {
				z.ActivePaths = (z.ActivePaths)[:zb0010]
			} else {
				z.ActivePaths = make([]string, zb0010)
			}
			for za0013 := range z.ActivePaths {
				z.ActivePaths[za0013], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0013)
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.PerBucketStats = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LifeTimeILM = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ActivePaths = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ScannerMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	if z.PerBucketStats == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.LifeTimeILM == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.ActivePaths == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "current_cycle"
		err = en.Append(0xad, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x79, 0x63, 0x6c, 0x65)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.CurrentCycle)
		if err != nil {
			err = msgp.WrapError(err, "CurrentCycle")
			return
		}
		// write "current_started"
		err = en.Append(0xaf, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CurrentStarted)
		if err != nil {
			err = msgp.WrapError(err, "CurrentStarted")
			return
		}
		// write "cycle_complete_times"
		err = en.Append(0xb4, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.CyclesCompletedAt)))
		if err != nil {
			err = msgp.WrapError(err, "CyclesCompletedAt")
			return
		}
		for za0001 := range z.CyclesCompletedAt {
			err = en.WriteTime(z.CyclesCompletedAt[za0001])
			if err != nil {
				err = msgp.WrapError(err, "CyclesCompletedAt", za0001)
				return
			}
		}
		// write "ongoing_buckets"
		err = en.Append(0xaf, 0x6f, 0x6e, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.OngoingBuckets)
		if err != nil {
			err = msgp.WrapError(err, "OngoingBuckets")
			return
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "per_bucket_stats"
			err = en.Append(0xb0, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.PerBucketStats)))
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			for za0002, za0003 := range z.PerBucketStats {
				err = en.WriteString(za0002)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				err = en.WriteArrayHeader(uint32(len(za0003)))
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0002)
					return
				}
				for za0004 := range za0003 {
					err = za0003[za0004].EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0002, za0004)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "life_time_ops"
			err = en.Append(0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			for za0005, za0006 := range z.LifeTimeOps {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				err = en.WriteUint64(za0006)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "ilm_ops"
			err = en.Append(0xa7, 0x69, 0x6c, 0x6d, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeILM)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			for za0007, za0008 := range z.LifeTimeILM {
				err = en.WriteString(za0007)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				err = en.WriteUint64(za0008)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0007)
					return
				}
			}
		}
		// write "last_minute"
		err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(2)
		var zb0002Mask uint8 /* 2 bits */
		_ = zb0002Mask
		if z.LastMinute.Actions == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		if z.LastMinute.ILM == nil {
			zb0002Len--
			zb0002Mask |= 0x2
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}

		// skip if no fields are to be emitted
		if zb0002Len != 0 {
			if (zb0002Mask & 0x1) == 0 { // if not omitted
				// write "actions"
				err = en.Append(0xa7, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
				if err != nil {
					return
				}
				err = en.WriteMapHeader(uint32(len(z.LastMinute.Actions)))
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Actions")
					return
				}
				for za0009, za0010 := range z.LastMinute.Actions {
					err = en.WriteString(za0009)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					err = za0010.EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions", za0009)
						return
					}
				}
			}
			if (zb0002Mask & 0x2) == 0 { // if not omitted
				// write "ilm"
				err = en.Append(0xa3, 0x69, 0x6c, 0x6d)
				if err != nil {
					return
				}
				err = en.WriteMapHeader(uint32(len(z.LastMinute.ILM)))
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "ILM")
					return
				}
				for za0011, za0012 := range z.LastMinute.ILM {
					err = en.WriteString(za0011)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					err = za0012.EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM", za0011)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "active"
			err = en.Append(0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.ActivePaths)))
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			for za0013 := range z.ActivePaths {
				err = en.WriteString(z.ActivePaths[za0013])
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0013)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ScannerMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	if z.PerBucketStats == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.LifeTimeILM == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.ActivePaths == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "current_cycle"
		o = append(o, 0xad, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x63, 0x79, 0x63, 0x6c, 0x65)
		o = msgp.AppendUint64(o, z.CurrentCycle)
		// string "current_started"
		o = append(o, 0xaf, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CurrentStarted)
		// string "cycle_complete_times"
		o = append(o, 0xb4, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.CyclesCompletedAt)))
		for za0001 := range z.CyclesCompletedAt {
			o = msgp.AppendTime(o, z.CyclesCompletedAt[za0001])
		}
		// string "ongoing_buckets"
		o = append(o, 0xaf, 0x6f, 0x6e, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendInt(o, z.OngoingBuckets)
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "per_bucket_stats"
			o = append(o, 0xb0, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.PerBucketStats)))
			for za0002, za0003 := range z.PerBucketStats {
				o = msgp.AppendString(o, za0002)
				o = msgp.AppendArrayHeader(o, uint32(len(za0003)))
				for za0004 := range za0003 {
					o, err = za0003[za0004].MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0002, za0004)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "life_time_ops"
			o = append(o, 0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeOps)))
			for za0005, za0006 := range z.LifeTimeOps {
				o = msgp.AppendString(o, za0005)
				o = msgp.AppendUint64(o, za0006)
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "ilm_ops"
			o = append(o, 0xa7, 0x69, 0x6c, 0x6d, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeILM)))
			for za0007, za0008 := range z.LifeTimeILM {
				o = msgp.AppendString(o, za0007)
				o = msgp.AppendUint64(o, za0008)
			}
		}
		// string "last_minute"
		o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		// check for omitted fields
		zb0002Len := uint32(2)
		var zb0002Mask uint8 /* 2 bits */
		_ = zb0002Mask
		if z.LastMinute.Actions == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		if z.LastMinute.ILM == nil {
			zb0002Len--
			zb0002Mask |= 0x2
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))

		// skip if no fields are to be emitted
		if zb0002Len != 0 {
			if (zb0002Mask & 0x1) == 0 { // if not omitted
				// string "actions"
				o = append(o, 0xa7, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
				o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.Actions)))
				for za0009, za0010 := range z.LastMinute.Actions {
					o = msgp.AppendString(o, za0009)
					o, err = za0010.MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions", za0009)
						return
					}
				}
			}
			if (zb0002Mask & 0x2) == 0 { // if not omitted
				// string "ilm"
				o = append(o, 0xa3, 0x69, 0x6c, 0x6d)
				o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.ILM)))
				for za0011, za0012 := range z.LastMinute.ILM {
					o = msgp.AppendString(o, za0011)
					o, err = za0012.MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM", za0011)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "active"
			o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
			o = msgp.AppendArrayHeader(o, uint32(len(z.ActivePaths)))
			for za0013 := range z.ActivePaths {
				o = msgp.AppendString(o, z.ActivePaths[za0013])
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ScannerMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "current_cycle":
			z.CurrentCycle, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentCycle")
				return
			}
		case "current_started":
			z.CurrentStarted, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentStarted")
				return
			}
		case "cycle_complete_times":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CyclesCompletedAt")
				return
			}
			if cap(z.CyclesCompletedAt) >= int(zb0002) {
				z.CyclesCompletedAt = (z.CyclesCompletedAt)[:zb0002]
			} else {
				z.CyclesCompletedAt = make([]time.Time, zb0002)
			}
			for za0001 := range z.CyclesCompletedAt {
				z.CyclesCompletedAt[za0001], bts, err = msgp.ReadTimeBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CyclesCompletedAt", za0001)
					return
				}
			}
		case "ongoing_buckets":
			z.OngoingBuckets, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OngoingBuckets")
				return
			}
		case "per_bucket_stats":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			if z.PerBucketStats == nil {
				z.PerBucketStats = make(map[string][]BucketScanInfo, zb0003)
			} else if len(z.PerBucketStats) > 0 {
				for key := range z.PerBucketStats {
					delete(z.PerBucketStats, key)
				}
			}
			for zb0003 > 0 {
				var za0002 string
				var za0003 []BucketScanInfo
				zb0003--
				za0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0002)
					return
				}
				if cap(za0003) >= int(zb0004) {
					za0003 = (za0003)[:zb0004]
				} else {
					za0003 = make([]BucketScanInfo, zb0004)
				}
				for za0004 := range za0003 {
					bts, err = za0003[za0004].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0002, za0004)
						return
					}
				}
				z.PerBucketStats[za0002] = za0003
			}
			zb0001Mask |= 0x1
		case "life_time_ops":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0005)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0005 > 0 {
				var za0005 string
				var za0006 uint64
				zb0005--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0006, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0005)
					return
				}
				z.LifeTimeOps[za0005] = za0006
			}
			zb0001Mask |= 0x2
		case "ilm_ops":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			if z.LifeTimeILM == nil {
				z.LifeTimeILM = make(map[string]uint64, zb0006)
			} else if len(z.LifeTimeILM) > 0 {
				for key := range z.LifeTimeILM {
					delete(z.LifeTimeILM, key)
				}
			}
			for zb0006 > 0 {
				var za0007 string
				var za0008 uint64
				zb0006--
				za0007, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				za0008, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0007)
					return
				}
				z.LifeTimeILM[za0007] = za0008
			}
			zb0001Mask |= 0x4
		case "last_minute":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0007Mask uint8 /* 2 bits */
			_ = zb0007Mask
			for zb0007 > 0 {
				zb0007--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "actions":
					var zb0008 uint32
					zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					if z.LastMinute.Actions == nil {
						z.LastMinute.Actions = make(map[string]TimedAction, zb0008)
					} else if len(z.LastMinute.Actions) > 0 {
						for key := range z.LastMinute.Actions {
							delete(z.LastMinute.Actions, key)
						}
					}
					for zb0008 > 0 {
						var za0009 string
						var za0010 TimedAction
						zb0008--
						za0009, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions")
							return
						}
						bts, err = za0010.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions", za0009)
							return
						}
						z.LastMinute.Actions[za0009] = za0010
					}
					zb0007Mask |= 0x1
				case "ilm":
					var zb0009 uint32
					zb0009, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					if z.LastMinute.ILM == nil {
						z.LastMinute.ILM = make(map[string]TimedAction, zb0009)
					} else if len(z.LastMinute.ILM) > 0 {
						for key := range z.LastMinute.ILM {
							delete(z.LastMinute.ILM, key)
						}
					}
					for zb0009 > 0 {
						var za0011 string
						var za0012 TimedAction
						zb0009--
						za0011, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM")
							return
						}
						bts, err = za0012.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM", za0011)
							return
						}
						z.LastMinute.ILM[za0011] = za0012
					}
					zb0007Mask |= 0x2
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0007Mask != 0x3 {
				if (zb0007Mask & 0x1) == 0 {
					z.LastMinute.Actions = nil
				}
				if (zb0007Mask & 0x2) == 0 {
					z.LastMinute.ILM = nil
				}
			}
		case "active":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			if cap(z.ActivePaths) >= int(zb0010) {
				z.ActivePaths = (z.ActivePaths)[:zb0010]
			} else {
				z.ActivePaths = make([]string, zb0010)
			}
			for za0013 := range z.ActivePaths {
				z.ActivePaths[za0013], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0013)
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.PerBucketStats = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LifeTimeILM = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ActivePaths = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ScannerMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 14 + msgp.Uint64Size + 16 + msgp.TimeSize + 21 + msgp.ArrayHeaderSize + (len(z.CyclesCompletedAt) * (msgp.TimeSize)) + 16 + msgp.IntSize + 17 + msgp.MapHeaderSize
	if z.PerBucketStats != nil {
		for za0002, za0003 := range z.PerBucketStats {
			_ = za0003
			s += msgp.StringPrefixSize + len(za0002) + msgp.ArrayHeaderSize
			for za0004 := range za0003 {
				s += za0003[za0004].Msgsize()
			}
		}
	}
	s += 14 + msgp.MapHeaderSize
	if z.LifeTimeOps != nil {
		for za0005, za0006 := range z.LifeTimeOps {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + msgp.Uint64Size
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.LifeTimeILM != nil {
		for za0007, za0008 := range z.LifeTimeILM {
			_ = za0008
			s += msgp.StringPrefixSize + len(za0007) + msgp.Uint64Size
		}
	}
	s += 12 + 1 + 8 + msgp.MapHeaderSize
	if z.LastMinute.Actions != nil {
		for za0009, za0010 := range z.LastMinute.Actions {
			_ = za0010
			s += msgp.StringPrefixSize + len(za0009) + za0010.Msgsize()
		}
	}
	s += 4 + msgp.MapHeaderSize
	if z.LastMinute.ILM != nil {
		for za0011, za0012 := range z.LastMinute.ILM {
			_ = za0012
			s += msgp.StringPrefixSize + len(za0011) + za0012.Msgsize()
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0013 := range z.ActivePaths {
		s += msgp.StringPrefixSize + len(z.ActivePaths[za0013])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SiteResyncMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "resyncStatus":
			z.ResyncStatus, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			z.StartTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "numBuckets":
			z.NumBuckets, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "NumBuckets")
				return
			}
		case "resyncID":
			z.ResyncID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ResyncID")
				return
			}
		case "deplID":
			z.DeplID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DeplID")
				return
			}
		case "completedReplicationSize":
			z.ReplicatedSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "replicationCount":
			z.ReplicatedCount, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedCount")
				return
			}
		case "failedReplicationSize":
			z.FailedSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FailedSize")
				return
			}
		case "failedReplicationCount":
			z.FailedCount, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FailedCount")
				return
			}
		case "failedBuckets":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets")
				return
			}
			if cap(z.FailedBuckets) >= int(zb0002) {
				z.FailedBuckets = (z.FailedBuckets)[:zb0002]
			} else {
				z.FailedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.FailedBuckets {
				z.FailedBuckets[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "FailedBuckets", za0001)
					return
				}
			}
		case "bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
			zb0001Mask |= 0x2
		case "object":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
			zb0001Mask |= 0x4
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.ResyncStatus = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Bucket = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Object = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SiteResyncMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.ResyncStatus == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Bucket == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.Object == "" {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "resyncStatus"
			err = en.Append(0xac, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
			if err != nil {
				return
			}
			err = en.WriteString(z.ResyncStatus)
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
		}
		// write "startTime"
		err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.StartTime)
		if err != nil {
			err = msgp.WrapError(err, "StartTime")
			return
		}
		// write "lastUpdate"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastUpdate)
		if err != nil {
			err = msgp.WrapError(err, "LastUpdate")
			return
		}
		// write "numBuckets"
		err = en.Append(0xaa, 0x6e, 0x75, 0x6d, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.NumBuckets)
		if err != nil {
			err = msgp.WrapError(err, "NumBuckets")
			return
		}
		// write "resyncID"
		err = en.Append(0xa8, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.ResyncID)
		if err != nil {
			err = msgp.WrapError(err, "ResyncID")
			return
		}
		// write "deplID"
		err = en.Append(0xa6, 0x64, 0x65, 0x70, 0x6c, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.DeplID)
		if err != nil {
			err = msgp.WrapError(err, "DeplID")
			return
		}
		// write "completedReplicationSize"
		err = en.Append(0xb8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.ReplicatedSize)
		if err != nil {
			err = msgp.WrapError(err, "ReplicatedSize")
			return
		}
		// write "replicationCount"
		err = en.Append(0xb0, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.ReplicatedCount)
		if err != nil {
			err = msgp.WrapError(err, "ReplicatedCount")
			return
		}
		// write "failedReplicationSize"
		err = en.Append(0xb5, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.FailedSize)
		if err != nil {
			err = msgp.WrapError(err, "FailedSize")
			return
		}
		// write "failedReplicationCount"
		err = en.Append(0xb6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.FailedCount)
		if err != nil {
			err = msgp.WrapError(err, "FailedCount")
			return
		}
		// write "failedBuckets"
		err = en.Append(0xad, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.FailedBuckets)))
		if err != nil {
			err = msgp.WrapError(err, "FailedBuckets")
			return
		}
		for za0001 := range z.FailedBuckets {
			err = en.WriteString(z.FailedBuckets[za0001])
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets", za0001)
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "bucket"
			err = en.Append(0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
			if err != nil {
				return
			}
			err = en.WriteString(z.Bucket)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "object"
			err = en.Append(0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
			if err != nil {
				return
			}
			err = en.WriteString(z.Object)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SiteResyncMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.ResyncStatus == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Bucket == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.Object == "" {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "resyncStatus"
			o = append(o, 0xac, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
			o = msgp.AppendString(o, z.ResyncStatus)
		}
		// string "startTime"
		o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.StartTime)
		// string "lastUpdate"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		o = msgp.AppendTime(o, z.LastUpdate)
		// string "numBuckets"
		o = append(o, 0xaa, 0x6e, 0x75, 0x6d, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendInt64(o, z.NumBuckets)
		// string "resyncID"
		o = append(o, 0xa8, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x49, 0x44)
		o = msgp.AppendString(o, z.ResyncID)
		// string "deplID"
		o = append(o, 0xa6, 0x64, 0x65, 0x70, 0x6c, 0x49, 0x44)
		o = msgp.AppendString(o, z.DeplID)
		// string "completedReplicationSize"
		o = append(o, 0xb8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt64(o, z.ReplicatedSize)
		// string "replicationCount"
		o = append(o, 0xb0, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt64(o, z.ReplicatedCount)
		// string "failedReplicationSize"
		o = append(o, 0xb5, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt64(o, z.FailedSize)
		// string "failedReplicationCount"
		o = append(o, 0xb6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt64(o, z.FailedCount)
		// string "failedBuckets"
		o = append(o, 0xad, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.FailedBuckets)))
		for za0001 := range z.FailedBuckets {
			o = msgp.AppendString(o, z.FailedBuckets[za0001])
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "bucket"
			o = append(o, 0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
			o = msgp.AppendString(o, z.Bucket)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "object"
			o = append(o, 0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
			o = msgp.AppendString(o, z.Object)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SiteResyncMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "resyncStatus":
			z.ResyncStatus, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "numBuckets":
			z.NumBuckets, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumBuckets")
				return
			}
		case "resyncID":
			z.ResyncID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResyncID")
				return
			}
		case "deplID":
			z.DeplID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeplID")
				return
			}
		case "completedReplicationSize":
			z.ReplicatedSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "replicationCount":
			z.ReplicatedCount, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedCount")
				return
			}
		case "failedReplicationSize":
			z.FailedSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedSize")
				return
			}
		case "failedReplicationCount":
			z.FailedCount, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedCount")
				return
			}
		case "failedBuckets":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets")
				return
			}
			if cap(z.FailedBuckets) >= int(zb0002) {
				z.FailedBuckets = (z.FailedBuckets)[:zb0002]
			} else {
				z.FailedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.FailedBuckets {
				z.FailedBuckets[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FailedBuckets", za0001)
					return
				}
			}
		case "bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
			zb0001Mask |= 0x2
		case "object":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
			zb0001Mask |= 0x4
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.ResyncStatus = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Bucket = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Object = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SiteResyncMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 13 + msgp.StringPrefixSize + len(z.ResyncStatus) + 10 + msgp.TimeSize + 11 + msgp.TimeSize + 11 + msgp.Int64Size + 9 + msgp.StringPrefixSize + len(z.ResyncID) + 7 + msgp.StringPrefixSize + len(z.DeplID) + 25 + msgp.Int64Size + 17 + msgp.Int64Size + 22 + msgp.Int64Size + 23 + msgp.Int64Size + 14 + msgp.ArrayHeaderSize
	for za0001 := range z.FailedBuckets {
		s += msgp.StringPrefixSize + len(z.FailedBuckets[za0001])
	}
	s += 7 + msgp.StringPrefixSize + len(z.Bucket) + 7 + msgp.StringPrefixSize + len(z.Object)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *localF64H) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "counts":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			if cap(z.Counts) >= int(zb0002) {
				z.Counts = (z.Counts)[:zb0002]
			} else {
				z.Counts = make([]uint64, zb0002)
			}
			for za0001 := range z.Counts {
				z.Counts[za0001], err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "buckets":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			if cap(z.Buckets) >= int(zb0003) {
				z.Buckets = (z.Buckets)[:zb0003]
			} else {
				z.Buckets = make([]float64, zb0003)
			}
			for za0002 := range z.Buckets {
				z.Buckets[za0002], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Counts = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Buckets = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *localF64H) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Counts == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Buckets == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "counts"
			err = en.Append(0xa6, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Counts)))
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			for za0001 := range z.Counts {
				err = en.WriteUint64(z.Counts[za0001])
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "buckets"
			err = en.Append(0xa7, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Buckets)))
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			for za0002 := range z.Buckets {
				err = en.WriteFloat64(z.Buckets[za0002])
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *localF64H) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Counts == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Buckets == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "counts"
			o = append(o, 0xa6, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Counts)))
			for za0001 := range z.Counts {
				o = msgp.AppendUint64(o, z.Counts[za0001])
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "buckets"
			o = append(o, 0xa7, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Buckets)))
			for za0002 := range z.Buckets {
				o = msgp.AppendFloat64(o, z.Buckets[za0002])
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *localF64H) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "counts":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			if cap(z.Counts) >= int(zb0002) {
				z.Counts = (z.Counts)[:zb0002]
			} else {
				z.Counts = make([]uint64, zb0002)
			}
			for za0001 := range z.Counts {
				z.Counts[za0001], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "buckets":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			if cap(z.Buckets) >= int(zb0003) {
				z.Buckets = (z.Buckets)[:zb0003]
			} else {
				z.Buckets = make([]float64, zb0003)
			}
			for za0002 := range z.Buckets {
				z.Buckets[za0002], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Counts = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Buckets = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *localF64H) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize + (len(z.Counts) * (msgp.Uint64Size)) + 8 + msgp.ArrayHeaderSize + (len(z.Buckets) * (msgp.Float64Size))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *nodeCommon) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			z.Addr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Addr")
				return
			}
		case "error":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.Error = ""
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z nodeCommon) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "addr"
		err = en.Append(0xa4, 0x61, 0x64, 0x64, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.Addr)
		if err != nil {
			err = msgp.WrapError(err, "Addr")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "error"
			err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			if err != nil {
				return
			}
			err = en.WriteString(z.Error)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z nodeCommon) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "addr"
		o = append(o, 0xa4, 0x61, 0x64, 0x64, 0x72)
		o = msgp.AppendString(o, z.Addr)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "error"
			o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			o = msgp.AppendString(o, z.Error)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *nodeCommon) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			z.Addr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Addr")
				return
			}
		case "error":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.Error = ""
	}

	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z nodeCommon) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Addr) + 6 + msgp.StringPrefixSize + len(z.Error)
	return
}
