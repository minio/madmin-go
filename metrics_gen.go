package madmin

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"runtime/metrics"
	"time"

	"github.com/shirou/gopsutil/v4/cpu"
	"github.com/shirou/gopsutil/v4/load"
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *APIMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "activeRequests":
			z.ActiveRequests, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ActiveRequests")
				return
			}
			zb0001Mask |= 0x1
		case "queuedRequests":
			z.QueuedRequests, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "QueuedRequests")
				return
			}
			zb0001Mask |= 0x2
		case "lastMinuteApi":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinuteAPI")
				return
			}
			if z.LastMinuteAPI == nil {
				z.LastMinuteAPI = make(map[string]APIStats, zb0002)
			} else if len(z.LastMinuteAPI) > 0 {
				for key := range z.LastMinuteAPI {
					delete(z.LastMinuteAPI, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 APIStats
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI")
					return
				}
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI", za0001)
					return
				}
				z.LastMinuteAPI[za0001] = za0002
			}
			zb0001Mask |= 0x4
		case "lastDayApi":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastDayAPI")
				return
			}
			if z.LastDayAPI == nil {
				z.LastDayAPI = make(map[string]SegmentedAPIMetrics, zb0003)
			} else if len(z.LastDayAPI) > 0 {
				for key := range z.LastDayAPI {
					delete(z.LastDayAPI, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 SegmentedAPIMetrics
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI")
					return
				}
				err = za0004.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI", za0003)
					return
				}
				z.LastDayAPI[za0003] = za0004
			}
			zb0001Mask |= 0x8
		case "since_start":
			err = z.SinceStart.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "SinceStart")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.ActiveRequests = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.QueuedRequests = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LastMinuteAPI = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.LastDayAPI = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *APIMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.ActiveRequests == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.QueuedRequests == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LastMinuteAPI == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.LastDayAPI == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "nodes"
		err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Nodes)
		if err != nil {
			err = msgp.WrapError(err, "Nodes")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "activeRequests"
			err = en.Append(0xae, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ActiveRequests)
			if err != nil {
				err = msgp.WrapError(err, "ActiveRequests")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "queuedRequests"
			err = en.Append(0xae, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.QueuedRequests)
			if err != nil {
				err = msgp.WrapError(err, "QueuedRequests")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "lastMinuteApi"
			err = en.Append(0xad, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x41, 0x70, 0x69)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinuteAPI)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinuteAPI")
				return
			}
			for za0001, za0002 := range z.LastMinuteAPI {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI")
					return
				}
				err = za0002.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "lastDayApi"
			err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x79, 0x41, 0x70, 0x69)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastDayAPI)))
			if err != nil {
				err = msgp.WrapError(err, "LastDayAPI")
				return
			}
			for za0003, za0004 := range z.LastDayAPI {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI", za0003)
					return
				}
			}
		}
		// write "since_start"
		err = en.Append(0xab, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74)
		if err != nil {
			return
		}
		err = z.SinceStart.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "SinceStart")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *APIMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.ActiveRequests == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.QueuedRequests == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LastMinuteAPI == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.LastDayAPI == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "nodes"
		o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		o = msgp.AppendInt(o, z.Nodes)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "activeRequests"
			o = append(o, 0xae, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			o = msgp.AppendInt64(o, z.ActiveRequests)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "queuedRequests"
			o = append(o, 0xae, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			o = msgp.AppendInt64(o, z.QueuedRequests)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "lastMinuteApi"
			o = append(o, 0xad, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x41, 0x70, 0x69)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinuteAPI)))
			for za0001, za0002 := range z.LastMinuteAPI {
				o = msgp.AppendString(o, za0001)
				o, err = za0002.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "lastDayApi"
			o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x79, 0x41, 0x70, 0x69)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastDayAPI)))
			for za0003, za0004 := range z.LastDayAPI {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI", za0003)
					return
				}
			}
		}
		// string "since_start"
		o = append(o, 0xab, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74)
		o, err = z.SinceStart.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "SinceStart")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *APIMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "activeRequests":
			z.ActiveRequests, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActiveRequests")
				return
			}
			zb0001Mask |= 0x1
		case "queuedRequests":
			z.QueuedRequests, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QueuedRequests")
				return
			}
			zb0001Mask |= 0x2
		case "lastMinuteApi":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinuteAPI")
				return
			}
			if z.LastMinuteAPI == nil {
				z.LastMinuteAPI = make(map[string]APIStats, zb0002)
			} else if len(z.LastMinuteAPI) > 0 {
				for key := range z.LastMinuteAPI {
					delete(z.LastMinuteAPI, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 APIStats
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI", za0001)
					return
				}
				z.LastMinuteAPI[za0001] = za0002
			}
			zb0001Mask |= 0x4
		case "lastDayApi":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastDayAPI")
				return
			}
			if z.LastDayAPI == nil {
				z.LastDayAPI = make(map[string]SegmentedAPIMetrics, zb0003)
			} else if len(z.LastDayAPI) > 0 {
				for key := range z.LastDayAPI {
					delete(z.LastDayAPI, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 SegmentedAPIMetrics
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI")
					return
				}
				bts, err = za0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI", za0003)
					return
				}
				z.LastDayAPI[za0003] = za0004
			}
			zb0001Mask |= 0x8
		case "since_start":
			bts, err = z.SinceStart.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "SinceStart")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.ActiveRequests = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.QueuedRequests = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LastMinuteAPI = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.LastDayAPI = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *APIMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 6 + msgp.IntSize + 15 + msgp.Int64Size + 15 + msgp.Int64Size + 14 + msgp.MapHeaderSize
	if z.LastMinuteAPI != nil {
		for za0001, za0002 := range z.LastMinuteAPI {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += 11 + msgp.MapHeaderSize
	if z.LastDayAPI != nil {
		for za0003, za0004 := range z.LastDayAPI {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += 12 + z.SinceStart.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *APIStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 23 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
				z.StartTime = nil
			} else {
				if z.StartTime == nil {
					z.StartTime = new(time.Time)
				}
				*z.StartTime, err = dc.ReadTimeUTC()
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
			zb0001Mask |= 0x2
		case "endTime":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
				z.EndTime = nil
			} else {
				if z.EndTime == nil {
					z.EndTime = new(time.Time)
				}
				*z.EndTime, err = dc.ReadTimeUTC()
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
			zb0001Mask |= 0x4
		case "wallTimeSecs":
			z.WallTimeSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
			zb0001Mask |= 0x8
		case "requests":
			z.Requests, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
			zb0001Mask |= 0x10
		case "incomingBytes":
			z.IncomingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x20
		case "outgoingBytes":
			z.OutgoingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x40
		case "errors_4xx":
			z.Errors4xx, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Errors4xx")
				return
			}
			zb0001Mask |= 0x80
		case "errors_5xx":
			z.Errors5xx, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Errors5xx")
				return
			}
			zb0001Mask |= 0x100
		case "canceled":
			z.Canceled, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Canceled")
				return
			}
			zb0001Mask |= 0x200
		case "requestTimeSecs":
			z.RequestTimeSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
			zb0001Mask |= 0x400
		case "reqReadSecs":
			z.ReqReadSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecs")
				return
			}
			zb0001Mask |= 0x800
		case "respSecs":
			z.RespSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespSecs")
				return
			}
			zb0001Mask |= 0x1000
		case "respTtfbSecs":
			z.RespTTFBSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecs")
				return
			}
			zb0001Mask |= 0x2000
		case "requestTimeSecsMin":
			z.RequestTimeSecsMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMin")
				return
			}
			zb0001Mask |= 0x4000
		case "requestTimeSecsMax":
			z.RequestTimeSecsMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMax")
				return
			}
			zb0001Mask |= 0x8000
		case "reqReadSecsMin":
			z.ReqReadSecsMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMin")
				return
			}
			zb0001Mask |= 0x10000
		case "reqReadSecsMax":
			z.ReqReadSecsMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMax")
				return
			}
			zb0001Mask |= 0x20000
		case "respSecsMin":
			z.RespSecsMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMin")
				return
			}
			zb0001Mask |= 0x40000
		case "respSecsMax":
			z.RespSecsMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMax")
				return
			}
			zb0001Mask |= 0x80000
		case "respTtfbSecsMin":
			z.RespTTFBSecsMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMin")
				return
			}
			zb0001Mask |= 0x100000
		case "respTtfbSecsMax":
			z.RespTTFBSecsMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMax")
				return
			}
			zb0001Mask |= 0x200000
		case "rejected":
			err = z.Rejected.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Rejected")
				return
			}
			zb0001Mask |= 0x400000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7fffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.StartTime = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.EndTime = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.WallTimeSecs = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Requests = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.OutgoingBytes = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Errors4xx = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Errors5xx = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Canceled = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.RequestTimeSecs = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReqReadSecs = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.RespSecs = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.RespTTFBSecs = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.RequestTimeSecsMin = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.RequestTimeSecsMax = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.ReqReadSecsMin = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.ReqReadSecsMax = 0
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.RespSecsMin = 0
		}
		if (zb0001Mask & 0x80000) == 0 {
			z.RespSecsMax = 0
		}
		if (zb0001Mask & 0x100000) == 0 {
			z.RespTTFBSecsMin = 0
		}
		if (zb0001Mask & 0x200000) == 0 {
			z.RespTTFBSecsMax = 0
		}
		if (zb0001Mask & 0x400000) == 0 {
			z.Rejected = RejectedAPIStats{}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *APIStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(23)
	var zb0001Mask uint32 /* 23 bits */
	_ = zb0001Mask
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.StartTime == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.EndTime == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.WallTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Requests == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Errors4xx == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Errors5xx == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Canceled == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RequestTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.ReqReadSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.RespSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.RespTTFBSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.RequestTimeSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.RequestTimeSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.ReqReadSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.ReqReadSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.RespSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.RespSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.RespTTFBSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x100000
	}
	if z.RespTTFBSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x200000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "nodes"
			err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Nodes)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "startTime"
			err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			if z.StartTime == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteTime(*z.StartTime)
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "endTime"
			err = en.Append(0xa7, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			if z.EndTime == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteTime(*z.EndTime)
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "wallTimeSecs"
			err = en.Append(0xac, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.WallTimeSecs)
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "requests"
			err = en.Append(0xa8, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Requests)
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "incomingBytes"
			err = en.Append(0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.IncomingBytes)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "outgoingBytes"
			err = en.Append(0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.OutgoingBytes)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "errors_4xx"
			err = en.Append(0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x5f, 0x34, 0x78, 0x78)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Errors4xx)
			if err != nil {
				err = msgp.WrapError(err, "Errors4xx")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "errors_5xx"
			err = en.Append(0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x5f, 0x35, 0x78, 0x78)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Errors5xx)
			if err != nil {
				err = msgp.WrapError(err, "Errors5xx")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "canceled"
			err = en.Append(0xa8, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Canceled)
			if err != nil {
				err = msgp.WrapError(err, "Canceled")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "requestTimeSecs"
			err = en.Append(0xaf, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RequestTimeSecs)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "reqReadSecs"
			err = en.Append(0xab, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.ReqReadSecs)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecs")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "respSecs"
			err = en.Append(0xa8, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespSecs)
			if err != nil {
				err = msgp.WrapError(err, "RespSecs")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "respTtfbSecs"
			err = en.Append(0xac, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespTTFBSecs)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecs")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "requestTimeSecsMin"
			err = en.Append(0xb2, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RequestTimeSecsMin)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMin")
				return
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "requestTimeSecsMax"
			err = en.Append(0xb2, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RequestTimeSecsMax)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMax")
				return
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "reqReadSecsMin"
			err = en.Append(0xae, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.ReqReadSecsMin)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMin")
				return
			}
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// write "reqReadSecsMax"
			err = en.Append(0xae, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.ReqReadSecsMax)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMax")
				return
			}
		}
		if (zb0001Mask & 0x40000) == 0 { // if not omitted
			// write "respSecsMin"
			err = en.Append(0xab, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespSecsMin)
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMin")
				return
			}
		}
		if (zb0001Mask & 0x80000) == 0 { // if not omitted
			// write "respSecsMax"
			err = en.Append(0xab, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespSecsMax)
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMax")
				return
			}
		}
		if (zb0001Mask & 0x100000) == 0 { // if not omitted
			// write "respTtfbSecsMin"
			err = en.Append(0xaf, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespTTFBSecsMin)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMin")
				return
			}
		}
		if (zb0001Mask & 0x200000) == 0 { // if not omitted
			// write "respTtfbSecsMax"
			err = en.Append(0xaf, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespTTFBSecsMax)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMax")
				return
			}
		}
		// write "rejected"
		err = en.Append(0xa8, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = z.Rejected.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Rejected")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *APIStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(23)
	var zb0001Mask uint32 /* 23 bits */
	_ = zb0001Mask
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.StartTime == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.EndTime == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.WallTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Requests == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Errors4xx == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Errors5xx == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Canceled == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RequestTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.ReqReadSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.RespSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.RespTTFBSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.RequestTimeSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.RequestTimeSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.ReqReadSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.ReqReadSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.RespSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.RespSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.RespTTFBSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x100000
	}
	if z.RespTTFBSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x200000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "nodes"
			o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			o = msgp.AppendInt(o, z.Nodes)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "startTime"
			o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if z.StartTime == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendTime(o, *z.StartTime)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "endTime"
			o = append(o, 0xa7, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
			if z.EndTime == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendTime(o, *z.EndTime)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "wallTimeSecs"
			o = append(o, 0xac, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.WallTimeSecs)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "requests"
			o = append(o, 0xa8, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			o = msgp.AppendInt64(o, z.Requests)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "incomingBytes"
			o = append(o, 0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.IncomingBytes)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "outgoingBytes"
			o = append(o, 0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.OutgoingBytes)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "errors_4xx"
			o = append(o, 0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x5f, 0x34, 0x78, 0x78)
			o = msgp.AppendInt(o, z.Errors4xx)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "errors_5xx"
			o = append(o, 0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x5f, 0x35, 0x78, 0x78)
			o = msgp.AppendInt(o, z.Errors5xx)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "canceled"
			o = append(o, 0xa8, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x65, 0x64)
			o = msgp.AppendInt64(o, z.Canceled)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "requestTimeSecs"
			o = append(o, 0xaf, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.RequestTimeSecs)
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "reqReadSecs"
			o = append(o, 0xab, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.ReqReadSecs)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "respSecs"
			o = append(o, 0xa8, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.RespSecs)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "respTtfbSecs"
			o = append(o, 0xac, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.RespTTFBSecs)
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "requestTimeSecsMin"
			o = append(o, 0xb2, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			o = msgp.AppendFloat64(o, z.RequestTimeSecsMin)
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "requestTimeSecsMax"
			o = append(o, 0xb2, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			o = msgp.AppendFloat64(o, z.RequestTimeSecsMax)
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "reqReadSecsMin"
			o = append(o, 0xae, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			o = msgp.AppendFloat64(o, z.ReqReadSecsMin)
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// string "reqReadSecsMax"
			o = append(o, 0xae, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			o = msgp.AppendFloat64(o, z.ReqReadSecsMax)
		}
		if (zb0001Mask & 0x40000) == 0 { // if not omitted
			// string "respSecsMin"
			o = append(o, 0xab, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			o = msgp.AppendFloat64(o, z.RespSecsMin)
		}
		if (zb0001Mask & 0x80000) == 0 { // if not omitted
			// string "respSecsMax"
			o = append(o, 0xab, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			o = msgp.AppendFloat64(o, z.RespSecsMax)
		}
		if (zb0001Mask & 0x100000) == 0 { // if not omitted
			// string "respTtfbSecsMin"
			o = append(o, 0xaf, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			o = msgp.AppendFloat64(o, z.RespTTFBSecsMin)
		}
		if (zb0001Mask & 0x200000) == 0 { // if not omitted
			// string "respTtfbSecsMax"
			o = append(o, 0xaf, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			o = msgp.AppendFloat64(o, z.RespTTFBSecsMax)
		}
		// string "rejected"
		o = append(o, 0xa8, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64)
		o, err = z.Rejected.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Rejected")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *APIStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 23 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StartTime = nil
			} else {
				if z.StartTime == nil {
					z.StartTime = new(time.Time)
				}
				*z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
			zb0001Mask |= 0x2
		case "endTime":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EndTime = nil
			} else {
				if z.EndTime == nil {
					z.EndTime = new(time.Time)
				}
				*z.EndTime, bts, err = msgp.ReadTimeUTCBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
			zb0001Mask |= 0x4
		case "wallTimeSecs":
			z.WallTimeSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
			zb0001Mask |= 0x8
		case "requests":
			z.Requests, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
			zb0001Mask |= 0x10
		case "incomingBytes":
			z.IncomingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x20
		case "outgoingBytes":
			z.OutgoingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x40
		case "errors_4xx":
			z.Errors4xx, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors4xx")
				return
			}
			zb0001Mask |= 0x80
		case "errors_5xx":
			z.Errors5xx, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors5xx")
				return
			}
			zb0001Mask |= 0x100
		case "canceled":
			z.Canceled, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Canceled")
				return
			}
			zb0001Mask |= 0x200
		case "requestTimeSecs":
			z.RequestTimeSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
			zb0001Mask |= 0x400
		case "reqReadSecs":
			z.ReqReadSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecs")
				return
			}
			zb0001Mask |= 0x800
		case "respSecs":
			z.RespSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespSecs")
				return
			}
			zb0001Mask |= 0x1000
		case "respTtfbSecs":
			z.RespTTFBSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecs")
				return
			}
			zb0001Mask |= 0x2000
		case "requestTimeSecsMin":
			z.RequestTimeSecsMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMin")
				return
			}
			zb0001Mask |= 0x4000
		case "requestTimeSecsMax":
			z.RequestTimeSecsMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMax")
				return
			}
			zb0001Mask |= 0x8000
		case "reqReadSecsMin":
			z.ReqReadSecsMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMin")
				return
			}
			zb0001Mask |= 0x10000
		case "reqReadSecsMax":
			z.ReqReadSecsMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMax")
				return
			}
			zb0001Mask |= 0x20000
		case "respSecsMin":
			z.RespSecsMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMin")
				return
			}
			zb0001Mask |= 0x40000
		case "respSecsMax":
			z.RespSecsMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMax")
				return
			}
			zb0001Mask |= 0x80000
		case "respTtfbSecsMin":
			z.RespTTFBSecsMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMin")
				return
			}
			zb0001Mask |= 0x100000
		case "respTtfbSecsMax":
			z.RespTTFBSecsMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMax")
				return
			}
			zb0001Mask |= 0x200000
		case "rejected":
			bts, err = z.Rejected.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Rejected")
				return
			}
			zb0001Mask |= 0x400000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7fffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.StartTime = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.EndTime = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.WallTimeSecs = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Requests = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.OutgoingBytes = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Errors4xx = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Errors5xx = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Canceled = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.RequestTimeSecs = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReqReadSecs = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.RespSecs = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.RespTTFBSecs = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.RequestTimeSecsMin = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.RequestTimeSecsMax = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.ReqReadSecsMin = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.ReqReadSecsMax = 0
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.RespSecsMin = 0
		}
		if (zb0001Mask & 0x80000) == 0 {
			z.RespSecsMax = 0
		}
		if (zb0001Mask & 0x100000) == 0 {
			z.RespTTFBSecsMin = 0
		}
		if (zb0001Mask & 0x200000) == 0 {
			z.RespTTFBSecsMax = 0
		}
		if (zb0001Mask & 0x400000) == 0 {
			z.Rejected = RejectedAPIStats{}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *APIStats) Msgsize() (s int) {
	s = 3 + 6 + msgp.IntSize + 10
	if z.StartTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 8
	if z.EndTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 13 + msgp.Float64Size + 9 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 11 + msgp.IntSize + 11 + msgp.IntSize + 9 + msgp.Int64Size + 16 + msgp.Float64Size + 12 + msgp.Float64Size + 9 + msgp.Float64Size + 13 + msgp.Float64Size + 19 + msgp.Float64Size + 19 + msgp.Float64Size + 15 + msgp.Float64Size + 15 + msgp.Float64Size + 12 + msgp.Float64Size + 12 + msgp.Float64Size + 16 + msgp.Float64Size + 16 + msgp.Float64Size + 9 + z.Rejected.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BatchJobMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "Jobs":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Jobs")
				return
			}
			if z.Jobs == nil {
				z.Jobs = make(map[string]JobMetric, zb0002)
			} else if len(z.Jobs) > 0 {
				for key := range z.Jobs {
					delete(z.Jobs, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 JobMetric
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Jobs")
					return
				}
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Jobs", za0001)
					return
				}
				z.Jobs[za0001] = za0002
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BatchJobMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "collected"
	err = en.Append(0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "Jobs"
	err = en.Append(0xa4, 0x4a, 0x6f, 0x62, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Jobs)))
	if err != nil {
		err = msgp.WrapError(err, "Jobs")
		return
	}
	for za0001, za0002 := range z.Jobs {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Jobs")
			return
		}
		err = za0002.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Jobs", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BatchJobMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "collected"
	o = append(o, 0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "Jobs"
	o = append(o, 0xa4, 0x4a, 0x6f, 0x62, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Jobs)))
	for za0001, za0002 := range z.Jobs {
		o = msgp.AppendString(o, za0001)
		o, err = za0002.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Jobs", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BatchJobMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "Jobs":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Jobs")
				return
			}
			if z.Jobs == nil {
				z.Jobs = make(map[string]JobMetric, zb0002)
			} else if len(z.Jobs) > 0 {
				for key := range z.Jobs {
					delete(z.Jobs, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 JobMetric
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Jobs")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Jobs", za0001)
					return
				}
				z.Jobs[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BatchJobMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 5 + msgp.MapHeaderSize
	if z.Jobs != nil {
		for za0001, za0002 := range z.Jobs {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CPUMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "timesStat":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
				z.TimesStat = nil
			} else {
				if z.TimesStat == nil {
					z.TimesStat = new(cpu.TimesStat)
				}
				err = (*cpuTimesStat)(z.TimesStat).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
			}
		case "loadStat":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
				z.LoadStat = nil
			} else {
				if z.LoadStat == nil {
					z.LoadStat = new(load.AvgStat)
				}
				err = (*loadAvgStat)(z.LoadStat).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
			}
		case "cpuCount":
			z.CPUCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CPUCount")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CPUMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "collected"
	err = en.Append(0x84, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "timesStat"
	err = en.Append(0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74)
	if err != nil {
		return
	}
	if z.TimesStat == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = (*cpuTimesStat)(z.TimesStat).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "TimesStat")
			return
		}
	}
	// write "loadStat"
	err = en.Append(0xa8, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74)
	if err != nil {
		return
	}
	if z.LoadStat == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = (*loadAvgStat)(z.LoadStat).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "LoadStat")
			return
		}
	}
	// write "cpuCount"
	err = en.Append(0xa8, 0x63, 0x70, 0x75, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CPUCount)
	if err != nil {
		err = msgp.WrapError(err, "CPUCount")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CPUMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "collected"
	o = append(o, 0x84, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "timesStat"
	o = append(o, 0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74)
	if z.TimesStat == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = (*cpuTimesStat)(z.TimesStat).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "TimesStat")
			return
		}
	}
	// string "loadStat"
	o = append(o, 0xa8, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74)
	if z.LoadStat == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = (*loadAvgStat)(z.LoadStat).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LoadStat")
			return
		}
	}
	// string "cpuCount"
	o = append(o, 0xa8, 0x63, 0x70, 0x75, 0x43, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.CPUCount)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CPUMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "timesStat":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TimesStat = nil
			} else {
				if z.TimesStat == nil {
					z.TimesStat = new(cpu.TimesStat)
				}
				bts, err = (*cpuTimesStat)(z.TimesStat).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
			}
		case "loadStat":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LoadStat = nil
			} else {
				if z.LoadStat == nil {
					z.LoadStat = new(load.AvgStat)
				}
				bts, err = (*loadAvgStat)(z.LoadStat).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
			}
		case "cpuCount":
			z.CPUCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CPUCount")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CPUMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 10
	if z.TimesStat == nil {
		s += msgp.NilSize
	} else {
		s += (*cpuTimesStat)(z.TimesStat).Msgsize()
	}
	s += 9
	if z.LoadStat == nil {
		s += msgp.NilSize
	} else {
		s += (*loadAvgStat)(z.LoadStat).Msgsize()
	}
	s += 9 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CatalogInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastBucketScanned":
			z.LastBucketScanned, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastBucketScanned")
				return
			}
			zb0001Mask |= 0x1
		case "lastObjectScanned":
			z.LastObjectScanned, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastObjectScanned")
				return
			}
		case "lastBucketMatched":
			z.LastBucketMatched, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastBucketMatched")
				return
			}
			zb0001Mask |= 0x2
		case "lastObjectMatched":
			z.LastObjectMatched, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastObjectMatched")
				return
			}
		case "objectsScannedCount":
			z.ObjectsScannedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsScannedCount")
				return
			}
		case "objectsMatchedCount":
			z.ObjectsMatchedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsMatchedCount")
				return
			}
		case "recordsWrittenCount":
			z.RecordsWrittenCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RecordsWrittenCount")
				return
			}
		case "outputObjectsCount":
			z.OutputObjectsCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "OutputObjectsCount")
				return
			}
		case "manifestPathBucket":
			z.ManifestPathBucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathBucket")
				return
			}
		case "manifestPathObject":
			z.ManifestPathObject, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathObject")
				return
			}
		case "errorMsg":
			z.ErrorMsg, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ErrorMsg")
				return
			}
		case "lastObjectWritten":
			z.LastObjectWritten, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastObjectWritten")
				return
			}
			zb0001Mask |= 0x4
		case "outputFiles":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OutputFiles")
				return
			}
			if cap(z.OutputFiles) >= int(zb0002) {
				z.OutputFiles = (z.OutputFiles)[:zb0002]
			} else {
				z.OutputFiles = make([]CatalogDataFile, zb0002)
			}
			for za0001 := range z.OutputFiles {
				err = z.OutputFiles[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OutputFiles", za0001)
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.LastBucketScanned = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LastBucketMatched = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LastObjectWritten = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.OutputFiles = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CatalogInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.LastBucketScanned == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.LastBucketMatched == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LastObjectWritten == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.OutputFiles == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "bucket"
		err = en.Append(0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Bucket)
		if err != nil {
			err = msgp.WrapError(err, "Bucket")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "lastBucketScanned"
			err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteString(z.LastBucketScanned)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketScanned")
				return
			}
		}
		// write "lastObjectScanned"
		err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.LastObjectScanned)
		if err != nil {
			err = msgp.WrapError(err, "LastObjectScanned")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "lastBucketMatched"
			err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteString(z.LastBucketMatched)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketMatched")
				return
			}
		}
		// write "lastObjectMatched"
		err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.LastObjectMatched)
		if err != nil {
			err = msgp.WrapError(err, "LastObjectMatched")
			return
		}
		// write "objectsScannedCount"
		err = en.Append(0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.ObjectsScannedCount)
		if err != nil {
			err = msgp.WrapError(err, "ObjectsScannedCount")
			return
		}
		// write "objectsMatchedCount"
		err = en.Append(0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.ObjectsMatchedCount)
		if err != nil {
			err = msgp.WrapError(err, "ObjectsMatchedCount")
			return
		}
		// write "recordsWrittenCount"
		err = en.Append(0xb3, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.RecordsWrittenCount)
		if err != nil {
			err = msgp.WrapError(err, "RecordsWrittenCount")
			return
		}
		// write "outputObjectsCount"
		err = en.Append(0xb2, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.OutputObjectsCount)
		if err != nil {
			err = msgp.WrapError(err, "OutputObjectsCount")
			return
		}
		// write "manifestPathBucket"
		err = en.Append(0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.ManifestPathBucket)
		if err != nil {
			err = msgp.WrapError(err, "ManifestPathBucket")
			return
		}
		// write "manifestPathObject"
		err = en.Append(0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.ManifestPathObject)
		if err != nil {
			err = msgp.WrapError(err, "ManifestPathObject")
			return
		}
		// write "errorMsg"
		err = en.Append(0xa8, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x73, 0x67)
		if err != nil {
			return
		}
		err = en.WriteString(z.ErrorMsg)
		if err != nil {
			err = msgp.WrapError(err, "ErrorMsg")
			return
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "lastObjectWritten"
			err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteString(z.LastObjectWritten)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectWritten")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "outputFiles"
			err = en.Append(0xab, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.OutputFiles)))
			if err != nil {
				err = msgp.WrapError(err, "OutputFiles")
				return
			}
			for za0001 := range z.OutputFiles {
				err = z.OutputFiles[za0001].EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "OutputFiles", za0001)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CatalogInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.LastBucketScanned == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.LastBucketMatched == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LastObjectWritten == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.OutputFiles == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "bucket"
		o = append(o, 0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
		o = msgp.AppendString(o, z.Bucket)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "lastBucketScanned"
			o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
			o = msgp.AppendString(o, z.LastBucketScanned)
		}
		// string "lastObjectScanned"
		o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
		o = msgp.AppendString(o, z.LastObjectScanned)
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "lastBucketMatched"
			o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
			o = msgp.AppendString(o, z.LastBucketMatched)
		}
		// string "lastObjectMatched"
		o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
		o = msgp.AppendString(o, z.LastObjectMatched)
		// string "objectsScannedCount"
		o = append(o, 0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.ObjectsScannedCount)
		// string "objectsMatchedCount"
		o = append(o, 0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.ObjectsMatchedCount)
		// string "recordsWrittenCount"
		o = append(o, 0xb3, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.RecordsWrittenCount)
		// string "outputObjectsCount"
		o = append(o, 0xb2, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.OutputObjectsCount)
		// string "manifestPathBucket"
		o = append(o, 0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
		o = msgp.AppendString(o, z.ManifestPathBucket)
		// string "manifestPathObject"
		o = append(o, 0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
		o = msgp.AppendString(o, z.ManifestPathObject)
		// string "errorMsg"
		o = append(o, 0xa8, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x73, 0x67)
		o = msgp.AppendString(o, z.ErrorMsg)
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "lastObjectWritten"
			o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e)
			o = msgp.AppendString(o, z.LastObjectWritten)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "outputFiles"
			o = append(o, 0xab, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.OutputFiles)))
			for za0001 := range z.OutputFiles {
				o, err = z.OutputFiles[za0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "OutputFiles", za0001)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CatalogInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastBucketScanned":
			z.LastBucketScanned, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketScanned")
				return
			}
			zb0001Mask |= 0x1
		case "lastObjectScanned":
			z.LastObjectScanned, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectScanned")
				return
			}
		case "lastBucketMatched":
			z.LastBucketMatched, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketMatched")
				return
			}
			zb0001Mask |= 0x2
		case "lastObjectMatched":
			z.LastObjectMatched, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectMatched")
				return
			}
		case "objectsScannedCount":
			z.ObjectsScannedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsScannedCount")
				return
			}
		case "objectsMatchedCount":
			z.ObjectsMatchedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsMatchedCount")
				return
			}
		case "recordsWrittenCount":
			z.RecordsWrittenCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RecordsWrittenCount")
				return
			}
		case "outputObjectsCount":
			z.OutputObjectsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutputObjectsCount")
				return
			}
		case "manifestPathBucket":
			z.ManifestPathBucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathBucket")
				return
			}
		case "manifestPathObject":
			z.ManifestPathObject, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathObject")
				return
			}
		case "errorMsg":
			z.ErrorMsg, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ErrorMsg")
				return
			}
		case "lastObjectWritten":
			z.LastObjectWritten, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectWritten")
				return
			}
			zb0001Mask |= 0x4
		case "outputFiles":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutputFiles")
				return
			}
			if cap(z.OutputFiles) >= int(zb0002) {
				z.OutputFiles = (z.OutputFiles)[:zb0002]
			} else {
				z.OutputFiles = make([]CatalogDataFile, zb0002)
			}
			for za0001 := range z.OutputFiles {
				bts, err = z.OutputFiles[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OutputFiles", za0001)
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.LastBucketScanned = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LastBucketMatched = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LastObjectWritten = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.OutputFiles = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CatalogInfo) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Bucket) + 18 + msgp.StringPrefixSize + len(z.LastBucketScanned) + 18 + msgp.StringPrefixSize + len(z.LastObjectScanned) + 18 + msgp.StringPrefixSize + len(z.LastBucketMatched) + 18 + msgp.StringPrefixSize + len(z.LastObjectMatched) + 20 + msgp.Uint64Size + 20 + msgp.Uint64Size + 20 + msgp.Uint64Size + 19 + msgp.Uint64Size + 19 + msgp.StringPrefixSize + len(z.ManifestPathBucket) + 19 + msgp.StringPrefixSize + len(z.ManifestPathObject) + 9 + msgp.StringPrefixSize + len(z.ErrorMsg) + 18 + msgp.StringPrefixSize + len(z.LastObjectWritten) + 12 + msgp.ArrayHeaderSize
	for za0001 := range z.OutputFiles {
		s += z.OutputFiles[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DiskIOStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "read_ios":
			z.ReadIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
			zb0001Mask |= 0x1
		case "read_merges":
			z.ReadMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
			zb0001Mask |= 0x2
		case "read_sectors":
			z.ReadSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
			zb0001Mask |= 0x4
		case "read_ticks":
			z.ReadTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
			zb0001Mask |= 0x8
		case "write_ios":
			z.WriteIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
			zb0001Mask |= 0x10
		case "write_merges":
			z.WriteMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
			zb0001Mask |= 0x20
		case "wrte_sectors":
			z.WriteSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
			zb0001Mask |= 0x40
		case "write_ticks":
			z.WriteTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
			zb0001Mask |= 0x80
		case "current_ios":
			z.CurrentIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
			zb0001Mask |= 0x100
		case "total_ticks":
			z.TotalTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
			zb0001Mask |= 0x200
		case "req_ticks":
			z.ReqTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
			zb0001Mask |= 0x400
		case "discard_ios":
			z.DiscardIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
			zb0001Mask |= 0x800
		case "discard_merges":
			z.DiscardMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
			zb0001Mask |= 0x1000
		case "discard_secotrs":
			z.DiscardSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
			zb0001Mask |= 0x2000
		case "discard_ticks":
			z.DiscardTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
			zb0001Mask |= 0x4000
		case "flush_ios":
			z.FlushIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
			zb0001Mask |= 0x8000
		case "flush_ticks":
			z.FlushTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
			zb0001Mask |= 0x10000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.ReadIOs = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ReadMerges = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReadSectors = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ReadTicks = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.WriteIOs = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.WriteMerges = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.WriteSectors = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.WriteTicks = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.CurrentIOs = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.TotalTicks = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.ReqTicks = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.DiscardIOs = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.DiscardMerges = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.DiscardSectors = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.DiscardTicks = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.FlushIOs = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.FlushTicks = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DiskIOStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.ReadIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ReadMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReadSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ReadTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.WriteIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.WriteMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.WriteSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.WriteTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.CurrentIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.TotalTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.ReqTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.DiscardIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.DiscardMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.DiscardSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.DiscardTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.FlushIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.FlushTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "read_ios"
			err = en.Append(0xa8, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadIOs)
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "read_merges"
			err = en.Append(0xab, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadMerges)
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "read_sectors"
			err = en.Append(0xac, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadSectors)
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "read_ticks"
			err = en.Append(0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadTicks)
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "write_ios"
			err = en.Append(0xa9, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteIOs)
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "write_merges"
			err = en.Append(0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteMerges)
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "wrte_sectors"
			err = en.Append(0xac, 0x77, 0x72, 0x74, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteSectors)
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "write_ticks"
			err = en.Append(0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteTicks)
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "current_ios"
			err = en.Append(0xab, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.CurrentIOs)
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "total_ticks"
			err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalTicks)
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "req_ticks"
			err = en.Append(0xa9, 0x72, 0x65, 0x71, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReqTicks)
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "discard_ios"
			err = en.Append(0xab, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardIOs)
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "discard_merges"
			err = en.Append(0xae, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardMerges)
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "discard_secotrs"
			err = en.Append(0xaf, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x74, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardSectors)
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "discard_ticks"
			err = en.Append(0xad, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardTicks)
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "flush_ios"
			err = en.Append(0xa9, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.FlushIOs)
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "flush_ticks"
			err = en.Append(0xab, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.FlushTicks)
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DiskIOStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.ReadIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ReadMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReadSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ReadTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.WriteIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.WriteMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.WriteSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.WriteTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.CurrentIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.TotalTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.ReqTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.DiscardIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.DiscardMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.DiscardSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.DiscardTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.FlushIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.FlushTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "read_ios"
			o = append(o, 0xa8, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.ReadIOs)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "read_merges"
			o = append(o, 0xab, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.ReadMerges)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "read_sectors"
			o = append(o, 0xac, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.ReadSectors)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "read_ticks"
			o = append(o, 0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.ReadTicks)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "write_ios"
			o = append(o, 0xa9, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.WriteIOs)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "write_merges"
			o = append(o, 0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.WriteMerges)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "wrte_sectors"
			o = append(o, 0xac, 0x77, 0x72, 0x74, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.WriteSectors)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "write_ticks"
			o = append(o, 0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.WriteTicks)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "current_ios"
			o = append(o, 0xab, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.CurrentIOs)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "total_ticks"
			o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.TotalTicks)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "req_ticks"
			o = append(o, 0xa9, 0x72, 0x65, 0x71, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.ReqTicks)
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "discard_ios"
			o = append(o, 0xab, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.DiscardIOs)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "discard_merges"
			o = append(o, 0xae, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.DiscardMerges)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "discard_secotrs"
			o = append(o, 0xaf, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x74, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.DiscardSectors)
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "discard_ticks"
			o = append(o, 0xad, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.DiscardTicks)
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "flush_ios"
			o = append(o, 0xa9, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.FlushIOs)
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "flush_ticks"
			o = append(o, 0xab, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.FlushTicks)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DiskIOStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "read_ios":
			z.ReadIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
			zb0001Mask |= 0x1
		case "read_merges":
			z.ReadMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
			zb0001Mask |= 0x2
		case "read_sectors":
			z.ReadSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
			zb0001Mask |= 0x4
		case "read_ticks":
			z.ReadTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
			zb0001Mask |= 0x8
		case "write_ios":
			z.WriteIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
			zb0001Mask |= 0x10
		case "write_merges":
			z.WriteMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
			zb0001Mask |= 0x20
		case "wrte_sectors":
			z.WriteSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
			zb0001Mask |= 0x40
		case "write_ticks":
			z.WriteTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
			zb0001Mask |= 0x80
		case "current_ios":
			z.CurrentIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
			zb0001Mask |= 0x100
		case "total_ticks":
			z.TotalTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
			zb0001Mask |= 0x200
		case "req_ticks":
			z.ReqTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
			zb0001Mask |= 0x400
		case "discard_ios":
			z.DiscardIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
			zb0001Mask |= 0x800
		case "discard_merges":
			z.DiscardMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
			zb0001Mask |= 0x1000
		case "discard_secotrs":
			z.DiscardSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
			zb0001Mask |= 0x2000
		case "discard_ticks":
			z.DiscardTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
			zb0001Mask |= 0x4000
		case "flush_ios":
			z.FlushIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
			zb0001Mask |= 0x8000
		case "flush_ticks":
			z.FlushTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
			zb0001Mask |= 0x10000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.ReadIOs = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ReadMerges = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReadSectors = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ReadTicks = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.WriteIOs = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.WriteMerges = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.WriteSectors = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.WriteTicks = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.CurrentIOs = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.TotalTicks = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.ReqTicks = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.DiscardIOs = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.DiscardMerges = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.DiscardSectors = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.DiscardTicks = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.FlushIOs = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.FlushTicks = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DiskIOStats) Msgsize() (s int) {
	s = 3 + 9 + msgp.Uint64Size + 12 + msgp.Uint64Size + 13 + msgp.Uint64Size + 11 + msgp.Uint64Size + 10 + msgp.Uint64Size + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 10 + msgp.Uint64Size + 12 + msgp.Uint64Size + 15 + msgp.Uint64Size + 16 + msgp.Uint64Size + 14 + msgp.Uint64Size + 10 + msgp.Uint64Size + 12 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DiskMetric) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "n_disks":
			z.NDisks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NDisks")
				return
			}
		case "set_idx":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SetIdx")
					return
				}
				z.SetIdx = nil
			} else {
				if z.SetIdx == nil {
					z.SetIdx = new(int)
				}
				*z.SetIdx, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SetIdx")
					return
				}
			}
			zb0001Mask |= 0x1
		case "pool_idx":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx")
					return
				}
				z.PoolIdx = nil
			} else {
				if z.PoolIdx == nil {
					z.PoolIdx = new(int)
				}
				*z.PoolIdx, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx")
					return
				}
			}
			zb0001Mask |= 0x2
		case "offline":
			z.Offline, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
			zb0001Mask |= 0x4
		case "healing":
			z.Healing, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
			zb0001Mask |= 0x8
		case "life_time_ops":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 uint64
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x10
		case "last_minute":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						for key := range z.LastMinute.Operations {
							delete(z.LastMinute.Operations, key)
						}
					}
					for zb0004 > 0 {
						zb0004--
						var za0003 string
						var za0004 TimedAction
						za0003, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						err = za0004.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		case "iostats":
			err = z.IOStats.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "IOStats")
				return
			}
			zb0001Mask |= 0x20
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3f {
		if (zb0001Mask & 0x1) == 0 {
			z.SetIdx = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.PoolIdx = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Offline = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Healing = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IOStats = DiskIOStats{}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DiskMetric) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.SetIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.PoolIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Offline == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Healing == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "n_disks"
		err = en.Append(0xa7, 0x6e, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.NDisks)
		if err != nil {
			err = msgp.WrapError(err, "NDisks")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "set_idx"
			err = en.Append(0xa7, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x78)
			if err != nil {
				return
			}
			if z.SetIdx == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteInt(*z.SetIdx)
				if err != nil {
					err = msgp.WrapError(err, "SetIdx")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "pool_idx"
			err = en.Append(0xa8, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x78)
			if err != nil {
				return
			}
			if z.PoolIdx == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteInt(*z.PoolIdx)
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx")
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "offline"
			err = en.Append(0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Offline)
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "healing"
			err = en.Append(0xa7, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Healing)
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "life_time_ops"
			err = en.Append(0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			for za0001, za0002 := range z.LifeTimeOps {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				err = en.WriteUint64(za0002)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
			}
		}
		// write "last_minute"
		err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// write "operations"
			err = en.Append(0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinute.Operations)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinute", "Operations")
				return
			}
			for za0003, za0004 := range z.LastMinute.Operations {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
		// write "iostats"
		err = en.Append(0xa7, 0x69, 0x6f, 0x73, 0x74, 0x61, 0x74, 0x73)
		if err != nil {
			return
		}
		err = z.IOStats.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "IOStats")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DiskMetric) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.SetIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.PoolIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Offline == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Healing == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "n_disks"
		o = append(o, 0xa7, 0x6e, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x73)
		o = msgp.AppendInt(o, z.NDisks)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "set_idx"
			o = append(o, 0xa7, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x78)
			if z.SetIdx == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendInt(o, *z.SetIdx)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "pool_idx"
			o = append(o, 0xa8, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x78)
			if z.PoolIdx == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendInt(o, *z.PoolIdx)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "offline"
			o = append(o, 0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
			o = msgp.AppendInt(o, z.Offline)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "healing"
			o = append(o, 0xa7, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67)
			o = msgp.AppendInt(o, z.Healing)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "life_time_ops"
			o = append(o, 0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeOps)))
			for za0001, za0002 := range z.LifeTimeOps {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendUint64(o, za0002)
			}
		}
		// string "last_minute"
		o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// string "operations"
			o = append(o, 0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.Operations)))
			for za0003, za0004 := range z.LastMinute.Operations {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
		// string "iostats"
		o = append(o, 0xa7, 0x69, 0x6f, 0x73, 0x74, 0x61, 0x74, 0x73)
		o, err = z.IOStats.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "IOStats")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DiskMetric) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 6 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "n_disks":
			z.NDisks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NDisks")
				return
			}
		case "set_idx":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SetIdx = nil
			} else {
				if z.SetIdx == nil {
					z.SetIdx = new(int)
				}
				*z.SetIdx, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SetIdx")
					return
				}
			}
			zb0001Mask |= 0x1
		case "pool_idx":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PoolIdx = nil
			} else {
				if z.PoolIdx == nil {
					z.PoolIdx = new(int)
				}
				*z.PoolIdx, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx")
					return
				}
			}
			zb0001Mask |= 0x2
		case "offline":
			z.Offline, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
			zb0001Mask |= 0x4
		case "healing":
			z.Healing, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
			zb0001Mask |= 0x8
		case "life_time_ops":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 uint64
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x10
		case "last_minute":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						for key := range z.LastMinute.Operations {
							delete(z.LastMinute.Operations, key)
						}
					}
					for zb0004 > 0 {
						var za0003 string
						var za0004 TimedAction
						zb0004--
						za0003, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						bts, err = za0004.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		case "iostats":
			bts, err = z.IOStats.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "IOStats")
				return
			}
			zb0001Mask |= 0x20
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3f {
		if (zb0001Mask & 0x1) == 0 {
			z.SetIdx = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.PoolIdx = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Offline = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Healing = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IOStats = DiskIOStats{}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DiskMetric) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 8 + msgp.IntSize + 8
	if z.SetIdx == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 9
	if z.PoolIdx == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 8 + msgp.IntSize + 8 + msgp.IntSize + 14 + msgp.MapHeaderSize
	if z.LifeTimeOps != nil {
		for za0001, za0002 := range z.LifeTimeOps {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 12 + 1 + 11 + msgp.MapHeaderSize
	if z.LastMinute.Operations != nil {
		for za0003, za0004 := range z.LastMinute.Operations {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += 8 + z.IOStats.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ExpirationInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ExpirationInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "lastBucket"
	err = en.Append(0x86, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	// write "deleteMarkers"
	err = en.Append(0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkers)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkers")
		return
	}
	// write "deleteMarkersFailed"
	err = en.Append(0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkersFailed)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkersFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ExpirationInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "lastBucket"
	o = append(o, 0x86, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	// string "deleteMarkers"
	o = append(o, 0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	o = msgp.AppendInt64(o, z.DeleteMarkers)
	// string "deleteMarkersFailed"
	o = append(o, 0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.DeleteMarkersFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ExpirationInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ExpirationInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 20 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *JobMetric) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "jobID":
			z.JobID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "JobID")
				return
			}
		case "jobType":
			z.JobType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "JobType")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retryAttempts":
			z.RetryAttempts, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "complete":
			z.Complete, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Complete")
				return
			}
		case "failed":
			z.Failed, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Failed")
				return
			}
		case "status":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "replicate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
				z.Replicate = nil
			} else {
				if z.Replicate == nil {
					z.Replicate = new(ReplicateInfo)
				}
				err = z.Replicate.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
			zb0001Mask |= 0x1
		case "rotation":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
				z.KeyRotate = nil
			} else {
				if z.KeyRotate == nil {
					z.KeyRotate = new(KeyRotationInfo)
				}
				err = z.KeyRotate.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
			zb0001Mask |= 0x2
		case "expired":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
				z.Expired = nil
			} else {
				if z.Expired == nil {
					z.Expired = new(ExpirationInfo)
				}
				err = z.Expired.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
			zb0001Mask |= 0x4
		case "catalog":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
				z.Catalog = nil
			} else {
				if z.Catalog == nil {
					z.Catalog = new(CatalogInfo)
				}
				err = z.Catalog.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Replicate = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.KeyRotate = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Expired = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Catalog = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *JobMetric) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(12)
	var zb0001Mask uint16 /* 12 bits */
	_ = zb0001Mask
	if z.Replicate == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.KeyRotate == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Expired == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.Catalog == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "jobID"
		err = en.Append(0xa5, 0x6a, 0x6f, 0x62, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.JobID)
		if err != nil {
			err = msgp.WrapError(err, "JobID")
			return
		}
		// write "jobType"
		err = en.Append(0xa7, 0x6a, 0x6f, 0x62, 0x54, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.JobType)
		if err != nil {
			err = msgp.WrapError(err, "JobType")
			return
		}
		// write "startTime"
		err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.StartTime)
		if err != nil {
			err = msgp.WrapError(err, "StartTime")
			return
		}
		// write "lastUpdate"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastUpdate)
		if err != nil {
			err = msgp.WrapError(err, "LastUpdate")
			return
		}
		// write "retryAttempts"
		err = en.Append(0xad, 0x72, 0x65, 0x74, 0x72, 0x79, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.RetryAttempts)
		if err != nil {
			err = msgp.WrapError(err, "RetryAttempts")
			return
		}
		// write "complete"
		err = en.Append(0xa8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Complete)
		if err != nil {
			err = msgp.WrapError(err, "Complete")
			return
		}
		// write "failed"
		err = en.Append(0xa6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Failed)
		if err != nil {
			err = msgp.WrapError(err, "Failed")
			return
		}
		// write "status"
		err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		if err != nil {
			return
		}
		err = en.WriteString(z.Status)
		if err != nil {
			err = msgp.WrapError(err, "Status")
			return
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "replicate"
			err = en.Append(0xa9, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65)
			if err != nil {
				return
			}
			if z.Replicate == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Replicate.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "rotation"
			err = en.Append(0xa8, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if err != nil {
				return
			}
			if z.KeyRotate == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.KeyRotate.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "expired"
			err = en.Append(0xa7, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64)
			if err != nil {
				return
			}
			if z.Expired == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Expired.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "catalog"
			err = en.Append(0xa7, 0x63, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67)
			if err != nil {
				return
			}
			if z.Catalog == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Catalog.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *JobMetric) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(12)
	var zb0001Mask uint16 /* 12 bits */
	_ = zb0001Mask
	if z.Replicate == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.KeyRotate == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Expired == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.Catalog == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "jobID"
		o = append(o, 0xa5, 0x6a, 0x6f, 0x62, 0x49, 0x44)
		o = msgp.AppendString(o, z.JobID)
		// string "jobType"
		o = append(o, 0xa7, 0x6a, 0x6f, 0x62, 0x54, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.JobType)
		// string "startTime"
		o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.StartTime)
		// string "lastUpdate"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		o = msgp.AppendTime(o, z.LastUpdate)
		// string "retryAttempts"
		o = append(o, 0xad, 0x72, 0x65, 0x74, 0x72, 0x79, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
		o = msgp.AppendInt(o, z.RetryAttempts)
		// string "complete"
		o = append(o, 0xa8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65)
		o = msgp.AppendBool(o, z.Complete)
		// string "failed"
		o = append(o, 0xa6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
		o = msgp.AppendBool(o, z.Failed)
		// string "status"
		o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		o = msgp.AppendString(o, z.Status)
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "replicate"
			o = append(o, 0xa9, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65)
			if z.Replicate == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Replicate.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "rotation"
			o = append(o, 0xa8, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if z.KeyRotate == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.KeyRotate.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "expired"
			o = append(o, 0xa7, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64)
			if z.Expired == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Expired.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "catalog"
			o = append(o, 0xa7, 0x63, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67)
			if z.Catalog == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Catalog.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *JobMetric) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "jobID":
			z.JobID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "JobID")
				return
			}
		case "jobType":
			z.JobType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "JobType")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retryAttempts":
			z.RetryAttempts, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "complete":
			z.Complete, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Complete")
				return
			}
		case "failed":
			z.Failed, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Failed")
				return
			}
		case "status":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "replicate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Replicate = nil
			} else {
				if z.Replicate == nil {
					z.Replicate = new(ReplicateInfo)
				}
				bts, err = z.Replicate.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
			zb0001Mask |= 0x1
		case "rotation":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.KeyRotate = nil
			} else {
				if z.KeyRotate == nil {
					z.KeyRotate = new(KeyRotationInfo)
				}
				bts, err = z.KeyRotate.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
			zb0001Mask |= 0x2
		case "expired":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Expired = nil
			} else {
				if z.Expired == nil {
					z.Expired = new(ExpirationInfo)
				}
				bts, err = z.Expired.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
			zb0001Mask |= 0x4
		case "catalog":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Catalog = nil
			} else {
				if z.Catalog == nil {
					z.Catalog = new(CatalogInfo)
				}
				bts, err = z.Catalog.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Replicate = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.KeyRotate = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Expired = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Catalog = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *JobMetric) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.JobID) + 8 + msgp.StringPrefixSize + len(z.JobType) + 10 + msgp.TimeSize + 11 + msgp.TimeSize + 14 + msgp.IntSize + 9 + msgp.BoolSize + 7 + msgp.BoolSize + 7 + msgp.StringPrefixSize + len(z.Status) + 10
	if z.Replicate == nil {
		s += msgp.NilSize
	} else {
		s += z.Replicate.Msgsize()
	}
	s += 9
	if z.KeyRotate == nil {
		s += msgp.NilSize
	} else {
		s += z.KeyRotate.Msgsize()
	}
	s += 8
	if z.Expired == nil {
		s += msgp.NilSize
	} else {
		s += z.Expired.Msgsize()
	}
	s += 8
	if z.Catalog == nil {
		s += msgp.NilSize
	} else {
		s += z.Catalog.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *KeyRotationInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *KeyRotationInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "lastBucket"
	err = en.Append(0x84, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *KeyRotationInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "lastBucket"
	o = append(o, 0x84, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *KeyRotationInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *KeyRotationInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MemInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "NodeCommon":
			err = (*nodeCommon)(&z.NodeCommon).DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "NodeCommon")
				return
			}
		case "total":
			z.Total, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
			zb0001Mask |= 0x1
		case "used":
			z.Used, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
			zb0001Mask |= 0x2
		case "free":
			z.Free, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
			zb0001Mask |= 0x4
		case "available":
			z.Available, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
			zb0001Mask |= 0x8
		case "shared":
			z.Shared, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
			zb0001Mask |= 0x10
		case "cache":
			z.Cache, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
			zb0001Mask |= 0x20
		case "buffer":
			z.Buffers, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
			zb0001Mask |= 0x40
		case "swap_space_total":
			z.SwapSpaceTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
			zb0001Mask |= 0x80
		case "swap_space_free":
			z.SwapSpaceFree, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
			zb0001Mask |= 0x100
		case "limit":
			z.Limit, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
			zb0001Mask |= 0x200
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Total = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Used = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Free = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Available = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Shared = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Cache = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Buffers = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.SwapSpaceTotal = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.SwapSpaceFree = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Limit = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MemInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Total == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Used == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Free == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Available == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Shared == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Cache == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Buffers == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.SwapSpaceTotal == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.SwapSpaceFree == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Limit == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "NodeCommon"
		err = en.Append(0xaa, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = (*nodeCommon)(&z.NodeCommon).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "NodeCommon")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "total"
			err = en.Append(0xa5, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Total)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "used"
			err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Used)
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "free"
			err = en.Append(0xa4, 0x66, 0x72, 0x65, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Free)
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "available"
			err = en.Append(0xa9, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Available)
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "shared"
			err = en.Append(0xa6, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Shared)
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "cache"
			err = en.Append(0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Cache)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "buffer"
			err = en.Append(0xa6, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Buffers)
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "swap_space_total"
			err = en.Append(0xb0, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.SwapSpaceTotal)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "swap_space_free"
			err = en.Append(0xaf, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x66, 0x72, 0x65, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.SwapSpaceFree)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "limit"
			err = en.Append(0xa5, 0x6c, 0x69, 0x6d, 0x69, 0x74)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Limit)
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MemInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Total == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Used == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Free == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Available == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Shared == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Cache == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Buffers == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.SwapSpaceTotal == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.SwapSpaceFree == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Limit == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "NodeCommon"
		o = append(o, 0xaa, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e)
		o, err = (*nodeCommon)(&z.NodeCommon).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "NodeCommon")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "total"
			o = append(o, 0xa5, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			o = msgp.AppendUint64(o, z.Total)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "used"
			o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.Used)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "free"
			o = append(o, 0xa4, 0x66, 0x72, 0x65, 0x65)
			o = msgp.AppendUint64(o, z.Free)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "available"
			o = append(o, 0xa9, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
			o = msgp.AppendUint64(o, z.Available)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "shared"
			o = append(o, 0xa6, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.Shared)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "cache"
			o = append(o, 0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			o = msgp.AppendUint64(o, z.Cache)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "buffer"
			o = append(o, 0xa6, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72)
			o = msgp.AppendUint64(o, z.Buffers)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "swap_space_total"
			o = append(o, 0xb0, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			o = msgp.AppendUint64(o, z.SwapSpaceTotal)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "swap_space_free"
			o = append(o, 0xaf, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x66, 0x72, 0x65, 0x65)
			o = msgp.AppendUint64(o, z.SwapSpaceFree)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "limit"
			o = append(o, 0xa5, 0x6c, 0x69, 0x6d, 0x69, 0x74)
			o = msgp.AppendUint64(o, z.Limit)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MemInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "NodeCommon":
			bts, err = (*nodeCommon)(&z.NodeCommon).UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "NodeCommon")
				return
			}
		case "total":
			z.Total, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
			zb0001Mask |= 0x1
		case "used":
			z.Used, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
			zb0001Mask |= 0x2
		case "free":
			z.Free, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
			zb0001Mask |= 0x4
		case "available":
			z.Available, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
			zb0001Mask |= 0x8
		case "shared":
			z.Shared, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
			zb0001Mask |= 0x10
		case "cache":
			z.Cache, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
			zb0001Mask |= 0x20
		case "buffer":
			z.Buffers, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
			zb0001Mask |= 0x40
		case "swap_space_total":
			z.SwapSpaceTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
			zb0001Mask |= 0x80
		case "swap_space_free":
			z.SwapSpaceFree, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
			zb0001Mask |= 0x100
		case "limit":
			z.Limit, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
			zb0001Mask |= 0x200
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Total = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Used = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Free = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Available = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Shared = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Cache = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Buffers = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.SwapSpaceTotal = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.SwapSpaceFree = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Limit = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MemInfo) Msgsize() (s int) {
	s = 1 + 11 + (*nodeCommon)(&z.NodeCommon).Msgsize() + 6 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 10 + msgp.Uint64Size + 7 + msgp.Uint64Size + 6 + msgp.Uint64Size + 7 + msgp.Uint64Size + 17 + msgp.Uint64Size + 16 + msgp.Uint64Size + 6 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MemMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "memInfo":
			err = z.Info.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MemMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "collected"
	err = en.Append(0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "memInfo"
	err = en.Append(0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
	if err != nil {
		return
	}
	err = z.Info.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Info")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MemMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "collected"
	o = append(o, 0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "memInfo"
	o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
	o, err = z.Info.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Info")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MemMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "memInfo":
			bts, err = z.Info.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MemMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 8 + z.Info.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MetricType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint32
		zb0001, err = dc.ReadUint32()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MetricType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MetricType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint32(uint32(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MetricType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint32(o, uint32(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MetricType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint32
		zb0001, bts, err = msgp.ReadUint32Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MetricType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MetricType) Msgsize() (s int) {
	s = msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Metrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "scanner":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
				z.Scanner = nil
			} else {
				if z.Scanner == nil {
					z.Scanner = new(ScannerMetrics)
				}
				err = z.Scanner.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
			zb0001Mask |= 0x1
		case "disk":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
				z.Disk = nil
			} else {
				if z.Disk == nil {
					z.Disk = new(DiskMetric)
				}
				err = z.Disk.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
			zb0001Mask |= 0x2
		case "os":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
				z.OS = nil
			} else {
				if z.OS == nil {
					z.OS = new(OSMetrics)
				}
				err = z.OS.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
			zb0001Mask |= 0x4
		case "batchJobs":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
				z.BatchJobs = nil
			} else {
				if z.BatchJobs == nil {
					z.BatchJobs = new(BatchJobMetrics)
				}
				err = z.BatchJobs.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
			zb0001Mask |= 0x8
		case "siteResync":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
				z.SiteResync = nil
			} else {
				if z.SiteResync == nil {
					z.SiteResync = new(SiteResyncMetrics)
				}
				err = z.SiteResync.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
			zb0001Mask |= 0x10
		case "net":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
				z.Net = nil
			} else {
				if z.Net == nil {
					z.Net = new(NetMetrics)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Net")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Net.CollectedAt, err = dc.ReadTimeUTC()
						if err != nil {
							err = msgp.WrapError(err, "Net", "CollectedAt")
							return
						}
					case "interfaceName":
						z.Net.InterfaceName, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "Net", "InterfaceName")
							return
						}
					case "netstats":
						err = (*procfsNetDevLine)(&z.Net.NetStats).DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Net", "NetStats")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Net")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x20
		case "mem":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				z.Mem = nil
			} else {
				if z.Mem == nil {
					z.Mem = new(MemMetrics)
				}
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Mem")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Mem.CollectedAt, err = dc.ReadTimeUTC()
						if err != nil {
							err = msgp.WrapError(err, "Mem", "CollectedAt")
							return
						}
					case "memInfo":
						err = z.Mem.Info.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "Info")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Mem")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x40
		case "cpu":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
				z.CPU = nil
			} else {
				if z.CPU == nil {
					z.CPU = new(CPUMetrics)
				}
				err = z.CPU.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
			zb0001Mask |= 0x80
		case "rpc":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
				z.RPC = nil
			} else {
				if z.RPC == nil {
					z.RPC = new(RPCMetrics)
				}
				err = z.RPC.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
			zb0001Mask |= 0x100
		case "go":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
				z.Go = nil
			} else {
				if z.Go == nil {
					z.Go = new(RuntimeMetrics)
				}
				err = z.Go.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
			zb0001Mask |= 0x200
		case "api":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
				z.API = nil
			} else {
				if z.API == nil {
					z.API = new(APIMetrics)
				}
				err = z.API.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
			}
			zb0001Mask |= 0x400
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Scanner = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Disk = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.OS = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.BatchJobs = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.SiteResync = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Net = nil
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Mem = nil
		}
		if (zb0001Mask & 0x80) == 0 {
			z.CPU = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.RPC = nil
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Go = nil
		}
		if (zb0001Mask & 0x400) == 0 {
			z.API = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Metrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Scanner == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Disk == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.OS == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.BatchJobs == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.SiteResync == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Net == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mem == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.CPU == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.RPC == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Go == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.API == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "scanner"
			err = en.Append(0xa7, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x72)
			if err != nil {
				return
			}
			if z.Scanner == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Scanner.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "disk"
			err = en.Append(0xa4, 0x64, 0x69, 0x73, 0x6b)
			if err != nil {
				return
			}
			if z.Disk == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Disk.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "os"
			err = en.Append(0xa2, 0x6f, 0x73)
			if err != nil {
				return
			}
			if z.OS == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.OS.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "batchJobs"
			err = en.Append(0xa9, 0x62, 0x61, 0x74, 0x63, 0x68, 0x4a, 0x6f, 0x62, 0x73)
			if err != nil {
				return
			}
			if z.BatchJobs == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.BatchJobs.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "siteResync"
			err = en.Append(0xaa, 0x73, 0x69, 0x74, 0x65, 0x52, 0x65, 0x73, 0x79, 0x6e, 0x63)
			if err != nil {
				return
			}
			if z.SiteResync == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.SiteResync.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "net"
			err = en.Append(0xa3, 0x6e, 0x65, 0x74)
			if err != nil {
				return
			}
			if z.Net == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				// map header, size 3
				// write "collected"
				err = en.Append(0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				if err != nil {
					return
				}
				err = en.WriteTime(z.Net.CollectedAt)
				if err != nil {
					err = msgp.WrapError(err, "Net", "CollectedAt")
					return
				}
				// write "interfaceName"
				err = en.Append(0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
				if err != nil {
					return
				}
				err = en.WriteString(z.Net.InterfaceName)
				if err != nil {
					err = msgp.WrapError(err, "Net", "InterfaceName")
					return
				}
				// write "netstats"
				err = en.Append(0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
				if err != nil {
					return
				}
				err = (*procfsNetDevLine)(&z.Net.NetStats).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Net", "NetStats")
					return
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "mem"
			err = en.Append(0xa3, 0x6d, 0x65, 0x6d)
			if err != nil {
				return
			}
			if z.Mem == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				// map header, size 2
				// write "collected"
				err = en.Append(0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				if err != nil {
					return
				}
				err = en.WriteTime(z.Mem.CollectedAt)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "CollectedAt")
					return
				}
				// write "memInfo"
				err = en.Append(0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
				if err != nil {
					return
				}
				err = z.Mem.Info.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "Info")
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "cpu"
			err = en.Append(0xa3, 0x63, 0x70, 0x75)
			if err != nil {
				return
			}
			if z.CPU == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.CPU.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "rpc"
			err = en.Append(0xa3, 0x72, 0x70, 0x63)
			if err != nil {
				return
			}
			if z.RPC == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.RPC.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "go"
			err = en.Append(0xa2, 0x67, 0x6f)
			if err != nil {
				return
			}
			if z.Go == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Go.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "api"
			err = en.Append(0xa3, 0x61, 0x70, 0x69)
			if err != nil {
				return
			}
			if z.API == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.API.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Metrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Scanner == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Disk == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.OS == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.BatchJobs == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.SiteResync == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Net == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mem == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.CPU == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.RPC == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Go == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.API == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "scanner"
			o = append(o, 0xa7, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x72)
			if z.Scanner == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Scanner.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "disk"
			o = append(o, 0xa4, 0x64, 0x69, 0x73, 0x6b)
			if z.Disk == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Disk.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "os"
			o = append(o, 0xa2, 0x6f, 0x73)
			if z.OS == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.OS.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "batchJobs"
			o = append(o, 0xa9, 0x62, 0x61, 0x74, 0x63, 0x68, 0x4a, 0x6f, 0x62, 0x73)
			if z.BatchJobs == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.BatchJobs.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "siteResync"
			o = append(o, 0xaa, 0x73, 0x69, 0x74, 0x65, 0x52, 0x65, 0x73, 0x79, 0x6e, 0x63)
			if z.SiteResync == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.SiteResync.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "net"
			o = append(o, 0xa3, 0x6e, 0x65, 0x74)
			if z.Net == nil {
				o = msgp.AppendNil(o)
			} else {
				// map header, size 3
				// string "collected"
				o = append(o, 0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				o = msgp.AppendTime(o, z.Net.CollectedAt)
				// string "interfaceName"
				o = append(o, 0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
				o = msgp.AppendString(o, z.Net.InterfaceName)
				// string "netstats"
				o = append(o, 0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
				o, err = (*procfsNetDevLine)(&z.Net.NetStats).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Net", "NetStats")
					return
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "mem"
			o = append(o, 0xa3, 0x6d, 0x65, 0x6d)
			if z.Mem == nil {
				o = msgp.AppendNil(o)
			} else {
				// map header, size 2
				// string "collected"
				o = append(o, 0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				o = msgp.AppendTime(o, z.Mem.CollectedAt)
				// string "memInfo"
				o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
				o, err = z.Mem.Info.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "Info")
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "cpu"
			o = append(o, 0xa3, 0x63, 0x70, 0x75)
			if z.CPU == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.CPU.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "rpc"
			o = append(o, 0xa3, 0x72, 0x70, 0x63)
			if z.RPC == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.RPC.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "go"
			o = append(o, 0xa2, 0x67, 0x6f)
			if z.Go == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Go.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "api"
			o = append(o, 0xa3, 0x61, 0x70, 0x69)
			if z.API == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.API.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Metrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "scanner":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Scanner = nil
			} else {
				if z.Scanner == nil {
					z.Scanner = new(ScannerMetrics)
				}
				bts, err = z.Scanner.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
			zb0001Mask |= 0x1
		case "disk":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Disk = nil
			} else {
				if z.Disk == nil {
					z.Disk = new(DiskMetric)
				}
				bts, err = z.Disk.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
			zb0001Mask |= 0x2
		case "os":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OS = nil
			} else {
				if z.OS == nil {
					z.OS = new(OSMetrics)
				}
				bts, err = z.OS.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
			zb0001Mask |= 0x4
		case "batchJobs":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BatchJobs = nil
			} else {
				if z.BatchJobs == nil {
					z.BatchJobs = new(BatchJobMetrics)
				}
				bts, err = z.BatchJobs.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
			zb0001Mask |= 0x8
		case "siteResync":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SiteResync = nil
			} else {
				if z.SiteResync == nil {
					z.SiteResync = new(SiteResyncMetrics)
				}
				bts, err = z.SiteResync.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
			zb0001Mask |= 0x10
		case "net":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Net = nil
			} else {
				if z.Net == nil {
					z.Net = new(NetMetrics)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Net")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Net.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Net", "CollectedAt")
							return
						}
					case "interfaceName":
						z.Net.InterfaceName, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Net", "InterfaceName")
							return
						}
					case "netstats":
						bts, err = (*procfsNetDevLine)(&z.Net.NetStats).UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Net", "NetStats")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Net")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x20
		case "mem":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Mem = nil
			} else {
				if z.Mem == nil {
					z.Mem = new(MemMetrics)
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Mem")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Mem.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "CollectedAt")
							return
						}
					case "memInfo":
						bts, err = z.Mem.Info.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "Info")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x40
		case "cpu":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CPU = nil
			} else {
				if z.CPU == nil {
					z.CPU = new(CPUMetrics)
				}
				bts, err = z.CPU.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
			zb0001Mask |= 0x80
		case "rpc":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RPC = nil
			} else {
				if z.RPC == nil {
					z.RPC = new(RPCMetrics)
				}
				bts, err = z.RPC.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
			zb0001Mask |= 0x100
		case "go":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Go = nil
			} else {
				if z.Go == nil {
					z.Go = new(RuntimeMetrics)
				}
				bts, err = z.Go.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
			zb0001Mask |= 0x200
		case "api":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.API = nil
			} else {
				if z.API == nil {
					z.API = new(APIMetrics)
				}
				bts, err = z.API.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
			}
			zb0001Mask |= 0x400
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Scanner = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Disk = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.OS = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.BatchJobs = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.SiteResync = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Net = nil
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Mem = nil
		}
		if (zb0001Mask & 0x80) == 0 {
			z.CPU = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.RPC = nil
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Go = nil
		}
		if (zb0001Mask & 0x400) == 0 {
			z.API = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Metrics) Msgsize() (s int) {
	s = 1 + 8
	if z.Scanner == nil {
		s += msgp.NilSize
	} else {
		s += z.Scanner.Msgsize()
	}
	s += 5
	if z.Disk == nil {
		s += msgp.NilSize
	} else {
		s += z.Disk.Msgsize()
	}
	s += 3
	if z.OS == nil {
		s += msgp.NilSize
	} else {
		s += z.OS.Msgsize()
	}
	s += 10
	if z.BatchJobs == nil {
		s += msgp.NilSize
	} else {
		s += z.BatchJobs.Msgsize()
	}
	s += 11
	if z.SiteResync == nil {
		s += msgp.NilSize
	} else {
		s += z.SiteResync.Msgsize()
	}
	s += 4
	if z.Net == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.TimeSize + 14 + msgp.StringPrefixSize + len(z.Net.InterfaceName) + 9 + (*procfsNetDevLine)(&z.Net.NetStats).Msgsize()
	}
	s += 4
	if z.Mem == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.TimeSize + 8 + z.Mem.Info.Msgsize()
	}
	s += 4
	if z.CPU == nil {
		s += msgp.NilSize
	} else {
		s += z.CPU.Msgsize()
	}
	s += 4
	if z.RPC == nil {
		s += msgp.NilSize
	} else {
		s += z.RPC.Msgsize()
	}
	s += 3
	if z.Go == nil {
		s += msgp.NilSize
	} else {
		s += z.Go.Msgsize()
	}
	s += 4
	if z.API == nil {
		s += msgp.NilSize
	} else {
		s += z.API.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MetricsOptions) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			{
				var zb0002 uint32
				zb0002, err = dc.ReadUint32()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = MetricType(zb0002)
			}
		case "N":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "Interval":
			z.Interval, err = dc.ReadDuration()
			if err != nil {
				err = msgp.WrapError(err, "Interval")
				return
			}
		case "PoolIdx":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PoolIdx")
				return
			}
			if cap(z.PoolIdx) >= int(zb0003) {
				z.PoolIdx = (z.PoolIdx)[:zb0003]
			} else {
				z.PoolIdx = make([]int, zb0003)
			}
			for za0001 := range z.PoolIdx {
				z.PoolIdx[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx", za0001)
					return
				}
			}
		case "Hosts":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0004) {
				z.Hosts = (z.Hosts)[:zb0004]
			} else {
				z.Hosts = make([]string, zb0004)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "DriveSetIdx":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DriveSetIdx")
				return
			}
			if cap(z.DriveSetIdx) >= int(zb0005) {
				z.DriveSetIdx = (z.DriveSetIdx)[:zb0005]
			} else {
				z.DriveSetIdx = make([]int, zb0005)
			}
			for za0003 := range z.DriveSetIdx {
				z.DriveSetIdx[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DriveSetIdx", za0003)
					return
				}
			}
		case "Disks":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0006) {
				z.Disks = (z.Disks)[:zb0006]
			} else {
				z.Disks = make([]string, zb0006)
			}
			for za0004 := range z.Disks {
				z.Disks[za0004], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0004)
					return
				}
			}
		case "ByJobID":
			z.ByJobID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ByJobID")
				return
			}
		case "ByDepID":
			z.ByDepID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ByDepID")
				return
			}
		case "ByHost":
			z.ByHost, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
		case "ByDisk":
			z.ByDisk, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
		case "ByPool":
			z.ByPool, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ByPool")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MetricsOptions) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 12
	// write "Type"
	err = en.Append(0x8c, 0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(uint32(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "N"
	err = en.Append(0xa1, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.N)
	if err != nil {
		err = msgp.WrapError(err, "N")
		return
	}
	// write "Interval"
	err = en.Append(0xa8, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteDuration(z.Interval)
	if err != nil {
		err = msgp.WrapError(err, "Interval")
		return
	}
	// write "PoolIdx"
	err = en.Append(0xa7, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x78)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PoolIdx)))
	if err != nil {
		err = msgp.WrapError(err, "PoolIdx")
		return
	}
	for za0001 := range z.PoolIdx {
		err = en.WriteInt(z.PoolIdx[za0001])
		if err != nil {
			err = msgp.WrapError(err, "PoolIdx", za0001)
			return
		}
	}
	// write "Hosts"
	err = en.Append(0xa5, 0x48, 0x6f, 0x73, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Hosts)))
	if err != nil {
		err = msgp.WrapError(err, "Hosts")
		return
	}
	for za0002 := range z.Hosts {
		err = en.WriteString(z.Hosts[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Hosts", za0002)
			return
		}
	}
	// write "DriveSetIdx"
	err = en.Append(0xab, 0x44, 0x72, 0x69, 0x76, 0x65, 0x53, 0x65, 0x74, 0x49, 0x64, 0x78)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DriveSetIdx)))
	if err != nil {
		err = msgp.WrapError(err, "DriveSetIdx")
		return
	}
	for za0003 := range z.DriveSetIdx {
		err = en.WriteInt(z.DriveSetIdx[za0003])
		if err != nil {
			err = msgp.WrapError(err, "DriveSetIdx", za0003)
			return
		}
	}
	// write "Disks"
	err = en.Append(0xa5, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Disks)))
	if err != nil {
		err = msgp.WrapError(err, "Disks")
		return
	}
	for za0004 := range z.Disks {
		err = en.WriteString(z.Disks[za0004])
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0004)
			return
		}
	}
	// write "ByJobID"
	err = en.Append(0xa7, 0x42, 0x79, 0x4a, 0x6f, 0x62, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ByJobID)
	if err != nil {
		err = msgp.WrapError(err, "ByJobID")
		return
	}
	// write "ByDepID"
	err = en.Append(0xa7, 0x42, 0x79, 0x44, 0x65, 0x70, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ByDepID)
	if err != nil {
		err = msgp.WrapError(err, "ByDepID")
		return
	}
	// write "ByHost"
	err = en.Append(0xa6, 0x42, 0x79, 0x48, 0x6f, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ByHost)
	if err != nil {
		err = msgp.WrapError(err, "ByHost")
		return
	}
	// write "ByDisk"
	err = en.Append(0xa6, 0x42, 0x79, 0x44, 0x69, 0x73, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ByDisk)
	if err != nil {
		err = msgp.WrapError(err, "ByDisk")
		return
	}
	// write "ByPool"
	err = en.Append(0xa6, 0x42, 0x79, 0x50, 0x6f, 0x6f, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ByPool)
	if err != nil {
		err = msgp.WrapError(err, "ByPool")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MetricsOptions) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "Type"
	o = append(o, 0x8c, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendUint32(o, uint32(z.Type))
	// string "N"
	o = append(o, 0xa1, 0x4e)
	o = msgp.AppendInt(o, z.N)
	// string "Interval"
	o = append(o, 0xa8, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	o = msgp.AppendDuration(o, z.Interval)
	// string "PoolIdx"
	o = append(o, 0xa7, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PoolIdx)))
	for za0001 := range z.PoolIdx {
		o = msgp.AppendInt(o, z.PoolIdx[za0001])
	}
	// string "Hosts"
	o = append(o, 0xa5, 0x48, 0x6f, 0x73, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Hosts)))
	for za0002 := range z.Hosts {
		o = msgp.AppendString(o, z.Hosts[za0002])
	}
	// string "DriveSetIdx"
	o = append(o, 0xab, 0x44, 0x72, 0x69, 0x76, 0x65, 0x53, 0x65, 0x74, 0x49, 0x64, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DriveSetIdx)))
	for za0003 := range z.DriveSetIdx {
		o = msgp.AppendInt(o, z.DriveSetIdx[za0003])
	}
	// string "Disks"
	o = append(o, 0xa5, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Disks)))
	for za0004 := range z.Disks {
		o = msgp.AppendString(o, z.Disks[za0004])
	}
	// string "ByJobID"
	o = append(o, 0xa7, 0x42, 0x79, 0x4a, 0x6f, 0x62, 0x49, 0x44)
	o = msgp.AppendString(o, z.ByJobID)
	// string "ByDepID"
	o = append(o, 0xa7, 0x42, 0x79, 0x44, 0x65, 0x70, 0x49, 0x44)
	o = msgp.AppendString(o, z.ByDepID)
	// string "ByHost"
	o = append(o, 0xa6, 0x42, 0x79, 0x48, 0x6f, 0x73, 0x74)
	o = msgp.AppendBool(o, z.ByHost)
	// string "ByDisk"
	o = append(o, 0xa6, 0x42, 0x79, 0x44, 0x69, 0x73, 0x6b)
	o = msgp.AppendBool(o, z.ByDisk)
	// string "ByPool"
	o = append(o, 0xa6, 0x42, 0x79, 0x50, 0x6f, 0x6f, 0x6c)
	o = msgp.AppendBool(o, z.ByPool)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MetricsOptions) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			{
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = MetricType(zb0002)
			}
		case "N":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "Interval":
			z.Interval, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Interval")
				return
			}
		case "PoolIdx":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolIdx")
				return
			}
			if cap(z.PoolIdx) >= int(zb0003) {
				z.PoolIdx = (z.PoolIdx)[:zb0003]
			} else {
				z.PoolIdx = make([]int, zb0003)
			}
			for za0001 := range z.PoolIdx {
				z.PoolIdx[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx", za0001)
					return
				}
			}
		case "Hosts":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0004) {
				z.Hosts = (z.Hosts)[:zb0004]
			} else {
				z.Hosts = make([]string, zb0004)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "DriveSetIdx":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DriveSetIdx")
				return
			}
			if cap(z.DriveSetIdx) >= int(zb0005) {
				z.DriveSetIdx = (z.DriveSetIdx)[:zb0005]
			} else {
				z.DriveSetIdx = make([]int, zb0005)
			}
			for za0003 := range z.DriveSetIdx {
				z.DriveSetIdx[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DriveSetIdx", za0003)
					return
				}
			}
		case "Disks":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0006) {
				z.Disks = (z.Disks)[:zb0006]
			} else {
				z.Disks = make([]string, zb0006)
			}
			for za0004 := range z.Disks {
				z.Disks[za0004], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0004)
					return
				}
			}
		case "ByJobID":
			z.ByJobID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByJobID")
				return
			}
		case "ByDepID":
			z.ByDepID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDepID")
				return
			}
		case "ByHost":
			z.ByHost, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
		case "ByDisk":
			z.ByDisk, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
		case "ByPool":
			z.ByPool, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByPool")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MetricsOptions) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint32Size + 2 + msgp.IntSize + 9 + msgp.DurationSize + 8 + msgp.ArrayHeaderSize + (len(z.PoolIdx) * (msgp.IntSize)) + 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Hosts {
		s += msgp.StringPrefixSize + len(z.Hosts[za0002])
	}
	s += 12 + msgp.ArrayHeaderSize + (len(z.DriveSetIdx) * (msgp.IntSize)) + 6 + msgp.ArrayHeaderSize
	for za0004 := range z.Disks {
		s += msgp.StringPrefixSize + len(z.Disks[za0004])
	}
	s += 8 + msgp.StringPrefixSize + len(z.ByJobID) + 8 + msgp.StringPrefixSize + len(z.ByDepID) + 7 + msgp.BoolSize + 7 + msgp.BoolSize + 7 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NetMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "interfaceName":
			z.InterfaceName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InterfaceName")
				return
			}
		case "netstats":
			err = (*procfsNetDevLine)(&z.NetStats).DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "NetStats")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *NetMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "collected"
	err = en.Append(0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "interfaceName"
	err = en.Append(0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.InterfaceName)
	if err != nil {
		err = msgp.WrapError(err, "InterfaceName")
		return
	}
	// write "netstats"
	err = en.Append(0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = (*procfsNetDevLine)(&z.NetStats).EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "NetStats")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *NetMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "collected"
	o = append(o, 0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "interfaceName"
	o = append(o, 0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.InterfaceName)
	// string "netstats"
	o = append(o, 0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
	o, err = (*procfsNetDevLine)(&z.NetStats).MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "NetStats")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NetMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "interfaceName":
			z.InterfaceName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InterfaceName")
				return
			}
		case "netstats":
			bts, err = (*procfsNetDevLine)(&z.NetStats).UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetStats")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NetMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 14 + msgp.StringPrefixSize + len(z.InterfaceName) + 9 + (*procfsNetDevLine)(&z.NetStats).Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OSMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "life_time_ops":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 uint64
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "last_minute":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						for key := range z.LastMinute.Operations {
							delete(z.LastMinute.Operations, key)
						}
					}
					for zb0004 > 0 {
						zb0004--
						var za0003 string
						var za0004 TimedAction
						za0003, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						err = za0004.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.LifeTimeOps = nil
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *OSMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "life_time_ops"
			err = en.Append(0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			for za0001, za0002 := range z.LifeTimeOps {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				err = en.WriteUint64(za0002)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
			}
		}
		// write "last_minute"
		err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// write "operations"
			err = en.Append(0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinute.Operations)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinute", "Operations")
				return
			}
			for za0003, za0004 := range z.LastMinute.Operations {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OSMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "life_time_ops"
			o = append(o, 0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeOps)))
			for za0001, za0002 := range z.LifeTimeOps {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendUint64(o, za0002)
			}
		}
		// string "last_minute"
		o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// string "operations"
			o = append(o, 0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.Operations)))
			for za0003, za0004 := range z.LastMinute.Operations {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OSMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "life_time_ops":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 uint64
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "last_minute":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						for key := range z.LastMinute.Operations {
							delete(z.LastMinute.Operations, key)
						}
					}
					for zb0004 > 0 {
						var za0003 string
						var za0004 TimedAction
						zb0004--
						za0003, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						bts, err = za0004.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.LifeTimeOps = nil
	}

	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OSMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 14 + msgp.MapHeaderSize
	if z.LifeTimeOps != nil {
		for za0001, za0002 := range z.LifeTimeOps {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 12 + 1 + 11 + msgp.MapHeaderSize
	if z.LastMinute.Operations != nil {
		for za0003, za0004 := range z.LastMinute.Operations {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RPCMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collectedAt":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "connected":
			z.Connected, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
		case "reconnectCount":
			z.ReconnectCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
		case "disconnected":
			z.Disconnected, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
		case "outgoingStreams":
			z.OutgoingStreams, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
		case "incomingStreams":
			z.IncomingStreams, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
		case "outgoingBytes":
			z.OutgoingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		case "incomingBytes":
			z.IncomingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		case "outgoingMessages":
			z.OutgoingMessages, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
		case "incomingMessages":
			z.IncomingMessages, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
		case "outQueue":
			z.OutQueue, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
		case "lastPongTime":
			z.LastPongTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
		case "lastPingMS":
			z.LastPingMS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
		case "maxPingDurMS":
			z.MaxPingDurMS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
		case "lastConnectTime":
			z.LastConnectTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
		case "byDestination":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			if z.ByDestination == nil {
				z.ByDestination = make(map[string]RPCMetrics, zb0002)
			} else if len(z.ByDestination) > 0 {
				for key := range z.ByDestination {
					delete(z.ByDestination, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 RPCMetrics
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0001)
					return
				}
				z.ByDestination[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "byCaller":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			if z.ByCaller == nil {
				z.ByCaller = make(map[string]RPCMetrics, zb0003)
			} else if len(z.ByCaller) > 0 {
				for key := range z.ByCaller {
					delete(z.ByCaller, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 RPCMetrics
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				err = za0004.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0003)
					return
				}
				z.ByCaller[za0003] = za0004
			}
			zb0001Mask |= 0x2
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.ByDestination = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByCaller = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RPCMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.ByDestination == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.ByCaller == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collectedAt"
		err = en.Append(0xab, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x41, 0x74)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "connected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Connected)
		if err != nil {
			err = msgp.WrapError(err, "Connected")
			return
		}
		// write "reconnectCount"
		err = en.Append(0xae, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.ReconnectCount)
		if err != nil {
			err = msgp.WrapError(err, "ReconnectCount")
			return
		}
		// write "disconnected"
		err = en.Append(0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Disconnected)
		if err != nil {
			err = msgp.WrapError(err, "Disconnected")
			return
		}
		// write "outgoingStreams"
		err = en.Append(0xaf, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.OutgoingStreams)
		if err != nil {
			err = msgp.WrapError(err, "OutgoingStreams")
			return
		}
		// write "incomingStreams"
		err = en.Append(0xaf, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.IncomingStreams)
		if err != nil {
			err = msgp.WrapError(err, "IncomingStreams")
			return
		}
		// write "outgoingBytes"
		err = en.Append(0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.OutgoingBytes)
		if err != nil {
			err = msgp.WrapError(err, "OutgoingBytes")
			return
		}
		// write "incomingBytes"
		err = en.Append(0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.IncomingBytes)
		if err != nil {
			err = msgp.WrapError(err, "IncomingBytes")
			return
		}
		// write "outgoingMessages"
		err = en.Append(0xb0, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.OutgoingMessages)
		if err != nil {
			err = msgp.WrapError(err, "OutgoingMessages")
			return
		}
		// write "incomingMessages"
		err = en.Append(0xb0, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.IncomingMessages)
		if err != nil {
			err = msgp.WrapError(err, "IncomingMessages")
			return
		}
		// write "outQueue"
		err = en.Append(0xa8, 0x6f, 0x75, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt(z.OutQueue)
		if err != nil {
			err = msgp.WrapError(err, "OutQueue")
			return
		}
		// write "lastPongTime"
		err = en.Append(0xac, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x6f, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastPongTime)
		if err != nil {
			err = msgp.WrapError(err, "LastPongTime")
			return
		}
		// write "lastPingMS"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x4d, 0x53)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.LastPingMS)
		if err != nil {
			err = msgp.WrapError(err, "LastPingMS")
			return
		}
		// write "maxPingDurMS"
		err = en.Append(0xac, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x6e, 0x67, 0x44, 0x75, 0x72, 0x4d, 0x53)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.MaxPingDurMS)
		if err != nil {
			err = msgp.WrapError(err, "MaxPingDurMS")
			return
		}
		// write "lastConnectTime"
		err = en.Append(0xaf, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastConnectTime)
		if err != nil {
			err = msgp.WrapError(err, "LastConnectTime")
			return
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "byDestination"
			err = en.Append(0xad, 0x62, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByDestination)))
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			for za0001, za0002 := range z.ByDestination {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				err = za0002.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "byCaller"
			err = en.Append(0xa8, 0x62, 0x79, 0x43, 0x61, 0x6c, 0x6c, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByCaller)))
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			for za0003, za0004 := range z.ByCaller {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0003)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RPCMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.ByDestination == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.ByCaller == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collectedAt"
		o = append(o, 0xab, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x41, 0x74)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "connected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendInt(o, z.Connected)
		// string "reconnectCount"
		o = append(o, 0xae, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt(o, z.ReconnectCount)
		// string "disconnected"
		o = append(o, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendInt(o, z.Disconnected)
		// string "outgoingStreams"
		o = append(o, 0xaf, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
		o = msgp.AppendInt(o, z.OutgoingStreams)
		// string "incomingStreams"
		o = append(o, 0xaf, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
		o = msgp.AppendInt(o, z.IncomingStreams)
		// string "outgoingBytes"
		o = append(o, 0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
		o = msgp.AppendInt64(o, z.OutgoingBytes)
		// string "incomingBytes"
		o = append(o, 0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
		o = msgp.AppendInt64(o, z.IncomingBytes)
		// string "outgoingMessages"
		o = append(o, 0xb0, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
		o = msgp.AppendInt64(o, z.OutgoingMessages)
		// string "incomingMessages"
		o = append(o, 0xb0, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
		o = msgp.AppendInt64(o, z.IncomingMessages)
		// string "outQueue"
		o = append(o, 0xa8, 0x6f, 0x75, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65)
		o = msgp.AppendInt(o, z.OutQueue)
		// string "lastPongTime"
		o = append(o, 0xac, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x6f, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.LastPongTime)
		// string "lastPingMS"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x4d, 0x53)
		o = msgp.AppendFloat64(o, z.LastPingMS)
		// string "maxPingDurMS"
		o = append(o, 0xac, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x6e, 0x67, 0x44, 0x75, 0x72, 0x4d, 0x53)
		o = msgp.AppendFloat64(o, z.MaxPingDurMS)
		// string "lastConnectTime"
		o = append(o, 0xaf, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.LastConnectTime)
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "byDestination"
			o = append(o, 0xad, 0x62, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByDestination)))
			for za0001, za0002 := range z.ByDestination {
				o = msgp.AppendString(o, za0001)
				o, err = za0002.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "byCaller"
			o = append(o, 0xa8, 0x62, 0x79, 0x43, 0x61, 0x6c, 0x6c, 0x65, 0x72)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByCaller)))
			for za0003, za0004 := range z.ByCaller {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0003)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RPCMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collectedAt":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "connected":
			z.Connected, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
		case "reconnectCount":
			z.ReconnectCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
		case "disconnected":
			z.Disconnected, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
		case "outgoingStreams":
			z.OutgoingStreams, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
		case "incomingStreams":
			z.IncomingStreams, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
		case "outgoingBytes":
			z.OutgoingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		case "incomingBytes":
			z.IncomingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		case "outgoingMessages":
			z.OutgoingMessages, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
		case "incomingMessages":
			z.IncomingMessages, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
		case "outQueue":
			z.OutQueue, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
		case "lastPongTime":
			z.LastPongTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
		case "lastPingMS":
			z.LastPingMS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
		case "maxPingDurMS":
			z.MaxPingDurMS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
		case "lastConnectTime":
			z.LastConnectTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
		case "byDestination":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			if z.ByDestination == nil {
				z.ByDestination = make(map[string]RPCMetrics, zb0002)
			} else if len(z.ByDestination) > 0 {
				for key := range z.ByDestination {
					delete(z.ByDestination, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 RPCMetrics
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0001)
					return
				}
				z.ByDestination[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "byCaller":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			if z.ByCaller == nil {
				z.ByCaller = make(map[string]RPCMetrics, zb0003)
			} else if len(z.ByCaller) > 0 {
				for key := range z.ByCaller {
					delete(z.ByCaller, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 RPCMetrics
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				bts, err = za0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0003)
					return
				}
				z.ByCaller[za0003] = za0004
			}
			zb0001Mask |= 0x2
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.ByDestination = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByCaller = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RPCMetrics) Msgsize() (s int) {
	s = 3 + 12 + msgp.TimeSize + 10 + msgp.IntSize + 15 + msgp.IntSize + 13 + msgp.IntSize + 16 + msgp.IntSize + 16 + msgp.IntSize + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 17 + msgp.Int64Size + 17 + msgp.Int64Size + 9 + msgp.IntSize + 13 + msgp.TimeSize + 11 + msgp.Float64Size + 13 + msgp.Float64Size + 16 + msgp.TimeSize + 14 + msgp.MapHeaderSize
	if z.ByDestination != nil {
		for za0001, za0002 := range z.ByDestination {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += 9 + msgp.MapHeaderSize
	if z.ByCaller != nil {
		for za0003, za0004 := range z.ByCaller {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RealtimeMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "errors":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0002) {
				z.Errors = (z.Errors)[:zb0002]
			} else {
				z.Errors = make([]string, zb0002)
			}
			for za0001 := range z.Errors {
				z.Errors[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "hosts":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0003) {
				z.Hosts = (z.Hosts)[:zb0003]
			} else {
				z.Hosts = make([]string, zb0003)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "aggregated":
			err = z.Aggregated.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Aggregated")
				return
			}
		case "by_host":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			if z.ByHost == nil {
				z.ByHost = make(map[string]Metrics, zb0004)
			} else if len(z.ByHost) > 0 {
				for key := range z.ByHost {
					delete(z.ByHost, key)
				}
			}
			for zb0004 > 0 {
				zb0004--
				var za0003 string
				var za0004 Metrics
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				err = za0004.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
				z.ByHost[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "by_disk":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			if z.ByDisk == nil {
				z.ByDisk = make(map[string]DiskMetric, zb0005)
			} else if len(z.ByDisk) > 0 {
				for key := range z.ByDisk {
					delete(z.ByDisk, key)
				}
			}
			for zb0005 > 0 {
				zb0005--
				var za0005 string
				var za0006 DiskMetric
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				err = za0006.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
				z.ByDisk[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "by_pool":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByPool")
				return
			}
			if z.ByPool == nil {
				z.ByPool = make(map[string]Metrics, zb0006)
			} else if len(z.ByPool) > 0 {
				for key := range z.ByPool {
					delete(z.ByPool, key)
				}
			}
			for zb0006 > 0 {
				zb0006--
				var za0007 string
				var za0008 Metrics
				za0007, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByPool")
					return
				}
				err = za0008.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByPool", za0007)
					return
				}
				z.ByPool[za0007] = za0008
			}
			zb0001Mask |= 0x8
		case "final":
			z.Final, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Final")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Errors = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByHost = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ByDisk = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ByPool = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RealtimeMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.Errors == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ByHost == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ByDisk == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.ByPool == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "errors"
			err = en.Append(0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Errors)))
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			for za0001 := range z.Errors {
				err = en.WriteString(z.Errors[za0001])
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
		}
		// write "hosts"
		err = en.Append(0xa5, 0x68, 0x6f, 0x73, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Hosts)))
		if err != nil {
			err = msgp.WrapError(err, "Hosts")
			return
		}
		for za0002 := range z.Hosts {
			err = en.WriteString(z.Hosts[za0002])
			if err != nil {
				err = msgp.WrapError(err, "Hosts", za0002)
				return
			}
		}
		// write "aggregated"
		err = en.Append(0xaa, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = z.Aggregated.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Aggregated")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "by_host"
			err = en.Append(0xa7, 0x62, 0x79, 0x5f, 0x68, 0x6f, 0x73, 0x74)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByHost)))
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			for za0003, za0004 := range z.ByHost {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "by_disk"
			err = en.Append(0xa7, 0x62, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByDisk)))
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			for za0005, za0006 := range z.ByDisk {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				err = za0006.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "by_pool"
			err = en.Append(0xa7, 0x62, 0x79, 0x5f, 0x70, 0x6f, 0x6f, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByPool)))
			if err != nil {
				err = msgp.WrapError(err, "ByPool")
				return
			}
			for za0007, za0008 := range z.ByPool {
				err = en.WriteString(za0007)
				if err != nil {
					err = msgp.WrapError(err, "ByPool")
					return
				}
				err = za0008.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByPool", za0007)
					return
				}
			}
		}
		// write "final"
		err = en.Append(0xa5, 0x66, 0x69, 0x6e, 0x61, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Final)
		if err != nil {
			err = msgp.WrapError(err, "Final")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RealtimeMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.Errors == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ByHost == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ByDisk == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.ByPool == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "errors"
			o = append(o, 0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Errors)))
			for za0001 := range z.Errors {
				o = msgp.AppendString(o, z.Errors[za0001])
			}
		}
		// string "hosts"
		o = append(o, 0xa5, 0x68, 0x6f, 0x73, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Hosts)))
		for za0002 := range z.Hosts {
			o = msgp.AppendString(o, z.Hosts[za0002])
		}
		// string "aggregated"
		o = append(o, 0xaa, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64)
		o, err = z.Aggregated.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Aggregated")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "by_host"
			o = append(o, 0xa7, 0x62, 0x79, 0x5f, 0x68, 0x6f, 0x73, 0x74)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByHost)))
			for za0003, za0004 := range z.ByHost {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "by_disk"
			o = append(o, 0xa7, 0x62, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByDisk)))
			for za0005, za0006 := range z.ByDisk {
				o = msgp.AppendString(o, za0005)
				o, err = za0006.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "by_pool"
			o = append(o, 0xa7, 0x62, 0x79, 0x5f, 0x70, 0x6f, 0x6f, 0x6c)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByPool)))
			for za0007, za0008 := range z.ByPool {
				o = msgp.AppendString(o, za0007)
				o, err = za0008.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByPool", za0007)
					return
				}
			}
		}
		// string "final"
		o = append(o, 0xa5, 0x66, 0x69, 0x6e, 0x61, 0x6c)
		o = msgp.AppendBool(o, z.Final)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RealtimeMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "errors":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0002) {
				z.Errors = (z.Errors)[:zb0002]
			} else {
				z.Errors = make([]string, zb0002)
			}
			for za0001 := range z.Errors {
				z.Errors[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "hosts":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0003) {
				z.Hosts = (z.Hosts)[:zb0003]
			} else {
				z.Hosts = make([]string, zb0003)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "aggregated":
			bts, err = z.Aggregated.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Aggregated")
				return
			}
		case "by_host":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			if z.ByHost == nil {
				z.ByHost = make(map[string]Metrics, zb0004)
			} else if len(z.ByHost) > 0 {
				for key := range z.ByHost {
					delete(z.ByHost, key)
				}
			}
			for zb0004 > 0 {
				var za0003 string
				var za0004 Metrics
				zb0004--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				bts, err = za0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
				z.ByHost[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "by_disk":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			if z.ByDisk == nil {
				z.ByDisk = make(map[string]DiskMetric, zb0005)
			} else if len(z.ByDisk) > 0 {
				for key := range z.ByDisk {
					delete(z.ByDisk, key)
				}
			}
			for zb0005 > 0 {
				var za0005 string
				var za0006 DiskMetric
				zb0005--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				bts, err = za0006.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
				z.ByDisk[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "by_pool":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByPool")
				return
			}
			if z.ByPool == nil {
				z.ByPool = make(map[string]Metrics, zb0006)
			} else if len(z.ByPool) > 0 {
				for key := range z.ByPool {
					delete(z.ByPool, key)
				}
			}
			for zb0006 > 0 {
				var za0007 string
				var za0008 Metrics
				zb0006--
				za0007, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByPool")
					return
				}
				bts, err = za0008.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByPool", za0007)
					return
				}
				z.ByPool[za0007] = za0008
			}
			zb0001Mask |= 0x8
		case "final":
			z.Final, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Final")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Errors = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByHost = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ByDisk = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ByPool = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RealtimeMetrics) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Errors {
		s += msgp.StringPrefixSize + len(z.Errors[za0001])
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Hosts {
		s += msgp.StringPrefixSize + len(z.Hosts[za0002])
	}
	s += 11 + z.Aggregated.Msgsize() + 8 + msgp.MapHeaderSize
	if z.ByHost != nil {
		for za0003, za0004 := range z.ByHost {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.ByDisk != nil {
		for za0005, za0006 := range z.ByDisk {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + za0006.Msgsize()
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.ByPool != nil {
		for za0007, za0008 := range z.ByPool {
			_ = za0008
			s += msgp.StringPrefixSize + len(za0007) + za0008.Msgsize()
		}
	}
	s += 6 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RejectedAPIStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "auth":
			z.Auth, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Auth")
				return
			}
			zb0001Mask |= 0x1
		case "requestsTime":
			z.RequestsTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "RequestsTime")
				return
			}
			zb0001Mask |= 0x2
		case "header":
			z.Header, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Header")
				return
			}
			zb0001Mask |= 0x4
		case "invalid":
			z.Invalid, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Invalid")
				return
			}
			zb0001Mask |= 0x8
		case "notImplemented":
			z.NotImplemented, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "NotImplemented")
				return
			}
			zb0001Mask |= 0x10
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.Auth = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.RequestsTime = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Header = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Invalid = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.NotImplemented = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RejectedAPIStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Auth == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.RequestsTime == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Header == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Invalid == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.NotImplemented == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "auth"
			err = en.Append(0xa4, 0x61, 0x75, 0x74, 0x68)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Auth)
			if err != nil {
				err = msgp.WrapError(err, "Auth")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "requestsTime"
			err = en.Append(0xac, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.RequestsTime)
			if err != nil {
				err = msgp.WrapError(err, "RequestsTime")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "header"
			err = en.Append(0xa6, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Header)
			if err != nil {
				err = msgp.WrapError(err, "Header")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "invalid"
			err = en.Append(0xa7, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Invalid)
			if err != nil {
				err = msgp.WrapError(err, "Invalid")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "notImplemented"
			err = en.Append(0xae, 0x6e, 0x6f, 0x74, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.NotImplemented)
			if err != nil {
				err = msgp.WrapError(err, "NotImplemented")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RejectedAPIStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Auth == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.RequestsTime == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Header == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Invalid == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.NotImplemented == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "auth"
			o = append(o, 0xa4, 0x61, 0x75, 0x74, 0x68)
			o = msgp.AppendInt64(o, z.Auth)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "requestsTime"
			o = append(o, 0xac, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x54, 0x69, 0x6d, 0x65)
			o = msgp.AppendInt64(o, z.RequestsTime)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "header"
			o = append(o, 0xa6, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72)
			o = msgp.AppendInt64(o, z.Header)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "invalid"
			o = append(o, 0xa7, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64)
			o = msgp.AppendInt64(o, z.Invalid)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "notImplemented"
			o = append(o, 0xae, 0x6e, 0x6f, 0x74, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64)
			o = msgp.AppendInt64(o, z.NotImplemented)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RejectedAPIStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "auth":
			z.Auth, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Auth")
				return
			}
			zb0001Mask |= 0x1
		case "requestsTime":
			z.RequestsTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestsTime")
				return
			}
			zb0001Mask |= 0x2
		case "header":
			z.Header, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Header")
				return
			}
			zb0001Mask |= 0x4
		case "invalid":
			z.Invalid, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Invalid")
				return
			}
			zb0001Mask |= 0x8
		case "notImplemented":
			z.NotImplemented, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NotImplemented")
				return
			}
			zb0001Mask |= 0x10
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.Auth = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.RequestsTime = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Header = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Invalid = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.NotImplemented = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RejectedAPIStats) Msgsize() (s int) {
	s = 1 + 5 + msgp.Int64Size + 13 + msgp.Int64Size + 7 + msgp.Int64Size + 8 + msgp.Int64Size + 15 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReplicateInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		case "bytesTransferred":
			z.BytesTransferred, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BytesTransferred")
				return
			}
		case "bytesFailed":
			z.BytesFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReplicateInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "lastBucket"
	err = en.Append(0x88, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	// write "deleteMarkers"
	err = en.Append(0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkers)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkers")
		return
	}
	// write "deleteMarkersFailed"
	err = en.Append(0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkersFailed)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkersFailed")
		return
	}
	// write "bytesTransferred"
	err = en.Append(0xb0, 0x62, 0x79, 0x74, 0x65, 0x73, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BytesTransferred)
	if err != nil {
		err = msgp.WrapError(err, "BytesTransferred")
		return
	}
	// write "bytesFailed"
	err = en.Append(0xab, 0x62, 0x79, 0x74, 0x65, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BytesFailed)
	if err != nil {
		err = msgp.WrapError(err, "BytesFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReplicateInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "lastBucket"
	o = append(o, 0x88, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	// string "deleteMarkers"
	o = append(o, 0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	o = msgp.AppendInt64(o, z.DeleteMarkers)
	// string "deleteMarkersFailed"
	o = append(o, 0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.DeleteMarkersFailed)
	// string "bytesTransferred"
	o = append(o, 0xb0, 0x62, 0x79, 0x74, 0x65, 0x73, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.BytesTransferred)
	// string "bytesFailed"
	o = append(o, 0xab, 0x62, 0x79, 0x74, 0x65, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.BytesFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReplicateInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		case "bytesTransferred":
			z.BytesTransferred, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesTransferred")
				return
			}
		case "bytesFailed":
			z.BytesFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReplicateInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 20 + msgp.Int64Size + 17 + msgp.Int64Size + 12 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RuntimeMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uintMetrics":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			if z.UintMetrics == nil {
				z.UintMetrics = make(map[string]uint64, zb0002)
			} else if len(z.UintMetrics) > 0 {
				for key := range z.UintMetrics {
					delete(z.UintMetrics, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 uint64
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
				z.UintMetrics[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "floatMetrics":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			if z.FloatMetrics == nil {
				z.FloatMetrics = make(map[string]float64, zb0003)
			} else if len(z.FloatMetrics) > 0 {
				for key := range z.FloatMetrics {
					delete(z.FloatMetrics, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 float64
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				za0004, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
				z.FloatMetrics[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "histMetrics":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			if z.HistMetrics == nil {
				z.HistMetrics = make(map[string]metrics.Float64Histogram, zb0004)
			} else if len(z.HistMetrics) > 0 {
				for key := range z.HistMetrics {
					delete(z.HistMetrics, key)
				}
			}
			for zb0004 > 0 {
				zb0004--
				var za0005 string
				var za0006 metrics.Float64Histogram
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				err = (*localF64H)(&za0006).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
				z.HistMetrics[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "n":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.UintMetrics = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.FloatMetrics = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.HistMetrics = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RuntimeMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.UintMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.FloatMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.HistMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "uintMetrics"
			err = en.Append(0xab, 0x75, 0x69, 0x6e, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.UintMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			for za0001, za0002 := range z.UintMetrics {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				err = en.WriteUint64(za0002)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "floatMetrics"
			err = en.Append(0xac, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.FloatMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			for za0003, za0004 := range z.FloatMetrics {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				err = en.WriteFloat64(za0004)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "histMetrics"
			err = en.Append(0xab, 0x68, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.HistMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			for za0005, za0006 := range z.HistMetrics {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				err = (*localF64H)(&za0006).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
			}
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteInt(z.N)
		if err != nil {
			err = msgp.WrapError(err, "N")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RuntimeMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.UintMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.FloatMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.HistMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "uintMetrics"
			o = append(o, 0xab, 0x75, 0x69, 0x6e, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.UintMetrics)))
			for za0001, za0002 := range z.UintMetrics {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendUint64(o, za0002)
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "floatMetrics"
			o = append(o, 0xac, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.FloatMetrics)))
			for za0003, za0004 := range z.FloatMetrics {
				o = msgp.AppendString(o, za0003)
				o = msgp.AppendFloat64(o, za0004)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "histMetrics"
			o = append(o, 0xab, 0x68, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.HistMetrics)))
			for za0005, za0006 := range z.HistMetrics {
				o = msgp.AppendString(o, za0005)
				o, err = (*localF64H)(&za0006).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
			}
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendInt(o, z.N)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RuntimeMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uintMetrics":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			if z.UintMetrics == nil {
				z.UintMetrics = make(map[string]uint64, zb0002)
			} else if len(z.UintMetrics) > 0 {
				for key := range z.UintMetrics {
					delete(z.UintMetrics, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 uint64
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
				z.UintMetrics[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "floatMetrics":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			if z.FloatMetrics == nil {
				z.FloatMetrics = make(map[string]float64, zb0003)
			} else if len(z.FloatMetrics) > 0 {
				for key := range z.FloatMetrics {
					delete(z.FloatMetrics, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 float64
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				za0004, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
				z.FloatMetrics[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "histMetrics":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			if z.HistMetrics == nil {
				z.HistMetrics = make(map[string]metrics.Float64Histogram, zb0004)
			} else if len(z.HistMetrics) > 0 {
				for key := range z.HistMetrics {
					delete(z.HistMetrics, key)
				}
			}
			for zb0004 > 0 {
				var za0005 string
				var za0006 metrics.Float64Histogram
				zb0004--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				bts, err = (*localF64H)(&za0006).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
				z.HistMetrics[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "n":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.UintMetrics = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.FloatMetrics = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.HistMetrics = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RuntimeMetrics) Msgsize() (s int) {
	s = 1 + 12 + msgp.MapHeaderSize
	if z.UintMetrics != nil {
		for za0001, za0002 := range z.UintMetrics {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 13 + msgp.MapHeaderSize
	if z.FloatMetrics != nil {
		for za0003, za0004 := range z.FloatMetrics {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.Float64Size
		}
	}
	s += 12 + msgp.MapHeaderSize
	if z.HistMetrics != nil {
		for za0005, za0006 := range z.HistMetrics {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + (*localF64H)(&za0006).Msgsize()
		}
	}
	s += 2 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ScannerMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "ongoing_buckets":
			z.OngoingBuckets, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OngoingBuckets")
				return
			}
		case "per_bucket_stats":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			if z.PerBucketStats == nil {
				z.PerBucketStats = make(map[string][]BucketScanInfo, zb0002)
			} else if len(z.PerBucketStats) > 0 {
				for key := range z.PerBucketStats {
					delete(z.PerBucketStats, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 []BucketScanInfo
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				var zb0003 uint32
				zb0003, err = dc.ReadArrayHeader()
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0001)
					return
				}
				if cap(za0002) >= int(zb0003) {
					za0002 = (za0002)[:zb0003]
				} else {
					za0002 = make([]BucketScanInfo, zb0003)
				}
				for za0003 := range za0002 {
					err = za0002[za0003].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0001, za0003)
						return
					}
				}
				z.PerBucketStats[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "life_time_ops":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0004)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0004 > 0 {
				zb0004--
				var za0004 string
				var za0005 uint64
				za0004, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0005, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0004)
					return
				}
				z.LifeTimeOps[za0004] = za0005
			}
			zb0001Mask |= 0x2
		case "ilm_ops":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			if z.LifeTimeILM == nil {
				z.LifeTimeILM = make(map[string]uint64, zb0005)
			} else if len(z.LifeTimeILM) > 0 {
				for key := range z.LifeTimeILM {
					delete(z.LifeTimeILM, key)
				}
			}
			for zb0005 > 0 {
				zb0005--
				var za0006 string
				var za0007 uint64
				za0006, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				za0007, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0006)
					return
				}
				z.LifeTimeILM[za0006] = za0007
			}
			zb0001Mask |= 0x4
		case "last_minute":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0006Mask uint8 /* 2 bits */
			_ = zb0006Mask
			for zb0006 > 0 {
				zb0006--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "actions":
					var zb0007 uint32
					zb0007, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					if z.LastMinute.Actions == nil {
						z.LastMinute.Actions = make(map[string]TimedAction, zb0007)
					} else if len(z.LastMinute.Actions) > 0 {
						for key := range z.LastMinute.Actions {
							delete(z.LastMinute.Actions, key)
						}
					}
					for zb0007 > 0 {
						zb0007--
						var za0008 string
						var za0009 TimedAction
						za0008, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions")
							return
						}
						err = za0009.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions", za0008)
							return
						}
						z.LastMinute.Actions[za0008] = za0009
					}
					zb0006Mask |= 0x1
				case "ilm":
					var zb0008 uint32
					zb0008, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					if z.LastMinute.ILM == nil {
						z.LastMinute.ILM = make(map[string]TimedAction, zb0008)
					} else if len(z.LastMinute.ILM) > 0 {
						for key := range z.LastMinute.ILM {
							delete(z.LastMinute.ILM, key)
						}
					}
					for zb0008 > 0 {
						zb0008--
						var za0010 string
						var za0011 TimedAction
						za0010, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM")
							return
						}
						err = za0011.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM", za0010)
							return
						}
						z.LastMinute.ILM[za0010] = za0011
					}
					zb0006Mask |= 0x2
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0006Mask != 0x3 {
				if (zb0006Mask & 0x1) == 0 {
					z.LastMinute.Actions = nil
				}
				if (zb0006Mask & 0x2) == 0 {
					z.LastMinute.ILM = nil
				}
			}
		case "active":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			if cap(z.ActivePaths) >= int(zb0009) {
				z.ActivePaths = (z.ActivePaths)[:zb0009]
			} else {
				z.ActivePaths = make([]string, zb0009)
			}
			for za0012 := range z.ActivePaths {
				z.ActivePaths[za0012], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0012)
					return
				}
			}
			zb0001Mask |= 0x8
		case "excessive":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ExcessivePrefixes")
				return
			}
			if cap(z.ExcessivePrefixes) >= int(zb0010) {
				z.ExcessivePrefixes = (z.ExcessivePrefixes)[:zb0010]
			} else {
				z.ExcessivePrefixes = make([]string, zb0010)
			}
			for za0013 := range z.ExcessivePrefixes {
				z.ExcessivePrefixes[za0013], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ExcessivePrefixes", za0013)
					return
				}
			}
			zb0001Mask |= 0x10
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.PerBucketStats = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LifeTimeILM = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ActivePaths = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.ExcessivePrefixes = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ScannerMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(8)
	var zb0001Mask uint8 /* 8 bits */
	_ = zb0001Mask
	if z.PerBucketStats == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LifeTimeILM == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.ActivePaths == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.ExcessivePrefixes == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "ongoing_buckets"
		err = en.Append(0xaf, 0x6f, 0x6e, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.OngoingBuckets)
		if err != nil {
			err = msgp.WrapError(err, "OngoingBuckets")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "per_bucket_stats"
			err = en.Append(0xb0, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.PerBucketStats)))
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			for za0001, za0002 := range z.PerBucketStats {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				err = en.WriteArrayHeader(uint32(len(za0002)))
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0001)
					return
				}
				for za0003 := range za0002 {
					err = za0002[za0003].EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0001, za0003)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "life_time_ops"
			err = en.Append(0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			for za0004, za0005 := range z.LifeTimeOps {
				err = en.WriteString(za0004)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				err = en.WriteUint64(za0005)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0004)
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "ilm_ops"
			err = en.Append(0xa7, 0x69, 0x6c, 0x6d, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeILM)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			for za0006, za0007 := range z.LifeTimeILM {
				err = en.WriteString(za0006)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				err = en.WriteUint64(za0007)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0006)
					return
				}
			}
		}
		// write "last_minute"
		err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(2)
		var zb0002Mask uint8 /* 2 bits */
		_ = zb0002Mask
		if z.LastMinute.Actions == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		if z.LastMinute.ILM == nil {
			zb0002Len--
			zb0002Mask |= 0x2
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}

		// skip if no fields are to be emitted
		if zb0002Len != 0 {
			if (zb0002Mask & 0x1) == 0 { // if not omitted
				// write "actions"
				err = en.Append(0xa7, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
				if err != nil {
					return
				}
				err = en.WriteMapHeader(uint32(len(z.LastMinute.Actions)))
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Actions")
					return
				}
				for za0008, za0009 := range z.LastMinute.Actions {
					err = en.WriteString(za0008)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					err = za0009.EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions", za0008)
						return
					}
				}
			}
			if (zb0002Mask & 0x2) == 0 { // if not omitted
				// write "ilm"
				err = en.Append(0xa3, 0x69, 0x6c, 0x6d)
				if err != nil {
					return
				}
				err = en.WriteMapHeader(uint32(len(z.LastMinute.ILM)))
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "ILM")
					return
				}
				for za0010, za0011 := range z.LastMinute.ILM {
					err = en.WriteString(za0010)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					err = za0011.EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM", za0010)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "active"
			err = en.Append(0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.ActivePaths)))
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			for za0012 := range z.ActivePaths {
				err = en.WriteString(z.ActivePaths[za0012])
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0012)
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "excessive"
			err = en.Append(0xa9, 0x65, 0x78, 0x63, 0x65, 0x73, 0x73, 0x69, 0x76, 0x65)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.ExcessivePrefixes)))
			if err != nil {
				err = msgp.WrapError(err, "ExcessivePrefixes")
				return
			}
			for za0013 := range z.ExcessivePrefixes {
				err = en.WriteString(z.ExcessivePrefixes[za0013])
				if err != nil {
					err = msgp.WrapError(err, "ExcessivePrefixes", za0013)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ScannerMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(8)
	var zb0001Mask uint8 /* 8 bits */
	_ = zb0001Mask
	if z.PerBucketStats == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LifeTimeILM == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.ActivePaths == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.ExcessivePrefixes == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "ongoing_buckets"
		o = append(o, 0xaf, 0x6f, 0x6e, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendInt(o, z.OngoingBuckets)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "per_bucket_stats"
			o = append(o, 0xb0, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.PerBucketStats)))
			for za0001, za0002 := range z.PerBucketStats {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendArrayHeader(o, uint32(len(za0002)))
				for za0003 := range za0002 {
					o, err = za0002[za0003].MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0001, za0003)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "life_time_ops"
			o = append(o, 0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeOps)))
			for za0004, za0005 := range z.LifeTimeOps {
				o = msgp.AppendString(o, za0004)
				o = msgp.AppendUint64(o, za0005)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "ilm_ops"
			o = append(o, 0xa7, 0x69, 0x6c, 0x6d, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeILM)))
			for za0006, za0007 := range z.LifeTimeILM {
				o = msgp.AppendString(o, za0006)
				o = msgp.AppendUint64(o, za0007)
			}
		}
		// string "last_minute"
		o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		// check for omitted fields
		zb0002Len := uint32(2)
		var zb0002Mask uint8 /* 2 bits */
		_ = zb0002Mask
		if z.LastMinute.Actions == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		if z.LastMinute.ILM == nil {
			zb0002Len--
			zb0002Mask |= 0x2
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))

		// skip if no fields are to be emitted
		if zb0002Len != 0 {
			if (zb0002Mask & 0x1) == 0 { // if not omitted
				// string "actions"
				o = append(o, 0xa7, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
				o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.Actions)))
				for za0008, za0009 := range z.LastMinute.Actions {
					o = msgp.AppendString(o, za0008)
					o, err = za0009.MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions", za0008)
						return
					}
				}
			}
			if (zb0002Mask & 0x2) == 0 { // if not omitted
				// string "ilm"
				o = append(o, 0xa3, 0x69, 0x6c, 0x6d)
				o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.ILM)))
				for za0010, za0011 := range z.LastMinute.ILM {
					o = msgp.AppendString(o, za0010)
					o, err = za0011.MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM", za0010)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "active"
			o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
			o = msgp.AppendArrayHeader(o, uint32(len(z.ActivePaths)))
			for za0012 := range z.ActivePaths {
				o = msgp.AppendString(o, z.ActivePaths[za0012])
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "excessive"
			o = append(o, 0xa9, 0x65, 0x78, 0x63, 0x65, 0x73, 0x73, 0x69, 0x76, 0x65)
			o = msgp.AppendArrayHeader(o, uint32(len(z.ExcessivePrefixes)))
			for za0013 := range z.ExcessivePrefixes {
				o = msgp.AppendString(o, z.ExcessivePrefixes[za0013])
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ScannerMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "ongoing_buckets":
			z.OngoingBuckets, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OngoingBuckets")
				return
			}
		case "per_bucket_stats":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			if z.PerBucketStats == nil {
				z.PerBucketStats = make(map[string][]BucketScanInfo, zb0002)
			} else if len(z.PerBucketStats) > 0 {
				for key := range z.PerBucketStats {
					delete(z.PerBucketStats, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 []BucketScanInfo
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0001)
					return
				}
				if cap(za0002) >= int(zb0003) {
					za0002 = (za0002)[:zb0003]
				} else {
					za0002 = make([]BucketScanInfo, zb0003)
				}
				for za0003 := range za0002 {
					bts, err = za0002[za0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0001, za0003)
						return
					}
				}
				z.PerBucketStats[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "life_time_ops":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0004)
			} else if len(z.LifeTimeOps) > 0 {
				for key := range z.LifeTimeOps {
					delete(z.LifeTimeOps, key)
				}
			}
			for zb0004 > 0 {
				var za0004 string
				var za0005 uint64
				zb0004--
				za0004, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0004)
					return
				}
				z.LifeTimeOps[za0004] = za0005
			}
			zb0001Mask |= 0x2
		case "ilm_ops":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			if z.LifeTimeILM == nil {
				z.LifeTimeILM = make(map[string]uint64, zb0005)
			} else if len(z.LifeTimeILM) > 0 {
				for key := range z.LifeTimeILM {
					delete(z.LifeTimeILM, key)
				}
			}
			for zb0005 > 0 {
				var za0006 string
				var za0007 uint64
				zb0005--
				za0006, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				za0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0006)
					return
				}
				z.LifeTimeILM[za0006] = za0007
			}
			zb0001Mask |= 0x4
		case "last_minute":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0006Mask uint8 /* 2 bits */
			_ = zb0006Mask
			for zb0006 > 0 {
				zb0006--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "actions":
					var zb0007 uint32
					zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					if z.LastMinute.Actions == nil {
						z.LastMinute.Actions = make(map[string]TimedAction, zb0007)
					} else if len(z.LastMinute.Actions) > 0 {
						for key := range z.LastMinute.Actions {
							delete(z.LastMinute.Actions, key)
						}
					}
					for zb0007 > 0 {
						var za0008 string
						var za0009 TimedAction
						zb0007--
						za0008, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions")
							return
						}
						bts, err = za0009.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions", za0008)
							return
						}
						z.LastMinute.Actions[za0008] = za0009
					}
					zb0006Mask |= 0x1
				case "ilm":
					var zb0008 uint32
					zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					if z.LastMinute.ILM == nil {
						z.LastMinute.ILM = make(map[string]TimedAction, zb0008)
					} else if len(z.LastMinute.ILM) > 0 {
						for key := range z.LastMinute.ILM {
							delete(z.LastMinute.ILM, key)
						}
					}
					for zb0008 > 0 {
						var za0010 string
						var za0011 TimedAction
						zb0008--
						za0010, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM")
							return
						}
						bts, err = za0011.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM", za0010)
							return
						}
						z.LastMinute.ILM[za0010] = za0011
					}
					zb0006Mask |= 0x2
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0006Mask != 0x3 {
				if (zb0006Mask & 0x1) == 0 {
					z.LastMinute.Actions = nil
				}
				if (zb0006Mask & 0x2) == 0 {
					z.LastMinute.ILM = nil
				}
			}
		case "active":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			if cap(z.ActivePaths) >= int(zb0009) {
				z.ActivePaths = (z.ActivePaths)[:zb0009]
			} else {
				z.ActivePaths = make([]string, zb0009)
			}
			for za0012 := range z.ActivePaths {
				z.ActivePaths[za0012], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0012)
					return
				}
			}
			zb0001Mask |= 0x8
		case "excessive":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExcessivePrefixes")
				return
			}
			if cap(z.ExcessivePrefixes) >= int(zb0010) {
				z.ExcessivePrefixes = (z.ExcessivePrefixes)[:zb0010]
			} else {
				z.ExcessivePrefixes = make([]string, zb0010)
			}
			for za0013 := range z.ExcessivePrefixes {
				z.ExcessivePrefixes[za0013], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExcessivePrefixes", za0013)
					return
				}
			}
			zb0001Mask |= 0x10
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.PerBucketStats = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LifeTimeILM = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ActivePaths = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.ExcessivePrefixes = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ScannerMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 16 + msgp.IntSize + 17 + msgp.MapHeaderSize
	if z.PerBucketStats != nil {
		for za0001, za0002 := range z.PerBucketStats {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.ArrayHeaderSize
			for za0003 := range za0002 {
				s += za0002[za0003].Msgsize()
			}
		}
	}
	s += 14 + msgp.MapHeaderSize
	if z.LifeTimeOps != nil {
		for za0004, za0005 := range z.LifeTimeOps {
			_ = za0005
			s += msgp.StringPrefixSize + len(za0004) + msgp.Uint64Size
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.LifeTimeILM != nil {
		for za0006, za0007 := range z.LifeTimeILM {
			_ = za0007
			s += msgp.StringPrefixSize + len(za0006) + msgp.Uint64Size
		}
	}
	s += 12 + 1 + 8 + msgp.MapHeaderSize
	if z.LastMinute.Actions != nil {
		for za0008, za0009 := range z.LastMinute.Actions {
			_ = za0009
			s += msgp.StringPrefixSize + len(za0008) + za0009.Msgsize()
		}
	}
	s += 4 + msgp.MapHeaderSize
	if z.LastMinute.ILM != nil {
		for za0010, za0011 := range z.LastMinute.ILM {
			_ = za0011
			s += msgp.StringPrefixSize + len(za0010) + za0011.Msgsize()
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0012 := range z.ActivePaths {
		s += msgp.StringPrefixSize + len(z.ActivePaths[za0012])
	}
	s += 10 + msgp.ArrayHeaderSize
	for za0013 := range z.ExcessivePrefixes {
		s += msgp.StringPrefixSize + len(z.ExcessivePrefixes[za0013])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SegmentedAPIMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "intervalSecs":
			z.Interval, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Interval")
				return
			}
		case "firstTime":
			z.FirstTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "FirstTime")
				return
			}
		case "segments":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Segments")
				return
			}
			if cap(z.Segments) >= int(zb0002) {
				z.Segments = (z.Segments)[:zb0002]
			} else {
				z.Segments = make([]APIStats, zb0002)
			}
			for za0001 := range z.Segments {
				err = z.Segments[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Segments", za0001)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SegmentedAPIMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "intervalSecs"
	err = en.Append(0x83, 0xac, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Interval)
	if err != nil {
		err = msgp.WrapError(err, "Interval")
		return
	}
	// write "firstTime"
	err = en.Append(0xa9, 0x66, 0x69, 0x72, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.FirstTime)
	if err != nil {
		err = msgp.WrapError(err, "FirstTime")
		return
	}
	// write "segments"
	err = en.Append(0xa8, 0x73, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Segments)))
	if err != nil {
		err = msgp.WrapError(err, "Segments")
		return
	}
	for za0001 := range z.Segments {
		err = z.Segments[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Segments", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SegmentedAPIMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "intervalSecs"
	o = append(o, 0x83, 0xac, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x73)
	o = msgp.AppendInt(o, z.Interval)
	// string "firstTime"
	o = append(o, 0xa9, 0x66, 0x69, 0x72, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.FirstTime)
	// string "segments"
	o = append(o, 0xa8, 0x73, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Segments)))
	for za0001 := range z.Segments {
		o, err = z.Segments[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Segments", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SegmentedAPIMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "intervalSecs":
			z.Interval, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Interval")
				return
			}
		case "firstTime":
			z.FirstTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FirstTime")
				return
			}
		case "segments":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Segments")
				return
			}
			if cap(z.Segments) >= int(zb0002) {
				z.Segments = (z.Segments)[:zb0002]
			} else {
				z.Segments = make([]APIStats, zb0002)
			}
			for za0001 := range z.Segments {
				bts, err = z.Segments[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Segments", za0001)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SegmentedAPIMetrics) Msgsize() (s int) {
	s = 1 + 13 + msgp.IntSize + 10 + msgp.TimeSize + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.Segments {
		s += z.Segments[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SiteResyncMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "resyncStatus":
			z.ResyncStatus, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			z.StartTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "numBuckets":
			z.NumBuckets, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "NumBuckets")
				return
			}
		case "resyncID":
			z.ResyncID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ResyncID")
				return
			}
		case "deplID":
			z.DeplID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DeplID")
				return
			}
		case "completedReplicationSize":
			z.ReplicatedSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "replicationCount":
			z.ReplicatedCount, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedCount")
				return
			}
		case "failedReplicationSize":
			z.FailedSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FailedSize")
				return
			}
		case "failedReplicationCount":
			z.FailedCount, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FailedCount")
				return
			}
		case "failedBuckets":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets")
				return
			}
			if cap(z.FailedBuckets) >= int(zb0002) {
				z.FailedBuckets = (z.FailedBuckets)[:zb0002]
			} else {
				z.FailedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.FailedBuckets {
				z.FailedBuckets[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "FailedBuckets", za0001)
					return
				}
			}
		case "bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
			zb0001Mask |= 0x2
		case "object":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
			zb0001Mask |= 0x4
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.ResyncStatus = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Bucket = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Object = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SiteResyncMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.ResyncStatus == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Bucket == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.Object == "" {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "resyncStatus"
			err = en.Append(0xac, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
			if err != nil {
				return
			}
			err = en.WriteString(z.ResyncStatus)
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
		}
		// write "startTime"
		err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.StartTime)
		if err != nil {
			err = msgp.WrapError(err, "StartTime")
			return
		}
		// write "lastUpdate"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastUpdate)
		if err != nil {
			err = msgp.WrapError(err, "LastUpdate")
			return
		}
		// write "numBuckets"
		err = en.Append(0xaa, 0x6e, 0x75, 0x6d, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.NumBuckets)
		if err != nil {
			err = msgp.WrapError(err, "NumBuckets")
			return
		}
		// write "resyncID"
		err = en.Append(0xa8, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.ResyncID)
		if err != nil {
			err = msgp.WrapError(err, "ResyncID")
			return
		}
		// write "deplID"
		err = en.Append(0xa6, 0x64, 0x65, 0x70, 0x6c, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.DeplID)
		if err != nil {
			err = msgp.WrapError(err, "DeplID")
			return
		}
		// write "completedReplicationSize"
		err = en.Append(0xb8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.ReplicatedSize)
		if err != nil {
			err = msgp.WrapError(err, "ReplicatedSize")
			return
		}
		// write "replicationCount"
		err = en.Append(0xb0, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.ReplicatedCount)
		if err != nil {
			err = msgp.WrapError(err, "ReplicatedCount")
			return
		}
		// write "failedReplicationSize"
		err = en.Append(0xb5, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.FailedSize)
		if err != nil {
			err = msgp.WrapError(err, "FailedSize")
			return
		}
		// write "failedReplicationCount"
		err = en.Append(0xb6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.FailedCount)
		if err != nil {
			err = msgp.WrapError(err, "FailedCount")
			return
		}
		// write "failedBuckets"
		err = en.Append(0xad, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.FailedBuckets)))
		if err != nil {
			err = msgp.WrapError(err, "FailedBuckets")
			return
		}
		for za0001 := range z.FailedBuckets {
			err = en.WriteString(z.FailedBuckets[za0001])
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets", za0001)
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "bucket"
			err = en.Append(0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
			if err != nil {
				return
			}
			err = en.WriteString(z.Bucket)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "object"
			err = en.Append(0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
			if err != nil {
				return
			}
			err = en.WriteString(z.Object)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SiteResyncMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.ResyncStatus == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Bucket == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.Object == "" {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "resyncStatus"
			o = append(o, 0xac, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
			o = msgp.AppendString(o, z.ResyncStatus)
		}
		// string "startTime"
		o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.StartTime)
		// string "lastUpdate"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		o = msgp.AppendTime(o, z.LastUpdate)
		// string "numBuckets"
		o = append(o, 0xaa, 0x6e, 0x75, 0x6d, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendInt64(o, z.NumBuckets)
		// string "resyncID"
		o = append(o, 0xa8, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x49, 0x44)
		o = msgp.AppendString(o, z.ResyncID)
		// string "deplID"
		o = append(o, 0xa6, 0x64, 0x65, 0x70, 0x6c, 0x49, 0x44)
		o = msgp.AppendString(o, z.DeplID)
		// string "completedReplicationSize"
		o = append(o, 0xb8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt64(o, z.ReplicatedSize)
		// string "replicationCount"
		o = append(o, 0xb0, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt64(o, z.ReplicatedCount)
		// string "failedReplicationSize"
		o = append(o, 0xb5, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt64(o, z.FailedSize)
		// string "failedReplicationCount"
		o = append(o, 0xb6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt64(o, z.FailedCount)
		// string "failedBuckets"
		o = append(o, 0xad, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.FailedBuckets)))
		for za0001 := range z.FailedBuckets {
			o = msgp.AppendString(o, z.FailedBuckets[za0001])
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "bucket"
			o = append(o, 0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
			o = msgp.AppendString(o, z.Bucket)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "object"
			o = append(o, 0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
			o = msgp.AppendString(o, z.Object)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SiteResyncMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "resyncStatus":
			z.ResyncStatus, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "numBuckets":
			z.NumBuckets, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumBuckets")
				return
			}
		case "resyncID":
			z.ResyncID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResyncID")
				return
			}
		case "deplID":
			z.DeplID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeplID")
				return
			}
		case "completedReplicationSize":
			z.ReplicatedSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "replicationCount":
			z.ReplicatedCount, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedCount")
				return
			}
		case "failedReplicationSize":
			z.FailedSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedSize")
				return
			}
		case "failedReplicationCount":
			z.FailedCount, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedCount")
				return
			}
		case "failedBuckets":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets")
				return
			}
			if cap(z.FailedBuckets) >= int(zb0002) {
				z.FailedBuckets = (z.FailedBuckets)[:zb0002]
			} else {
				z.FailedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.FailedBuckets {
				z.FailedBuckets[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FailedBuckets", za0001)
					return
				}
			}
		case "bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
			zb0001Mask |= 0x2
		case "object":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
			zb0001Mask |= 0x4
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.ResyncStatus = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Bucket = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Object = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SiteResyncMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 13 + msgp.StringPrefixSize + len(z.ResyncStatus) + 10 + msgp.TimeSize + 11 + msgp.TimeSize + 11 + msgp.Int64Size + 9 + msgp.StringPrefixSize + len(z.ResyncID) + 7 + msgp.StringPrefixSize + len(z.DeplID) + 25 + msgp.Int64Size + 17 + msgp.Int64Size + 22 + msgp.Int64Size + 23 + msgp.Int64Size + 14 + msgp.ArrayHeaderSize
	for za0001 := range z.FailedBuckets {
		s += msgp.StringPrefixSize + len(z.FailedBuckets[za0001])
	}
	s += 7 + msgp.StringPrefixSize + len(z.Bucket) + 7 + msgp.StringPrefixSize + len(z.Object)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *localF64H) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "counts":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			if cap(z.Counts) >= int(zb0002) {
				z.Counts = (z.Counts)[:zb0002]
			} else {
				z.Counts = make([]uint64, zb0002)
			}
			for za0001 := range z.Counts {
				z.Counts[za0001], err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "buckets":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			if cap(z.Buckets) >= int(zb0003) {
				z.Buckets = (z.Buckets)[:zb0003]
			} else {
				z.Buckets = make([]float64, zb0003)
			}
			for za0002 := range z.Buckets {
				z.Buckets[za0002], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Counts = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Buckets = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *localF64H) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Counts == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Buckets == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "counts"
			err = en.Append(0xa6, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Counts)))
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			for za0001 := range z.Counts {
				err = en.WriteUint64(z.Counts[za0001])
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "buckets"
			err = en.Append(0xa7, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Buckets)))
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			for za0002 := range z.Buckets {
				err = en.WriteFloat64(z.Buckets[za0002])
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *localF64H) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Counts == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Buckets == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "counts"
			o = append(o, 0xa6, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Counts)))
			for za0001 := range z.Counts {
				o = msgp.AppendUint64(o, z.Counts[za0001])
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "buckets"
			o = append(o, 0xa7, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Buckets)))
			for za0002 := range z.Buckets {
				o = msgp.AppendFloat64(o, z.Buckets[za0002])
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *localF64H) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "counts":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			if cap(z.Counts) >= int(zb0002) {
				z.Counts = (z.Counts)[:zb0002]
			} else {
				z.Counts = make([]uint64, zb0002)
			}
			for za0001 := range z.Counts {
				z.Counts[za0001], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "buckets":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			if cap(z.Buckets) >= int(zb0003) {
				z.Buckets = (z.Buckets)[:zb0003]
			} else {
				z.Buckets = make([]float64, zb0003)
			}
			for za0002 := range z.Buckets {
				z.Buckets[za0002], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Counts = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Buckets = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *localF64H) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize + (len(z.Counts) * (msgp.Uint64Size)) + 8 + msgp.ArrayHeaderSize + (len(z.Buckets) * (msgp.Float64Size))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *nodeCommon) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			z.Addr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Addr")
				return
			}
		case "error":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.Error = ""
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z nodeCommon) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "addr"
		err = en.Append(0xa4, 0x61, 0x64, 0x64, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.Addr)
		if err != nil {
			err = msgp.WrapError(err, "Addr")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "error"
			err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			if err != nil {
				return
			}
			err = en.WriteString(z.Error)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z nodeCommon) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "addr"
		o = append(o, 0xa4, 0x61, 0x64, 0x64, 0x72)
		o = msgp.AppendString(o, z.Addr)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "error"
			o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			o = msgp.AppendString(o, z.Error)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *nodeCommon) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			z.Addr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Addr")
				return
			}
		case "error":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.Error = ""
	}

	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z nodeCommon) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Addr) + 6 + msgp.StringPrefixSize + len(z.Error)
	return
}
