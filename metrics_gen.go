// Code generated by github.com/tinylib/msgp DO NOT EDIT.

package madmin

import (
	"runtime/metrics"
	"time"

	"github.com/shirou/gopsutil/v4/cpu"
	"github.com/shirou/gopsutil/v4/load"
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *APIMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "activeRequests":
			z.ActiveRequests, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ActiveRequests")
				return
			}
			zb0001Mask |= 0x1
		case "queuedRequests":
			z.QueuedRequests, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "QueuedRequests")
				return
			}
			zb0001Mask |= 0x2
		case "lastMinuteApi":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinuteAPI")
				return
			}
			if z.LastMinuteAPI == nil {
				z.LastMinuteAPI = make(map[string]APIStats, zb0002)
			} else if len(z.LastMinuteAPI) > 0 {
				clear(z.LastMinuteAPI)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI")
					return
				}
				var za0002 APIStats
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI", za0001)
					return
				}
				z.LastMinuteAPI[za0001] = za0002
			}
			zb0001Mask |= 0x4
		case "lastDayApi":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastDayAPI")
				return
			}
			if z.LastDayAPI == nil {
				z.LastDayAPI = make(map[string]SegmentedAPIMetrics, zb0003)
			} else if len(z.LastDayAPI) > 0 {
				clear(z.LastDayAPI)
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI")
					return
				}
				var za0004 SegmentedAPIMetrics
				err = (*Segmented[APIStats, *APIStats])(&za0004).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI", za0003)
					return
				}
				z.LastDayAPI[za0003] = za0004
			}
			zb0001Mask |= 0x8
		case "since_start":
			err = z.SinceStart.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "SinceStart")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.ActiveRequests = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.QueuedRequests = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LastMinuteAPI = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.LastDayAPI = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *APIMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.ActiveRequests == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.QueuedRequests == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LastMinuteAPI == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.LastDayAPI == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "nodes"
		err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Nodes)
		if err != nil {
			err = msgp.WrapError(err, "Nodes")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "activeRequests"
			err = en.Append(0xae, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ActiveRequests)
			if err != nil {
				err = msgp.WrapError(err, "ActiveRequests")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "queuedRequests"
			err = en.Append(0xae, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.QueuedRequests)
			if err != nil {
				err = msgp.WrapError(err, "QueuedRequests")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "lastMinuteApi"
			err = en.Append(0xad, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x41, 0x70, 0x69)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinuteAPI)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinuteAPI")
				return
			}
			for za0001, za0002 := range z.LastMinuteAPI {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI")
					return
				}
				err = za0002.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "lastDayApi"
			err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x79, 0x41, 0x70, 0x69)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastDayAPI)))
			if err != nil {
				err = msgp.WrapError(err, "LastDayAPI")
				return
			}
			for za0003, za0004 := range z.LastDayAPI {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI")
					return
				}
				err = (*Segmented[APIStats, *APIStats])(&za0004).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI", za0003)
					return
				}
			}
		}
		// write "since_start"
		err = en.Append(0xab, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74)
		if err != nil {
			return
		}
		err = z.SinceStart.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "SinceStart")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *APIMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.ActiveRequests == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.QueuedRequests == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LastMinuteAPI == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.LastDayAPI == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "nodes"
		o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		o = msgp.AppendInt(o, z.Nodes)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "activeRequests"
			o = append(o, 0xae, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			o = msgp.AppendInt64(o, z.ActiveRequests)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "queuedRequests"
			o = append(o, 0xae, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			o = msgp.AppendInt64(o, z.QueuedRequests)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "lastMinuteApi"
			o = append(o, 0xad, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x41, 0x70, 0x69)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinuteAPI)))
			for za0001, za0002 := range z.LastMinuteAPI {
				o = msgp.AppendString(o, za0001)
				o, err = za0002.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "lastDayApi"
			o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x79, 0x41, 0x70, 0x69)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastDayAPI)))
			for za0003, za0004 := range z.LastDayAPI {
				o = msgp.AppendString(o, za0003)
				o, err = (*Segmented[APIStats, *APIStats])(&za0004).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI", za0003)
					return
				}
			}
		}
		// string "since_start"
		o = append(o, 0xab, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74)
		o, err = z.SinceStart.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "SinceStart")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *APIMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "activeRequests":
			z.ActiveRequests, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActiveRequests")
				return
			}
			zb0001Mask |= 0x1
		case "queuedRequests":
			z.QueuedRequests, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QueuedRequests")
				return
			}
			zb0001Mask |= 0x2
		case "lastMinuteApi":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinuteAPI")
				return
			}
			if z.LastMinuteAPI == nil {
				z.LastMinuteAPI = make(map[string]APIStats, zb0002)
			} else if len(z.LastMinuteAPI) > 0 {
				clear(z.LastMinuteAPI)
			}
			for zb0002 > 0 {
				var za0002 APIStats
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinuteAPI", za0001)
					return
				}
				z.LastMinuteAPI[za0001] = za0002
			}
			zb0001Mask |= 0x4
		case "lastDayApi":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastDayAPI")
				return
			}
			if z.LastDayAPI == nil {
				z.LastDayAPI = make(map[string]SegmentedAPIMetrics, zb0003)
			} else if len(z.LastDayAPI) > 0 {
				clear(z.LastDayAPI)
			}
			for zb0003 > 0 {
				var za0004 SegmentedAPIMetrics
				zb0003--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI")
					return
				}
				bts, err = (*Segmented[APIStats, *APIStats])(&za0004).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDayAPI", za0003)
					return
				}
				z.LastDayAPI[za0003] = za0004
			}
			zb0001Mask |= 0x8
		case "since_start":
			bts, err = z.SinceStart.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "SinceStart")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.ActiveRequests = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.QueuedRequests = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LastMinuteAPI = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.LastDayAPI = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *APIMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 6 + msgp.IntSize + 15 + msgp.Int64Size + 15 + msgp.Int64Size + 14 + msgp.MapHeaderSize
	if z.LastMinuteAPI != nil {
		for za0001, za0002 := range z.LastMinuteAPI {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += 11 + msgp.MapHeaderSize
	if z.LastDayAPI != nil {
		for za0003, za0004 := range z.LastDayAPI {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + (*Segmented[APIStats, *APIStats])(&za0004).Msgsize()
		}
	}
	s += 12 + z.SinceStart.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *APIStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 25 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
				z.StartTime = nil
			} else {
				if z.StartTime == nil {
					z.StartTime = new(time.Time)
				}
				*z.StartTime, err = dc.ReadTimeUTC()
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
			zb0001Mask |= 0x2
		case "endTime":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
				z.EndTime = nil
			} else {
				if z.EndTime == nil {
					z.EndTime = new(time.Time)
				}
				*z.EndTime, err = dc.ReadTimeUTC()
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
			zb0001Mask |= 0x4
		case "wallTimeSecs":
			z.WallTimeSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
			zb0001Mask |= 0x8
		case "requests":
			z.Requests, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
			zb0001Mask |= 0x10
		case "incomingBytes":
			z.IncomingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x20
		case "outgoingBytes":
			z.OutgoingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x40
		case "errors_4xx":
			z.Errors4xx, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Errors4xx")
				return
			}
			zb0001Mask |= 0x80
		case "errors_5xx":
			z.Errors5xx, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Errors5xx")
				return
			}
			zb0001Mask |= 0x100
		case "canceled":
			z.Canceled, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Canceled")
				return
			}
			zb0001Mask |= 0x200
		case "requestTimeSecs":
			z.RequestTimeSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
			zb0001Mask |= 0x400
		case "reqReadSecs":
			z.ReqReadSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecs")
				return
			}
			zb0001Mask |= 0x800
		case "respSecs":
			z.RespSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespSecs")
				return
			}
			zb0001Mask |= 0x1000
		case "respTtfbSecs":
			z.RespTTFBSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecs")
				return
			}
			zb0001Mask |= 0x2000
		case "readBlocked":
			z.ReadBlockedSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReadBlockedSecs")
				return
			}
			zb0001Mask |= 0x4000
		case "writeBlocked":
			z.WriteBlockedSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WriteBlockedSecs")
				return
			}
			zb0001Mask |= 0x8000
		case "requestTimeSecsMin":
			z.RequestTimeSecsMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMin")
				return
			}
			zb0001Mask |= 0x10000
		case "requestTimeSecsMax":
			z.RequestTimeSecsMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMax")
				return
			}
			zb0001Mask |= 0x20000
		case "reqReadSecsMin":
			z.ReqReadSecsMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMin")
				return
			}
			zb0001Mask |= 0x40000
		case "reqReadSecsMax":
			z.ReqReadSecsMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMax")
				return
			}
			zb0001Mask |= 0x80000
		case "respSecsMin":
			z.RespSecsMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMin")
				return
			}
			zb0001Mask |= 0x100000
		case "respSecsMax":
			z.RespSecsMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMax")
				return
			}
			zb0001Mask |= 0x200000
		case "respTtfbSecsMin":
			z.RespTTFBSecsMin, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMin")
				return
			}
			zb0001Mask |= 0x400000
		case "respTtfbSecsMax":
			z.RespTTFBSecsMax, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMax")
				return
			}
			zb0001Mask |= 0x800000
		case "rejected":
			err = z.Rejected.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Rejected")
				return
			}
			zb0001Mask |= 0x1000000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ffffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.StartTime = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.EndTime = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.WallTimeSecs = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Requests = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.OutgoingBytes = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Errors4xx = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Errors5xx = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Canceled = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.RequestTimeSecs = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReqReadSecs = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.RespSecs = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.RespTTFBSecs = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.ReadBlockedSecs = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.WriteBlockedSecs = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.RequestTimeSecsMin = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.RequestTimeSecsMax = 0
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.ReqReadSecsMin = 0
		}
		if (zb0001Mask & 0x80000) == 0 {
			z.ReqReadSecsMax = 0
		}
		if (zb0001Mask & 0x100000) == 0 {
			z.RespSecsMin = 0
		}
		if (zb0001Mask & 0x200000) == 0 {
			z.RespSecsMax = 0
		}
		if (zb0001Mask & 0x400000) == 0 {
			z.RespTTFBSecsMin = 0
		}
		if (zb0001Mask & 0x800000) == 0 {
			z.RespTTFBSecsMax = 0
		}
		if (zb0001Mask & 0x1000000) == 0 {
			z.Rejected = RejectedAPIStats{}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *APIStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(25)
	var zb0001Mask uint32 /* 25 bits */
	_ = zb0001Mask
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.StartTime == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.EndTime == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.WallTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Requests == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Errors4xx == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Errors5xx == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Canceled == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RequestTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.ReqReadSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.RespSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.RespTTFBSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.ReadBlockedSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.WriteBlockedSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.RequestTimeSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.RequestTimeSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.ReqReadSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.ReqReadSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.RespSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x100000
	}
	if z.RespSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x200000
	}
	if z.RespTTFBSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x400000
	}
	if z.RespTTFBSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x800000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "nodes"
			err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Nodes)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "startTime"
			err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			if z.StartTime == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteTime(*z.StartTime)
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "endTime"
			err = en.Append(0xa7, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			if z.EndTime == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteTime(*z.EndTime)
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "wallTimeSecs"
			err = en.Append(0xac, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.WallTimeSecs)
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "requests"
			err = en.Append(0xa8, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Requests)
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "incomingBytes"
			err = en.Append(0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.IncomingBytes)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "outgoingBytes"
			err = en.Append(0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.OutgoingBytes)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "errors_4xx"
			err = en.Append(0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x5f, 0x34, 0x78, 0x78)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Errors4xx)
			if err != nil {
				err = msgp.WrapError(err, "Errors4xx")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "errors_5xx"
			err = en.Append(0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x5f, 0x35, 0x78, 0x78)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Errors5xx)
			if err != nil {
				err = msgp.WrapError(err, "Errors5xx")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "canceled"
			err = en.Append(0xa8, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Canceled)
			if err != nil {
				err = msgp.WrapError(err, "Canceled")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "requestTimeSecs"
			err = en.Append(0xaf, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RequestTimeSecs)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "reqReadSecs"
			err = en.Append(0xab, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.ReqReadSecs)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecs")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "respSecs"
			err = en.Append(0xa8, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespSecs)
			if err != nil {
				err = msgp.WrapError(err, "RespSecs")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "respTtfbSecs"
			err = en.Append(0xac, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespTTFBSecs)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecs")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "readBlocked"
			err = en.Append(0xab, 0x72, 0x65, 0x61, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.ReadBlockedSecs)
			if err != nil {
				err = msgp.WrapError(err, "ReadBlockedSecs")
				return
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "writeBlocked"
			err = en.Append(0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.WriteBlockedSecs)
			if err != nil {
				err = msgp.WrapError(err, "WriteBlockedSecs")
				return
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "requestTimeSecsMin"
			err = en.Append(0xb2, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RequestTimeSecsMin)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMin")
				return
			}
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// write "requestTimeSecsMax"
			err = en.Append(0xb2, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RequestTimeSecsMax)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMax")
				return
			}
		}
		if (zb0001Mask & 0x40000) == 0 { // if not omitted
			// write "reqReadSecsMin"
			err = en.Append(0xae, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.ReqReadSecsMin)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMin")
				return
			}
		}
		if (zb0001Mask & 0x80000) == 0 { // if not omitted
			// write "reqReadSecsMax"
			err = en.Append(0xae, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.ReqReadSecsMax)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMax")
				return
			}
		}
		if (zb0001Mask & 0x100000) == 0 { // if not omitted
			// write "respSecsMin"
			err = en.Append(0xab, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespSecsMin)
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMin")
				return
			}
		}
		if (zb0001Mask & 0x200000) == 0 { // if not omitted
			// write "respSecsMax"
			err = en.Append(0xab, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespSecsMax)
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMax")
				return
			}
		}
		if (zb0001Mask & 0x400000) == 0 { // if not omitted
			// write "respTtfbSecsMin"
			err = en.Append(0xaf, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespTTFBSecsMin)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMin")
				return
			}
		}
		if (zb0001Mask & 0x800000) == 0 { // if not omitted
			// write "respTtfbSecsMax"
			err = en.Append(0xaf, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RespTTFBSecsMax)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMax")
				return
			}
		}
		// write "rejected"
		err = en.Append(0xa8, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = z.Rejected.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Rejected")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *APIStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(25)
	var zb0001Mask uint32 /* 25 bits */
	_ = zb0001Mask
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.StartTime == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.EndTime == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.WallTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Requests == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Errors4xx == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Errors5xx == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Canceled == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RequestTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.ReqReadSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.RespSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.RespTTFBSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.ReadBlockedSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.WriteBlockedSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.RequestTimeSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.RequestTimeSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.ReqReadSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.ReqReadSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.RespSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x100000
	}
	if z.RespSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x200000
	}
	if z.RespTTFBSecsMin == 0 {
		zb0001Len--
		zb0001Mask |= 0x400000
	}
	if z.RespTTFBSecsMax == 0 {
		zb0001Len--
		zb0001Mask |= 0x800000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "nodes"
			o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			o = msgp.AppendInt(o, z.Nodes)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "startTime"
			o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if z.StartTime == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendTime(o, *z.StartTime)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "endTime"
			o = append(o, 0xa7, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
			if z.EndTime == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendTime(o, *z.EndTime)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "wallTimeSecs"
			o = append(o, 0xac, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.WallTimeSecs)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "requests"
			o = append(o, 0xa8, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			o = msgp.AppendInt64(o, z.Requests)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "incomingBytes"
			o = append(o, 0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.IncomingBytes)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "outgoingBytes"
			o = append(o, 0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.OutgoingBytes)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "errors_4xx"
			o = append(o, 0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x5f, 0x34, 0x78, 0x78)
			o = msgp.AppendInt(o, z.Errors4xx)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "errors_5xx"
			o = append(o, 0xaa, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x5f, 0x35, 0x78, 0x78)
			o = msgp.AppendInt(o, z.Errors5xx)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "canceled"
			o = append(o, 0xa8, 0x63, 0x61, 0x6e, 0x63, 0x65, 0x6c, 0x65, 0x64)
			o = msgp.AppendInt64(o, z.Canceled)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "requestTimeSecs"
			o = append(o, 0xaf, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.RequestTimeSecs)
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "reqReadSecs"
			o = append(o, 0xab, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.ReqReadSecs)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "respSecs"
			o = append(o, 0xa8, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.RespSecs)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "respTtfbSecs"
			o = append(o, 0xac, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.RespTTFBSecs)
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "readBlocked"
			o = append(o, 0xab, 0x72, 0x65, 0x61, 0x64, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64)
			o = msgp.AppendFloat64(o, z.ReadBlockedSecs)
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "writeBlocked"
			o = append(o, 0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64)
			o = msgp.AppendFloat64(o, z.WriteBlockedSecs)
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "requestTimeSecsMin"
			o = append(o, 0xb2, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			o = msgp.AppendFloat64(o, z.RequestTimeSecsMin)
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// string "requestTimeSecsMax"
			o = append(o, 0xb2, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			o = msgp.AppendFloat64(o, z.RequestTimeSecsMax)
		}
		if (zb0001Mask & 0x40000) == 0 { // if not omitted
			// string "reqReadSecsMin"
			o = append(o, 0xae, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			o = msgp.AppendFloat64(o, z.ReqReadSecsMin)
		}
		if (zb0001Mask & 0x80000) == 0 { // if not omitted
			// string "reqReadSecsMax"
			o = append(o, 0xae, 0x72, 0x65, 0x71, 0x52, 0x65, 0x61, 0x64, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			o = msgp.AppendFloat64(o, z.ReqReadSecsMax)
		}
		if (zb0001Mask & 0x100000) == 0 { // if not omitted
			// string "respSecsMin"
			o = append(o, 0xab, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			o = msgp.AppendFloat64(o, z.RespSecsMin)
		}
		if (zb0001Mask & 0x200000) == 0 { // if not omitted
			// string "respSecsMax"
			o = append(o, 0xab, 0x72, 0x65, 0x73, 0x70, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			o = msgp.AppendFloat64(o, z.RespSecsMax)
		}
		if (zb0001Mask & 0x400000) == 0 { // if not omitted
			// string "respTtfbSecsMin"
			o = append(o, 0xaf, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x69, 0x6e)
			o = msgp.AppendFloat64(o, z.RespTTFBSecsMin)
		}
		if (zb0001Mask & 0x800000) == 0 { // if not omitted
			// string "respTtfbSecsMax"
			o = append(o, 0xaf, 0x72, 0x65, 0x73, 0x70, 0x54, 0x74, 0x66, 0x62, 0x53, 0x65, 0x63, 0x73, 0x4d, 0x61, 0x78)
			o = msgp.AppendFloat64(o, z.RespTTFBSecsMax)
		}
		// string "rejected"
		o = append(o, 0xa8, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64)
		o, err = z.Rejected.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Rejected")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *APIStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 25 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StartTime = nil
			} else {
				if z.StartTime == nil {
					z.StartTime = new(time.Time)
				}
				*z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
			zb0001Mask |= 0x2
		case "endTime":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EndTime = nil
			} else {
				if z.EndTime == nil {
					z.EndTime = new(time.Time)
				}
				*z.EndTime, bts, err = msgp.ReadTimeUTCBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
			zb0001Mask |= 0x4
		case "wallTimeSecs":
			z.WallTimeSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
			zb0001Mask |= 0x8
		case "requests":
			z.Requests, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
			zb0001Mask |= 0x10
		case "incomingBytes":
			z.IncomingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x20
		case "outgoingBytes":
			z.OutgoingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x40
		case "errors_4xx":
			z.Errors4xx, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors4xx")
				return
			}
			zb0001Mask |= 0x80
		case "errors_5xx":
			z.Errors5xx, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors5xx")
				return
			}
			zb0001Mask |= 0x100
		case "canceled":
			z.Canceled, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Canceled")
				return
			}
			zb0001Mask |= 0x200
		case "requestTimeSecs":
			z.RequestTimeSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
			zb0001Mask |= 0x400
		case "reqReadSecs":
			z.ReqReadSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecs")
				return
			}
			zb0001Mask |= 0x800
		case "respSecs":
			z.RespSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespSecs")
				return
			}
			zb0001Mask |= 0x1000
		case "respTtfbSecs":
			z.RespTTFBSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecs")
				return
			}
			zb0001Mask |= 0x2000
		case "readBlocked":
			z.ReadBlockedSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadBlockedSecs")
				return
			}
			zb0001Mask |= 0x4000
		case "writeBlocked":
			z.WriteBlockedSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteBlockedSecs")
				return
			}
			zb0001Mask |= 0x8000
		case "requestTimeSecsMin":
			z.RequestTimeSecsMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMin")
				return
			}
			zb0001Mask |= 0x10000
		case "requestTimeSecsMax":
			z.RequestTimeSecsMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecsMax")
				return
			}
			zb0001Mask |= 0x20000
		case "reqReadSecsMin":
			z.ReqReadSecsMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMin")
				return
			}
			zb0001Mask |= 0x40000
		case "reqReadSecsMax":
			z.ReqReadSecsMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqReadSecsMax")
				return
			}
			zb0001Mask |= 0x80000
		case "respSecsMin":
			z.RespSecsMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMin")
				return
			}
			zb0001Mask |= 0x100000
		case "respSecsMax":
			z.RespSecsMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespSecsMax")
				return
			}
			zb0001Mask |= 0x200000
		case "respTtfbSecsMin":
			z.RespTTFBSecsMin, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMin")
				return
			}
			zb0001Mask |= 0x400000
		case "respTtfbSecsMax":
			z.RespTTFBSecsMax, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RespTTFBSecsMax")
				return
			}
			zb0001Mask |= 0x800000
		case "rejected":
			bts, err = z.Rejected.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Rejected")
				return
			}
			zb0001Mask |= 0x1000000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ffffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.StartTime = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.EndTime = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.WallTimeSecs = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Requests = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.OutgoingBytes = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Errors4xx = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Errors5xx = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Canceled = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.RequestTimeSecs = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReqReadSecs = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.RespSecs = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.RespTTFBSecs = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.ReadBlockedSecs = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.WriteBlockedSecs = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.RequestTimeSecsMin = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.RequestTimeSecsMax = 0
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.ReqReadSecsMin = 0
		}
		if (zb0001Mask & 0x80000) == 0 {
			z.ReqReadSecsMax = 0
		}
		if (zb0001Mask & 0x100000) == 0 {
			z.RespSecsMin = 0
		}
		if (zb0001Mask & 0x200000) == 0 {
			z.RespSecsMax = 0
		}
		if (zb0001Mask & 0x400000) == 0 {
			z.RespTTFBSecsMin = 0
		}
		if (zb0001Mask & 0x800000) == 0 {
			z.RespTTFBSecsMax = 0
		}
		if (zb0001Mask & 0x1000000) == 0 {
			z.Rejected = RejectedAPIStats{}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *APIStats) Msgsize() (s int) {
	s = 3 + 6 + msgp.IntSize + 10
	if z.StartTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 8
	if z.EndTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 13 + msgp.Float64Size + 9 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 11 + msgp.IntSize + 11 + msgp.IntSize + 9 + msgp.Int64Size + 16 + msgp.Float64Size + 12 + msgp.Float64Size + 9 + msgp.Float64Size + 13 + msgp.Float64Size + 12 + msgp.Float64Size + 13 + msgp.Float64Size + 19 + msgp.Float64Size + 19 + msgp.Float64Size + 15 + msgp.Float64Size + 15 + msgp.Float64Size + 12 + msgp.Float64Size + 12 + msgp.Float64Size + 16 + msgp.Float64Size + 16 + msgp.Float64Size + 9 + z.Rejected.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BatchJobMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "Jobs":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Jobs")
				return
			}
			if z.Jobs == nil {
				z.Jobs = make(map[string]JobMetric, zb0002)
			} else if len(z.Jobs) > 0 {
				clear(z.Jobs)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Jobs")
					return
				}
				var za0002 JobMetric
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Jobs", za0001)
					return
				}
				z.Jobs[za0001] = za0002
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BatchJobMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "collected"
	err = en.Append(0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "Jobs"
	err = en.Append(0xa4, 0x4a, 0x6f, 0x62, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Jobs)))
	if err != nil {
		err = msgp.WrapError(err, "Jobs")
		return
	}
	for za0001, za0002 := range z.Jobs {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Jobs")
			return
		}
		err = za0002.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Jobs", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BatchJobMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "collected"
	o = append(o, 0x82, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "Jobs"
	o = append(o, 0xa4, 0x4a, 0x6f, 0x62, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Jobs)))
	for za0001, za0002 := range z.Jobs {
		o = msgp.AppendString(o, za0001)
		o, err = za0002.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Jobs", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BatchJobMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "Jobs":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Jobs")
				return
			}
			if z.Jobs == nil {
				z.Jobs = make(map[string]JobMetric, zb0002)
			} else if len(z.Jobs) > 0 {
				clear(z.Jobs)
			}
			for zb0002 > 0 {
				var za0002 JobMetric
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Jobs")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Jobs", za0001)
					return
				}
				z.Jobs[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BatchJobMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 5 + msgp.MapHeaderSize
	if z.Jobs != nil {
		for za0001, za0002 := range z.Jobs {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CPUMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 12 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "timesStat":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
				z.TimesStat = nil
			} else {
				if z.TimesStat == nil {
					z.TimesStat = new(cpu.TimesStat)
				}
				err = (*cpuTimesStat)(z.TimesStat).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
			}
		case "loadStat":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
				z.LoadStat = nil
			} else {
				if z.LoadStat == nil {
					z.LoadStat = new(load.AvgStat)
				}
				err = (*loadAvgStat)(z.LoadStat).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
			}
		case "cpuCount":
			z.CPUCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CPUCount")
				return
			}
		case "cpu_by_model":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "CPUByModel")
				return
			}
			if z.CPUByModel == nil {
				z.CPUByModel = make(map[string]int, zb0002)
			} else if len(z.CPUByModel) > 0 {
				clear(z.CPUByModel)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "CPUByModel")
					return
				}
				var za0002 int
				za0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CPUByModel", za0001)
					return
				}
				z.CPUByModel[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "total_mhz":
			z.TotalMhz, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TotalMhz")
				return
			}
			zb0001Mask |= 0x2
		case "total_cores":
			z.TotalCores, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TotalCores")
				return
			}
			zb0001Mask |= 0x4
		case "total_cache_size":
			z.TotalCacheSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TotalCacheSize")
				return
			}
			zb0001Mask |= 0x8
		case "freq_stats_count":
			z.FreqStatsCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "FreqStatsCount")
				return
			}
			zb0001Mask |= 0x10
		case "governor_freq":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "GovernorFreq")
				return
			}
			if z.GovernorFreq == nil {
				z.GovernorFreq = make(map[string]int, zb0003)
			} else if len(z.GovernorFreq) > 0 {
				clear(z.GovernorFreq)
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "GovernorFreq")
					return
				}
				var za0004 int
				za0004, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "GovernorFreq", za0003)
					return
				}
				z.GovernorFreq[za0003] = za0004
			}
			zb0001Mask |= 0x20
		case "total_current_freq":
			z.TotalCurrentFreq, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalCurrentFreq")
				return
			}
			zb0001Mask |= 0x40
		case "total_scaling_current_freq":
			z.TotalScalingCurrentFreq, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalScalingCurrentFreq")
				return
			}
			zb0001Mask |= 0x80
		case "min_freq":
			z.MinCPUInfoFreq, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MinCPUInfoFreq")
				return
			}
			zb0001Mask |= 0x100
		case "max_freq":
			z.MaxCPUInfoFreq, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MaxCPUInfoFreq")
				return
			}
			zb0001Mask |= 0x200
		case "min_scaling_freq":
			z.MinScalingFreq, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MinScalingFreq")
				return
			}
			zb0001Mask |= 0x400
		case "max_scaling_freq":
			z.MaxScalingFreq, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MaxScalingFreq")
				return
			}
			zb0001Mask |= 0x800
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xfff {
		if (zb0001Mask & 0x1) == 0 {
			z.CPUByModel = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.TotalMhz = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.TotalCores = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.TotalCacheSize = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.FreqStatsCount = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.GovernorFreq = nil
		}
		if (zb0001Mask & 0x40) == 0 {
			z.TotalCurrentFreq = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.TotalScalingCurrentFreq = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.MinCPUInfoFreq = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.MaxCPUInfoFreq = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.MinScalingFreq = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.MaxScalingFreq = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CPUMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.CPUByModel == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TotalMhz == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.TotalCores == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.TotalCacheSize == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.FreqStatsCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.GovernorFreq == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.TotalCurrentFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.TotalScalingCurrentFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.MinCPUInfoFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.MaxCPUInfoFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.MinScalingFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.MaxScalingFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "nodes"
		err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Nodes)
		if err != nil {
			err = msgp.WrapError(err, "Nodes")
			return
		}
		// write "timesStat"
		err = en.Append(0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74)
		if err != nil {
			return
		}
		if z.TimesStat == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = (*cpuTimesStat)(z.TimesStat).EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "TimesStat")
				return
			}
		}
		// write "loadStat"
		err = en.Append(0xa8, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74)
		if err != nil {
			return
		}
		if z.LoadStat == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = (*loadAvgStat)(z.LoadStat).EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "LoadStat")
				return
			}
		}
		// write "cpuCount"
		err = en.Append(0xa8, 0x63, 0x70, 0x75, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.CPUCount)
		if err != nil {
			err = msgp.WrapError(err, "CPUCount")
			return
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "cpu_by_model"
			err = en.Append(0xac, 0x63, 0x70, 0x75, 0x5f, 0x62, 0x79, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.CPUByModel)))
			if err != nil {
				err = msgp.WrapError(err, "CPUByModel")
				return
			}
			for za0001, za0002 := range z.CPUByModel {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "CPUByModel")
					return
				}
				err = en.WriteInt(za0002)
				if err != nil {
					err = msgp.WrapError(err, "CPUByModel", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "total_mhz"
			err = en.Append(0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6d, 0x68, 0x7a)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.TotalMhz)
			if err != nil {
				err = msgp.WrapError(err, "TotalMhz")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "total_cores"
			err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x72, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.TotalCores)
			if err != nil {
				err = msgp.WrapError(err, "TotalCores")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "total_cache_size"
			err = en.Append(0xb0, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.TotalCacheSize)
			if err != nil {
				err = msgp.WrapError(err, "TotalCacheSize")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "freq_stats_count"
			err = en.Append(0xb0, 0x66, 0x72, 0x65, 0x71, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.FreqStatsCount)
			if err != nil {
				err = msgp.WrapError(err, "FreqStatsCount")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "governor_freq"
			err = en.Append(0xad, 0x67, 0x6f, 0x76, 0x65, 0x72, 0x6e, 0x6f, 0x72, 0x5f, 0x66, 0x72, 0x65, 0x71)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.GovernorFreq)))
			if err != nil {
				err = msgp.WrapError(err, "GovernorFreq")
				return
			}
			for za0003, za0004 := range z.GovernorFreq {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "GovernorFreq")
					return
				}
				err = en.WriteInt(za0004)
				if err != nil {
					err = msgp.WrapError(err, "GovernorFreq", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "total_current_freq"
			err = en.Append(0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x66, 0x72, 0x65, 0x71)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalCurrentFreq)
			if err != nil {
				err = msgp.WrapError(err, "TotalCurrentFreq")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "total_scaling_current_freq"
			err = en.Append(0xba, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x66, 0x72, 0x65, 0x71)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalScalingCurrentFreq)
			if err != nil {
				err = msgp.WrapError(err, "TotalScalingCurrentFreq")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "min_freq"
			err = en.Append(0xa8, 0x6d, 0x69, 0x6e, 0x5f, 0x66, 0x72, 0x65, 0x71)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.MinCPUInfoFreq)
			if err != nil {
				err = msgp.WrapError(err, "MinCPUInfoFreq")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "max_freq"
			err = en.Append(0xa8, 0x6d, 0x61, 0x78, 0x5f, 0x66, 0x72, 0x65, 0x71)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.MaxCPUInfoFreq)
			if err != nil {
				err = msgp.WrapError(err, "MaxCPUInfoFreq")
				return
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "min_scaling_freq"
			err = en.Append(0xb0, 0x6d, 0x69, 0x6e, 0x5f, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x72, 0x65, 0x71)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.MinScalingFreq)
			if err != nil {
				err = msgp.WrapError(err, "MinScalingFreq")
				return
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "max_scaling_freq"
			err = en.Append(0xb0, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x72, 0x65, 0x71)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.MaxScalingFreq)
			if err != nil {
				err = msgp.WrapError(err, "MaxScalingFreq")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CPUMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.CPUByModel == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TotalMhz == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.TotalCores == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.TotalCacheSize == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.FreqStatsCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.GovernorFreq == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.TotalCurrentFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.TotalScalingCurrentFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.MinCPUInfoFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.MaxCPUInfoFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.MinScalingFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.MaxScalingFreq == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "nodes"
		o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		o = msgp.AppendInt(o, z.Nodes)
		// string "timesStat"
		o = append(o, 0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x53, 0x74, 0x61, 0x74)
		if z.TimesStat == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = (*cpuTimesStat)(z.TimesStat).MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "TimesStat")
				return
			}
		}
		// string "loadStat"
		o = append(o, 0xa8, 0x6c, 0x6f, 0x61, 0x64, 0x53, 0x74, 0x61, 0x74)
		if z.LoadStat == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = (*loadAvgStat)(z.LoadStat).MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "LoadStat")
				return
			}
		}
		// string "cpuCount"
		o = append(o, 0xa8, 0x63, 0x70, 0x75, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt(o, z.CPUCount)
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "cpu_by_model"
			o = append(o, 0xac, 0x63, 0x70, 0x75, 0x5f, 0x62, 0x79, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c)
			o = msgp.AppendMapHeader(o, uint32(len(z.CPUByModel)))
			for za0001, za0002 := range z.CPUByModel {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendInt(o, za0002)
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "total_mhz"
			o = append(o, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6d, 0x68, 0x7a)
			o = msgp.AppendFloat64(o, z.TotalMhz)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "total_cores"
			o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6f, 0x72, 0x65, 0x73)
			o = msgp.AppendInt(o, z.TotalCores)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "total_cache_size"
			o = append(o, 0xb0, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65)
			o = msgp.AppendInt64(o, z.TotalCacheSize)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "freq_stats_count"
			o = append(o, 0xb0, 0x66, 0x72, 0x65, 0x71, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.FreqStatsCount)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "governor_freq"
			o = append(o, 0xad, 0x67, 0x6f, 0x76, 0x65, 0x72, 0x6e, 0x6f, 0x72, 0x5f, 0x66, 0x72, 0x65, 0x71)
			o = msgp.AppendMapHeader(o, uint32(len(z.GovernorFreq)))
			for za0003, za0004 := range z.GovernorFreq {
				o = msgp.AppendString(o, za0003)
				o = msgp.AppendInt(o, za0004)
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "total_current_freq"
			o = append(o, 0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x66, 0x72, 0x65, 0x71)
			o = msgp.AppendUint64(o, z.TotalCurrentFreq)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "total_scaling_current_freq"
			o = append(o, 0xba, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x66, 0x72, 0x65, 0x71)
			o = msgp.AppendUint64(o, z.TotalScalingCurrentFreq)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "min_freq"
			o = append(o, 0xa8, 0x6d, 0x69, 0x6e, 0x5f, 0x66, 0x72, 0x65, 0x71)
			o = msgp.AppendUint64(o, z.MinCPUInfoFreq)
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "max_freq"
			o = append(o, 0xa8, 0x6d, 0x61, 0x78, 0x5f, 0x66, 0x72, 0x65, 0x71)
			o = msgp.AppendUint64(o, z.MaxCPUInfoFreq)
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "min_scaling_freq"
			o = append(o, 0xb0, 0x6d, 0x69, 0x6e, 0x5f, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x72, 0x65, 0x71)
			o = msgp.AppendUint64(o, z.MinScalingFreq)
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "max_scaling_freq"
			o = append(o, 0xb0, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x72, 0x65, 0x71)
			o = msgp.AppendUint64(o, z.MaxScalingFreq)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CPUMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 12 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "timesStat":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TimesStat = nil
			} else {
				if z.TimesStat == nil {
					z.TimesStat = new(cpu.TimesStat)
				}
				bts, err = (*cpuTimesStat)(z.TimesStat).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "TimesStat")
					return
				}
			}
		case "loadStat":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LoadStat = nil
			} else {
				if z.LoadStat == nil {
					z.LoadStat = new(load.AvgStat)
				}
				bts, err = (*loadAvgStat)(z.LoadStat).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LoadStat")
					return
				}
			}
		case "cpuCount":
			z.CPUCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CPUCount")
				return
			}
		case "cpu_by_model":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CPUByModel")
				return
			}
			if z.CPUByModel == nil {
				z.CPUByModel = make(map[string]int, zb0002)
			} else if len(z.CPUByModel) > 0 {
				clear(z.CPUByModel)
			}
			for zb0002 > 0 {
				var za0002 int
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CPUByModel")
					return
				}
				za0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CPUByModel", za0001)
					return
				}
				z.CPUByModel[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "total_mhz":
			z.TotalMhz, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalMhz")
				return
			}
			zb0001Mask |= 0x2
		case "total_cores":
			z.TotalCores, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalCores")
				return
			}
			zb0001Mask |= 0x4
		case "total_cache_size":
			z.TotalCacheSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalCacheSize")
				return
			}
			zb0001Mask |= 0x8
		case "freq_stats_count":
			z.FreqStatsCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FreqStatsCount")
				return
			}
			zb0001Mask |= 0x10
		case "governor_freq":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GovernorFreq")
				return
			}
			if z.GovernorFreq == nil {
				z.GovernorFreq = make(map[string]int, zb0003)
			} else if len(z.GovernorFreq) > 0 {
				clear(z.GovernorFreq)
			}
			for zb0003 > 0 {
				var za0004 int
				zb0003--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GovernorFreq")
					return
				}
				za0004, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GovernorFreq", za0003)
					return
				}
				z.GovernorFreq[za0003] = za0004
			}
			zb0001Mask |= 0x20
		case "total_current_freq":
			z.TotalCurrentFreq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalCurrentFreq")
				return
			}
			zb0001Mask |= 0x40
		case "total_scaling_current_freq":
			z.TotalScalingCurrentFreq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalScalingCurrentFreq")
				return
			}
			zb0001Mask |= 0x80
		case "min_freq":
			z.MinCPUInfoFreq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinCPUInfoFreq")
				return
			}
			zb0001Mask |= 0x100
		case "max_freq":
			z.MaxCPUInfoFreq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxCPUInfoFreq")
				return
			}
			zb0001Mask |= 0x200
		case "min_scaling_freq":
			z.MinScalingFreq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinScalingFreq")
				return
			}
			zb0001Mask |= 0x400
		case "max_scaling_freq":
			z.MaxScalingFreq, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxScalingFreq")
				return
			}
			zb0001Mask |= 0x800
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xfff {
		if (zb0001Mask & 0x1) == 0 {
			z.CPUByModel = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.TotalMhz = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.TotalCores = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.TotalCacheSize = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.FreqStatsCount = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.GovernorFreq = nil
		}
		if (zb0001Mask & 0x40) == 0 {
			z.TotalCurrentFreq = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.TotalScalingCurrentFreq = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.MinCPUInfoFreq = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.MaxCPUInfoFreq = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.MinScalingFreq = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.MaxScalingFreq = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CPUMetrics) Msgsize() (s int) {
	s = 3 + 10 + msgp.TimeSize + 6 + msgp.IntSize + 10
	if z.TimesStat == nil {
		s += msgp.NilSize
	} else {
		s += (*cpuTimesStat)(z.TimesStat).Msgsize()
	}
	s += 9
	if z.LoadStat == nil {
		s += msgp.NilSize
	} else {
		s += (*loadAvgStat)(z.LoadStat).Msgsize()
	}
	s += 9 + msgp.IntSize + 13 + msgp.MapHeaderSize
	if z.CPUByModel != nil {
		for za0001, za0002 := range z.CPUByModel {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.IntSize
		}
	}
	s += 10 + msgp.Float64Size + 12 + msgp.IntSize + 17 + msgp.Int64Size + 17 + msgp.IntSize + 14 + msgp.MapHeaderSize
	if z.GovernorFreq != nil {
		for za0003, za0004 := range z.GovernorFreq {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.IntSize
		}
	}
	s += 19 + msgp.Uint64Size + 27 + msgp.Uint64Size + 9 + msgp.Uint64Size + 9 + msgp.Uint64Size + 17 + msgp.Uint64Size + 17 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CatalogInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastBucketScanned":
			z.LastBucketScanned, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastBucketScanned")
				return
			}
			zb0001Mask |= 0x1
		case "lastObjectScanned":
			z.LastObjectScanned, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastObjectScanned")
				return
			}
		case "lastBucketMatched":
			z.LastBucketMatched, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastBucketMatched")
				return
			}
			zb0001Mask |= 0x2
		case "lastObjectMatched":
			z.LastObjectMatched, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastObjectMatched")
				return
			}
		case "objectsScannedCount":
			z.ObjectsScannedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsScannedCount")
				return
			}
		case "objectsMatchedCount":
			z.ObjectsMatchedCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsMatchedCount")
				return
			}
		case "recordsWrittenCount":
			z.RecordsWrittenCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RecordsWrittenCount")
				return
			}
		case "outputObjectsCount":
			z.OutputObjectsCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "OutputObjectsCount")
				return
			}
		case "manifestPathBucket":
			z.ManifestPathBucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathBucket")
				return
			}
		case "manifestPathObject":
			z.ManifestPathObject, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathObject")
				return
			}
		case "errorMsg":
			z.ErrorMsg, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ErrorMsg")
				return
			}
		case "lastObjectWritten":
			z.LastObjectWritten, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "LastObjectWritten")
				return
			}
			zb0001Mask |= 0x4
		case "outputFiles":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OutputFiles")
				return
			}
			if cap(z.OutputFiles) >= int(zb0002) {
				z.OutputFiles = (z.OutputFiles)[:zb0002]
			} else {
				z.OutputFiles = make([]CatalogDataFile, zb0002)
			}
			for za0001 := range z.OutputFiles {
				err = z.OutputFiles[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OutputFiles", za0001)
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.LastBucketScanned = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LastBucketMatched = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LastObjectWritten = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.OutputFiles = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CatalogInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.LastBucketScanned == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.LastBucketMatched == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LastObjectWritten == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.OutputFiles == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "bucket"
		err = en.Append(0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.Bucket)
		if err != nil {
			err = msgp.WrapError(err, "Bucket")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "lastBucketScanned"
			err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteString(z.LastBucketScanned)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketScanned")
				return
			}
		}
		// write "lastObjectScanned"
		err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.LastObjectScanned)
		if err != nil {
			err = msgp.WrapError(err, "LastObjectScanned")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "lastBucketMatched"
			err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteString(z.LastBucketMatched)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketMatched")
				return
			}
		}
		// write "lastObjectMatched"
		err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.LastObjectMatched)
		if err != nil {
			err = msgp.WrapError(err, "LastObjectMatched")
			return
		}
		// write "objectsScannedCount"
		err = en.Append(0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.ObjectsScannedCount)
		if err != nil {
			err = msgp.WrapError(err, "ObjectsScannedCount")
			return
		}
		// write "objectsMatchedCount"
		err = en.Append(0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.ObjectsMatchedCount)
		if err != nil {
			err = msgp.WrapError(err, "ObjectsMatchedCount")
			return
		}
		// write "recordsWrittenCount"
		err = en.Append(0xb3, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.RecordsWrittenCount)
		if err != nil {
			err = msgp.WrapError(err, "RecordsWrittenCount")
			return
		}
		// write "outputObjectsCount"
		err = en.Append(0xb2, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.OutputObjectsCount)
		if err != nil {
			err = msgp.WrapError(err, "OutputObjectsCount")
			return
		}
		// write "manifestPathBucket"
		err = en.Append(0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.ManifestPathBucket)
		if err != nil {
			err = msgp.WrapError(err, "ManifestPathBucket")
			return
		}
		// write "manifestPathObject"
		err = en.Append(0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
		if err != nil {
			return
		}
		err = en.WriteString(z.ManifestPathObject)
		if err != nil {
			err = msgp.WrapError(err, "ManifestPathObject")
			return
		}
		// write "errorMsg"
		err = en.Append(0xa8, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x73, 0x67)
		if err != nil {
			return
		}
		err = en.WriteString(z.ErrorMsg)
		if err != nil {
			err = msgp.WrapError(err, "ErrorMsg")
			return
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "lastObjectWritten"
			err = en.Append(0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteString(z.LastObjectWritten)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectWritten")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "outputFiles"
			err = en.Append(0xab, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.OutputFiles)))
			if err != nil {
				err = msgp.WrapError(err, "OutputFiles")
				return
			}
			for za0001 := range z.OutputFiles {
				err = z.OutputFiles[za0001].EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "OutputFiles", za0001)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CatalogInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.LastBucketScanned == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.LastBucketMatched == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LastObjectWritten == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.OutputFiles == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "bucket"
		o = append(o, 0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
		o = msgp.AppendString(o, z.Bucket)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "lastBucketScanned"
			o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
			o = msgp.AppendString(o, z.LastBucketScanned)
		}
		// string "lastObjectScanned"
		o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64)
		o = msgp.AppendString(o, z.LastObjectScanned)
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "lastBucketMatched"
			o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
			o = msgp.AppendString(o, z.LastBucketMatched)
		}
		// string "lastObjectMatched"
		o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64)
		o = msgp.AppendString(o, z.LastObjectMatched)
		// string "objectsScannedCount"
		o = append(o, 0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x53, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.ObjectsScannedCount)
		// string "objectsMatchedCount"
		o = append(o, 0xb3, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.ObjectsMatchedCount)
		// string "recordsWrittenCount"
		o = append(o, 0xb3, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x73, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.RecordsWrittenCount)
		// string "outputObjectsCount"
		o = append(o, 0xb2, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendUint64(o, z.OutputObjectsCount)
		// string "manifestPathBucket"
		o = append(o, 0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
		o = msgp.AppendString(o, z.ManifestPathBucket)
		// string "manifestPathObject"
		o = append(o, 0xb2, 0x6d, 0x61, 0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x50, 0x61, 0x74, 0x68, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
		o = msgp.AppendString(o, z.ManifestPathObject)
		// string "errorMsg"
		o = append(o, 0xa8, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x4d, 0x73, 0x67)
		o = msgp.AppendString(o, z.ErrorMsg)
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "lastObjectWritten"
			o = append(o, 0xb1, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x57, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e)
			o = msgp.AppendString(o, z.LastObjectWritten)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "outputFiles"
			o = append(o, 0xab, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.OutputFiles)))
			for za0001 := range z.OutputFiles {
				o, err = z.OutputFiles[za0001].MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "OutputFiles", za0001)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CatalogInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastBucketScanned":
			z.LastBucketScanned, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketScanned")
				return
			}
			zb0001Mask |= 0x1
		case "lastObjectScanned":
			z.LastObjectScanned, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectScanned")
				return
			}
		case "lastBucketMatched":
			z.LastBucketMatched, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastBucketMatched")
				return
			}
			zb0001Mask |= 0x2
		case "lastObjectMatched":
			z.LastObjectMatched, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectMatched")
				return
			}
		case "objectsScannedCount":
			z.ObjectsScannedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsScannedCount")
				return
			}
		case "objectsMatchedCount":
			z.ObjectsMatchedCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsMatchedCount")
				return
			}
		case "recordsWrittenCount":
			z.RecordsWrittenCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RecordsWrittenCount")
				return
			}
		case "outputObjectsCount":
			z.OutputObjectsCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutputObjectsCount")
				return
			}
		case "manifestPathBucket":
			z.ManifestPathBucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathBucket")
				return
			}
		case "manifestPathObject":
			z.ManifestPathObject, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManifestPathObject")
				return
			}
		case "errorMsg":
			z.ErrorMsg, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ErrorMsg")
				return
			}
		case "lastObjectWritten":
			z.LastObjectWritten, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastObjectWritten")
				return
			}
			zb0001Mask |= 0x4
		case "outputFiles":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutputFiles")
				return
			}
			if cap(z.OutputFiles) >= int(zb0002) {
				z.OutputFiles = (z.OutputFiles)[:zb0002]
			} else {
				z.OutputFiles = make([]CatalogDataFile, zb0002)
			}
			for za0001 := range z.OutputFiles {
				bts, err = z.OutputFiles[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OutputFiles", za0001)
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.LastBucketScanned = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LastBucketMatched = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LastObjectWritten = ""
		}
		if (zb0001Mask & 0x8) == 0 {
			z.OutputFiles = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CatalogInfo) Msgsize() (s int) {
	s = 1 + 7 + msgp.StringPrefixSize + len(z.Bucket) + 18 + msgp.StringPrefixSize + len(z.LastBucketScanned) + 18 + msgp.StringPrefixSize + len(z.LastObjectScanned) + 18 + msgp.StringPrefixSize + len(z.LastBucketMatched) + 18 + msgp.StringPrefixSize + len(z.LastObjectMatched) + 20 + msgp.Uint64Size + 20 + msgp.Uint64Size + 20 + msgp.Uint64Size + 19 + msgp.Uint64Size + 19 + msgp.StringPrefixSize + len(z.ManifestPathBucket) + 19 + msgp.StringPrefixSize + len(z.ManifestPathObject) + 9 + msgp.StringPrefixSize + len(z.ErrorMsg) + 18 + msgp.StringPrefixSize + len(z.LastObjectWritten) + 12 + msgp.ArrayHeaderSize
	for za0001 := range z.OutputFiles {
		s += z.OutputFiles[za0001].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ConnectionStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "connected":
			z.Connected, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
			zb0001Mask |= 0x1
		case "disconnected":
			z.Disconnected, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
			zb0001Mask |= 0x2
		case "reconnectCount":
			z.ReconnectCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
			zb0001Mask |= 0x4
		case "outgoingStreams":
			z.OutgoingStreams, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
			zb0001Mask |= 0x8
		case "incomingStreams":
			z.IncomingStreams, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
			zb0001Mask |= 0x10
		case "outgoingMessages":
			z.OutgoingMessages, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
			zb0001Mask |= 0x20
		case "incomingMessages":
			z.IncomingMessages, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
			zb0001Mask |= 0x40
		case "outgoingBytes":
			z.OutgoingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x80
		case "incomingBytes":
			z.IncomingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x100
		case "outQueue":
			z.OutQueue, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
			zb0001Mask |= 0x200
		case "lastPongTime":
			z.LastPongTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
			zb0001Mask |= 0x400
		case "lastConnectTime":
			z.LastConnectTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
			zb0001Mask |= 0x800
		case "lastPingMS":
			z.LastPingMS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
			zb0001Mask |= 0x1000
		case "maxPingDurMS":
			z.MaxPingDurMS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
			zb0001Mask |= 0x2000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3fff {
		if (zb0001Mask & 0x1) == 0 {
			z.Connected = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Disconnected = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReconnectCount = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.OutgoingStreams = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.IncomingStreams = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.OutgoingMessages = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.IncomingMessages = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.OutgoingBytes = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.OutQueue = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.LastPongTime = (time.Time{})
		}
		if (zb0001Mask & 0x800) == 0 {
			z.LastConnectTime = (time.Time{})
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.LastPingMS = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.MaxPingDurMS = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ConnectionStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.Connected == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Disconnected == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReconnectCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.OutgoingStreams == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.IncomingStreams == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.OutgoingMessages == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.IncomingMessages == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.OutQueue == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.LastPongTime == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.LastConnectTime == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.LastPingMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.MaxPingDurMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "connected"
			err = en.Append(0xa9, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Connected)
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "disconnected"
			err = en.Append(0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Disconnected)
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "reconnectCount"
			err = en.Append(0xae, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.ReconnectCount)
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "outgoingStreams"
			err = en.Append(0xaf, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.OutgoingStreams)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "incomingStreams"
			err = en.Append(0xaf, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.IncomingStreams)
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "outgoingMessages"
			err = en.Append(0xb0, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.OutgoingMessages)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "incomingMessages"
			err = en.Append(0xb0, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.IncomingMessages)
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "outgoingBytes"
			err = en.Append(0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.OutgoingBytes)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "incomingBytes"
			err = en.Append(0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.IncomingBytes)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "outQueue"
			err = en.Append(0xa8, 0x6f, 0x75, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt(z.OutQueue)
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "lastPongTime"
			err = en.Append(0xac, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x6f, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			err = en.WriteTime(z.LastPongTime)
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "lastConnectTime"
			err = en.Append(0xaf, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			err = en.WriteTime(z.LastConnectTime)
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "lastPingMS"
			err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x4d, 0x53)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.LastPingMS)
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "maxPingDurMS"
			err = en.Append(0xac, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x6e, 0x67, 0x44, 0x75, 0x72, 0x4d, 0x53)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.MaxPingDurMS)
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ConnectionStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.Connected == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Disconnected == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReconnectCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.OutgoingStreams == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.IncomingStreams == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.OutgoingMessages == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.IncomingMessages == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.OutQueue == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.LastPongTime == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.LastConnectTime == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.LastPingMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.MaxPingDurMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "connected"
			o = append(o, 0xa9, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
			o = msgp.AppendInt(o, z.Connected)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "disconnected"
			o = append(o, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
			o = msgp.AppendInt(o, z.Disconnected)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "reconnectCount"
			o = append(o, 0xae, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.ReconnectCount)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "outgoingStreams"
			o = append(o, 0xaf, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
			o = msgp.AppendInt(o, z.OutgoingStreams)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "incomingStreams"
			o = append(o, 0xaf, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
			o = msgp.AppendInt(o, z.IncomingStreams)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "outgoingMessages"
			o = append(o, 0xb0, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.OutgoingMessages)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "incomingMessages"
			o = append(o, 0xb0, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.IncomingMessages)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "outgoingBytes"
			o = append(o, 0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.OutgoingBytes)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "incomingBytes"
			o = append(o, 0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.IncomingBytes)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "outQueue"
			o = append(o, 0xa8, 0x6f, 0x75, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65)
			o = msgp.AppendInt(o, z.OutQueue)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "lastPongTime"
			o = append(o, 0xac, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x6f, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65)
			o = msgp.AppendTime(o, z.LastPongTime)
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "lastConnectTime"
			o = append(o, 0xaf, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x69, 0x6d, 0x65)
			o = msgp.AppendTime(o, z.LastConnectTime)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "lastPingMS"
			o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x4d, 0x53)
			o = msgp.AppendFloat64(o, z.LastPingMS)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "maxPingDurMS"
			o = append(o, 0xac, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x6e, 0x67, 0x44, 0x75, 0x72, 0x4d, 0x53)
			o = msgp.AppendFloat64(o, z.MaxPingDurMS)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ConnectionStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "connected":
			z.Connected, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
			zb0001Mask |= 0x1
		case "disconnected":
			z.Disconnected, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
			zb0001Mask |= 0x2
		case "reconnectCount":
			z.ReconnectCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
			zb0001Mask |= 0x4
		case "outgoingStreams":
			z.OutgoingStreams, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
			zb0001Mask |= 0x8
		case "incomingStreams":
			z.IncomingStreams, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
			zb0001Mask |= 0x10
		case "outgoingMessages":
			z.OutgoingMessages, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
			zb0001Mask |= 0x20
		case "incomingMessages":
			z.IncomingMessages, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
			zb0001Mask |= 0x40
		case "outgoingBytes":
			z.OutgoingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x80
		case "incomingBytes":
			z.IncomingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x100
		case "outQueue":
			z.OutQueue, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
			zb0001Mask |= 0x200
		case "lastPongTime":
			z.LastPongTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
			zb0001Mask |= 0x400
		case "lastConnectTime":
			z.LastConnectTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
			zb0001Mask |= 0x800
		case "lastPingMS":
			z.LastPingMS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
			zb0001Mask |= 0x1000
		case "maxPingDurMS":
			z.MaxPingDurMS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
			zb0001Mask |= 0x2000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3fff {
		if (zb0001Mask & 0x1) == 0 {
			z.Connected = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Disconnected = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReconnectCount = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.OutgoingStreams = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.IncomingStreams = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.OutgoingMessages = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.IncomingMessages = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.OutgoingBytes = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.OutQueue = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.LastPongTime = (time.Time{})
		}
		if (zb0001Mask & 0x800) == 0 {
			z.LastConnectTime = (time.Time{})
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.LastPingMS = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.MaxPingDurMS = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ConnectionStats) Msgsize() (s int) {
	s = 1 + 10 + msgp.IntSize + 13 + msgp.IntSize + 15 + msgp.IntSize + 16 + msgp.IntSize + 16 + msgp.IntSize + 17 + msgp.Int64Size + 17 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 9 + msgp.IntSize + 13 + msgp.TimeSize + 16 + msgp.TimeSize + 11 + msgp.Float64Size + 13 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DiskIOStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
			zb0001Mask |= 0x1
		case "read_ios":
			z.ReadIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
			zb0001Mask |= 0x2
		case "read_merges":
			z.ReadMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
			zb0001Mask |= 0x4
		case "read_sectors":
			z.ReadSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
			zb0001Mask |= 0x8
		case "read_ticks":
			z.ReadTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
			zb0001Mask |= 0x10
		case "write_ios":
			z.WriteIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
			zb0001Mask |= 0x20
		case "write_merges":
			z.WriteMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
			zb0001Mask |= 0x40
		case "write_sectors":
			z.WriteSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
			zb0001Mask |= 0x80
		case "write_ticks":
			z.WriteTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
			zb0001Mask |= 0x100
		case "current_ios":
			z.CurrentIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
			zb0001Mask |= 0x200
		case "total_ticks":
			z.TotalTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
			zb0001Mask |= 0x400
		case "req_ticks":
			z.ReqTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
			zb0001Mask |= 0x800
		case "discard_ios":
			z.DiscardIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
			zb0001Mask |= 0x1000
		case "discard_merges":
			z.DiscardMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
			zb0001Mask |= 0x2000
		case "discard_sectors":
			z.DiscardSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
			zb0001Mask |= 0x4000
		case "discard_ticks":
			z.DiscardTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
			zb0001Mask |= 0x8000
		case "flush_ios":
			z.FlushIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
			zb0001Mask |= 0x10000
		case "flush_ticks":
			z.FlushTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
			zb0001Mask |= 0x20000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.N = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ReadIOs = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReadMerges = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ReadSectors = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.ReadTicks = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.WriteIOs = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.WriteMerges = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.WriteSectors = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.WriteTicks = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.CurrentIOs = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.TotalTicks = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReqTicks = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.DiscardIOs = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.DiscardMerges = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.DiscardSectors = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.DiscardTicks = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.FlushIOs = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.FlushTicks = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DiskIOStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	if z.N == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ReadIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReadMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ReadSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ReadTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.WriteIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.WriteMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.WriteSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.WriteTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.CurrentIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.TotalTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.ReqTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.DiscardIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.DiscardMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.DiscardSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.DiscardTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.FlushIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.FlushTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "n"
			err = en.Append(0xa1, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteInt(z.N)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "read_ios"
			err = en.Append(0xa8, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadIOs)
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "read_merges"
			err = en.Append(0xab, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadMerges)
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "read_sectors"
			err = en.Append(0xac, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadSectors)
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "read_ticks"
			err = en.Append(0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadTicks)
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "write_ios"
			err = en.Append(0xa9, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteIOs)
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "write_merges"
			err = en.Append(0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteMerges)
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "write_sectors"
			err = en.Append(0xad, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteSectors)
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "write_ticks"
			err = en.Append(0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteTicks)
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "current_ios"
			err = en.Append(0xab, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.CurrentIOs)
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "total_ticks"
			err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalTicks)
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "req_ticks"
			err = en.Append(0xa9, 0x72, 0x65, 0x71, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReqTicks)
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "discard_ios"
			err = en.Append(0xab, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardIOs)
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "discard_merges"
			err = en.Append(0xae, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardMerges)
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "discard_sectors"
			err = en.Append(0xaf, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardSectors)
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "discard_ticks"
			err = en.Append(0xad, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardTicks)
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "flush_ios"
			err = en.Append(0xa9, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.FlushIOs)
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// write "flush_ticks"
			err = en.Append(0xab, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.FlushTicks)
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DiskIOStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	if z.N == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ReadIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReadMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ReadSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ReadTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.WriteIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.WriteMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.WriteSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.WriteTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.CurrentIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.TotalTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.ReqTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.DiscardIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.DiscardMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.DiscardSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.DiscardTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.FlushIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.FlushTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "n"
			o = append(o, 0xa1, 0x6e)
			o = msgp.AppendInt(o, z.N)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "read_ios"
			o = append(o, 0xa8, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.ReadIOs)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "read_merges"
			o = append(o, 0xab, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.ReadMerges)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "read_sectors"
			o = append(o, 0xac, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.ReadSectors)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "read_ticks"
			o = append(o, 0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.ReadTicks)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "write_ios"
			o = append(o, 0xa9, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.WriteIOs)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "write_merges"
			o = append(o, 0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.WriteMerges)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "write_sectors"
			o = append(o, 0xad, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.WriteSectors)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "write_ticks"
			o = append(o, 0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.WriteTicks)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "current_ios"
			o = append(o, 0xab, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.CurrentIOs)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "total_ticks"
			o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.TotalTicks)
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "req_ticks"
			o = append(o, 0xa9, 0x72, 0x65, 0x71, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.ReqTicks)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "discard_ios"
			o = append(o, 0xab, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.DiscardIOs)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "discard_merges"
			o = append(o, 0xae, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.DiscardMerges)
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "discard_sectors"
			o = append(o, 0xaf, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.DiscardSectors)
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "discard_ticks"
			o = append(o, 0xad, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.DiscardTicks)
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "flush_ios"
			o = append(o, 0xa9, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.FlushIOs)
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// string "flush_ticks"
			o = append(o, 0xab, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.FlushTicks)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DiskIOStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
			zb0001Mask |= 0x1
		case "read_ios":
			z.ReadIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
			zb0001Mask |= 0x2
		case "read_merges":
			z.ReadMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
			zb0001Mask |= 0x4
		case "read_sectors":
			z.ReadSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
			zb0001Mask |= 0x8
		case "read_ticks":
			z.ReadTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
			zb0001Mask |= 0x10
		case "write_ios":
			z.WriteIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
			zb0001Mask |= 0x20
		case "write_merges":
			z.WriteMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
			zb0001Mask |= 0x40
		case "write_sectors":
			z.WriteSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
			zb0001Mask |= 0x80
		case "write_ticks":
			z.WriteTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
			zb0001Mask |= 0x100
		case "current_ios":
			z.CurrentIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
			zb0001Mask |= 0x200
		case "total_ticks":
			z.TotalTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
			zb0001Mask |= 0x400
		case "req_ticks":
			z.ReqTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
			zb0001Mask |= 0x800
		case "discard_ios":
			z.DiscardIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
			zb0001Mask |= 0x1000
		case "discard_merges":
			z.DiscardMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
			zb0001Mask |= 0x2000
		case "discard_sectors":
			z.DiscardSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
			zb0001Mask |= 0x4000
		case "discard_ticks":
			z.DiscardTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
			zb0001Mask |= 0x8000
		case "flush_ios":
			z.FlushIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
			zb0001Mask |= 0x10000
		case "flush_ticks":
			z.FlushTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
			zb0001Mask |= 0x20000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.N = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ReadIOs = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReadMerges = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ReadSectors = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.ReadTicks = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.WriteIOs = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.WriteMerges = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.WriteSectors = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.WriteTicks = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.CurrentIOs = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.TotalTicks = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReqTicks = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.DiscardIOs = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.DiscardMerges = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.DiscardSectors = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.DiscardTicks = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.FlushIOs = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.FlushTicks = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DiskIOStats) Msgsize() (s int) {
	s = 3 + 2 + msgp.IntSize + 9 + msgp.Uint64Size + 12 + msgp.Uint64Size + 13 + msgp.Uint64Size + 11 + msgp.Uint64Size + 10 + msgp.Uint64Size + 13 + msgp.Uint64Size + 14 + msgp.Uint64Size + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 10 + msgp.Uint64Size + 12 + msgp.Uint64Size + 15 + msgp.Uint64Size + 16 + msgp.Uint64Size + 14 + msgp.Uint64Size + 10 + msgp.Uint64Size + 12 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DiskIOStatsLegacy) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
			zb0001Mask |= 0x1
		case "read_ios":
			z.ReadIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
			zb0001Mask |= 0x2
		case "read_merges":
			z.ReadMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
			zb0001Mask |= 0x4
		case "read_sectors":
			z.ReadSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
			zb0001Mask |= 0x8
		case "read_ticks":
			z.ReadTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
			zb0001Mask |= 0x10
		case "write_ios":
			z.WriteIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
			zb0001Mask |= 0x20
		case "write_merges":
			z.WriteMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
			zb0001Mask |= 0x40
		case "wrte_sectors":
			z.WriteSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
			zb0001Mask |= 0x80
		case "write_ticks":
			z.WriteTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
			zb0001Mask |= 0x100
		case "current_ios":
			z.CurrentIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
			zb0001Mask |= 0x200
		case "total_ticks":
			z.TotalTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
			zb0001Mask |= 0x400
		case "req_ticks":
			z.ReqTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
			zb0001Mask |= 0x800
		case "discard_ios":
			z.DiscardIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
			zb0001Mask |= 0x1000
		case "discard_merges":
			z.DiscardMerges, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
			zb0001Mask |= 0x2000
		case "discard_secotrs":
			z.DiscardSectors, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
			zb0001Mask |= 0x4000
		case "discard_ticks":
			z.DiscardTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
			zb0001Mask |= 0x8000
		case "flush_ios":
			z.FlushIOs, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
			zb0001Mask |= 0x10000
		case "flush_ticks":
			z.FlushTicks, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
			zb0001Mask |= 0x20000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.N = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ReadIOs = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReadMerges = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ReadSectors = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.ReadTicks = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.WriteIOs = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.WriteMerges = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.WriteSectors = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.WriteTicks = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.CurrentIOs = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.TotalTicks = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReqTicks = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.DiscardIOs = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.DiscardMerges = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.DiscardSectors = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.DiscardTicks = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.FlushIOs = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.FlushTicks = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DiskIOStatsLegacy) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	if z.N == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ReadIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReadMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ReadSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ReadTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.WriteIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.WriteMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.WriteSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.WriteTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.CurrentIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.TotalTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.ReqTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.DiscardIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.DiscardMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.DiscardSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.DiscardTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.FlushIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.FlushTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "n"
			err = en.Append(0xa1, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteInt(z.N)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "read_ios"
			err = en.Append(0xa8, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadIOs)
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "read_merges"
			err = en.Append(0xab, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadMerges)
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "read_sectors"
			err = en.Append(0xac, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadSectors)
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "read_ticks"
			err = en.Append(0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadTicks)
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "write_ios"
			err = en.Append(0xa9, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteIOs)
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "write_merges"
			err = en.Append(0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteMerges)
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "wrte_sectors"
			err = en.Append(0xac, 0x77, 0x72, 0x74, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteSectors)
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "write_ticks"
			err = en.Append(0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteTicks)
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "current_ios"
			err = en.Append(0xab, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.CurrentIOs)
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "total_ticks"
			err = en.Append(0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalTicks)
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "req_ticks"
			err = en.Append(0xa9, 0x72, 0x65, 0x71, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReqTicks)
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "discard_ios"
			err = en.Append(0xab, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardIOs)
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "discard_merges"
			err = en.Append(0xae, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardMerges)
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "discard_secotrs"
			err = en.Append(0xaf, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x74, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardSectors)
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "discard_ticks"
			err = en.Append(0xad, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.DiscardTicks)
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "flush_ios"
			err = en.Append(0xa9, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x69, 0x6f, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.FlushIOs)
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// write "flush_ticks"
			err = en.Append(0xab, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.FlushTicks)
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DiskIOStatsLegacy) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	if z.N == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ReadIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReadMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ReadSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ReadTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.WriteIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.WriteMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.WriteSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.WriteTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.CurrentIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.TotalTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.ReqTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.DiscardIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.DiscardMerges == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.DiscardSectors == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.DiscardTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.FlushIOs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.FlushTicks == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "n"
			o = append(o, 0xa1, 0x6e)
			o = msgp.AppendInt(o, z.N)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "read_ios"
			o = append(o, 0xa8, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.ReadIOs)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "read_merges"
			o = append(o, 0xab, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.ReadMerges)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "read_sectors"
			o = append(o, 0xac, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.ReadSectors)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "read_ticks"
			o = append(o, 0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.ReadTicks)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "write_ios"
			o = append(o, 0xa9, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.WriteIOs)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "write_merges"
			o = append(o, 0xac, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.WriteMerges)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "wrte_sectors"
			o = append(o, 0xac, 0x77, 0x72, 0x74, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.WriteSectors)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "write_ticks"
			o = append(o, 0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.WriteTicks)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "current_ios"
			o = append(o, 0xab, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.CurrentIOs)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "total_ticks"
			o = append(o, 0xab, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.TotalTicks)
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "req_ticks"
			o = append(o, 0xa9, 0x72, 0x65, 0x71, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.ReqTicks)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "discard_ios"
			o = append(o, 0xab, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.DiscardIOs)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "discard_merges"
			o = append(o, 0xae, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x65, 0x72, 0x67, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.DiscardMerges)
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "discard_secotrs"
			o = append(o, 0xaf, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x74, 0x72, 0x73)
			o = msgp.AppendUint64(o, z.DiscardSectors)
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "discard_ticks"
			o = append(o, 0xad, 0x64, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.DiscardTicks)
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "flush_ios"
			o = append(o, 0xa9, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x69, 0x6f, 0x73)
			o = msgp.AppendUint64(o, z.FlushIOs)
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// string "flush_ticks"
			o = append(o, 0xab, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x73)
			o = msgp.AppendUint64(o, z.FlushTicks)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DiskIOStatsLegacy) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
			zb0001Mask |= 0x1
		case "read_ios":
			z.ReadIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadIOs")
				return
			}
			zb0001Mask |= 0x2
		case "read_merges":
			z.ReadMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadMerges")
				return
			}
			zb0001Mask |= 0x4
		case "read_sectors":
			z.ReadSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadSectors")
				return
			}
			zb0001Mask |= 0x8
		case "read_ticks":
			z.ReadTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadTicks")
				return
			}
			zb0001Mask |= 0x10
		case "write_ios":
			z.WriteIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteIOs")
				return
			}
			zb0001Mask |= 0x20
		case "write_merges":
			z.WriteMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteMerges")
				return
			}
			zb0001Mask |= 0x40
		case "wrte_sectors":
			z.WriteSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteSectors")
				return
			}
			zb0001Mask |= 0x80
		case "write_ticks":
			z.WriteTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteTicks")
				return
			}
			zb0001Mask |= 0x100
		case "current_ios":
			z.CurrentIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CurrentIOs")
				return
			}
			zb0001Mask |= 0x200
		case "total_ticks":
			z.TotalTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalTicks")
				return
			}
			zb0001Mask |= 0x400
		case "req_ticks":
			z.ReqTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqTicks")
				return
			}
			zb0001Mask |= 0x800
		case "discard_ios":
			z.DiscardIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardIOs")
				return
			}
			zb0001Mask |= 0x1000
		case "discard_merges":
			z.DiscardMerges, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardMerges")
				return
			}
			zb0001Mask |= 0x2000
		case "discard_secotrs":
			z.DiscardSectors, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardSectors")
				return
			}
			zb0001Mask |= 0x4000
		case "discard_ticks":
			z.DiscardTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DiscardTicks")
				return
			}
			zb0001Mask |= 0x8000
		case "flush_ios":
			z.FlushIOs, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlushIOs")
				return
			}
			zb0001Mask |= 0x10000
		case "flush_ticks":
			z.FlushTicks, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlushTicks")
				return
			}
			zb0001Mask |= 0x20000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.N = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ReadIOs = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReadMerges = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ReadSectors = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.ReadTicks = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.WriteIOs = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.WriteMerges = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.WriteSectors = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.WriteTicks = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.CurrentIOs = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.TotalTicks = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.ReqTicks = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.DiscardIOs = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.DiscardMerges = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.DiscardSectors = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.DiscardTicks = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.FlushIOs = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.FlushTicks = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DiskIOStatsLegacy) Msgsize() (s int) {
	s = 3 + 2 + msgp.IntSize + 9 + msgp.Uint64Size + 12 + msgp.Uint64Size + 13 + msgp.Uint64Size + 11 + msgp.Uint64Size + 10 + msgp.Uint64Size + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 10 + msgp.Uint64Size + 12 + msgp.Uint64Size + 15 + msgp.Uint64Size + 16 + msgp.Uint64Size + 14 + msgp.Uint64Size + 10 + msgp.Uint64Size + 12 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DiskMetric) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "n_disks":
			z.NDisks, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "NDisks")
				return
			}
		case "disk_idx":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DiskIdx")
					return
				}
				z.DiskIdx = nil
			} else {
				if z.DiskIdx == nil {
					z.DiskIdx = new(int)
				}
				*z.DiskIdx, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DiskIdx")
					return
				}
			}
			zb0001Mask |= 0x1
		case "set_idx":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SetIdx")
					return
				}
				z.SetIdx = nil
			} else {
				if z.SetIdx == nil {
					z.SetIdx = new(int)
				}
				*z.SetIdx, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SetIdx")
					return
				}
			}
			zb0001Mask |= 0x2
		case "pool_idx":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx")
					return
				}
				z.PoolIdx = nil
			} else {
				if z.PoolIdx == nil {
					z.PoolIdx = new(int)
				}
				*z.PoolIdx, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx")
					return
				}
			}
			zb0001Mask |= 0x4
		case "state":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
			if z.State == nil {
				z.State = make(map[string]int, zb0002)
			} else if len(z.State) > 0 {
				clear(z.State)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "State")
					return
				}
				var za0002 int
				za0002, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "State", za0001)
					return
				}
				z.State[za0001] = za0002
			}
			zb0001Mask |= 0x8
		case "offline":
			z.Offline, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
			zb0001Mask |= 0x10
		case "waiting":
			z.Hanging, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hanging")
				return
			}
			zb0001Mask |= 0x20
		case "healing":
			z.Healing, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
			zb0001Mask |= 0x40
		case "healingInfo":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HealingInfo")
					return
				}
				z.HealingInfo = nil
			} else {
				if z.HealingInfo == nil {
					z.HealingInfo = new(DriveHealInfo)
				}
				err = z.HealingInfo.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "HealingInfo")
					return
				}
			}
			zb0001Mask |= 0x80
		case "cache":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
				z.Cache = nil
			} else {
				if z.Cache == nil {
					z.Cache = new(CacheStats)
				}
				err = z.Cache.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
			}
			zb0001Mask |= 0x100
		case "space":
			err = z.Space.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Space")
				return
			}
		case "lifetime_ops":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifetimeOps")
				return
			}
			if z.LifetimeOps == nil {
				z.LifetimeOps = make(map[string]DiskAction, zb0003)
			} else if len(z.LifetimeOps) > 0 {
				clear(z.LifetimeOps)
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifetimeOps")
					return
				}
				var za0004 DiskAction
				err = za0004.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LifetimeOps", za0003)
					return
				}
				z.LifetimeOps[za0003] = za0004
			}
			zb0001Mask |= 0x200
		case "last_minute":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			if z.LastMinute == nil {
				z.LastMinute = make(map[string]DiskAction, zb0004)
			} else if len(z.LastMinute) > 0 {
				clear(z.LastMinute)
			}
			for zb0004 > 0 {
				zb0004--
				var za0005 string
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				var za0006 DiskAction
				err = za0006.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0005)
					return
				}
				z.LastMinute[za0005] = za0006
			}
			zb0001Mask |= 0x400
		case "last_day":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastDaySegmented")
				return
			}
			if z.LastDaySegmented == nil {
				z.LastDaySegmented = make(map[string]SegmentedDiskActions, zb0005)
			} else if len(z.LastDaySegmented) > 0 {
				clear(z.LastDaySegmented)
			}
			for zb0005 > 0 {
				zb0005--
				var za0007 string
				za0007, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastDaySegmented")
					return
				}
				var za0008 SegmentedDiskActions
				err = (*Segmented[DiskAction, *DiskAction])(&za0008).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastDaySegmented", za0007)
					return
				}
				z.LastDaySegmented[za0007] = za0008
			}
			zb0001Mask |= 0x800
		case "iostats":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "IOStats")
					return
				}
				z.IOStats = nil
			} else {
				if z.IOStats == nil {
					z.IOStats = new(DiskIOStatsLegacy)
				}
				err = z.IOStats.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "IOStats")
					return
				}
			}
			zb0001Mask |= 0x1000
		case "io_min":
			err = z.IOStatsMinute.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "IOStatsMinute")
				return
			}
		case "io_day":
			err = (*Segmented[DiskIOStats, *DiskIOStats])(&z.IOStatsDay).DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "IOStatsDay")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1fff {
		if (zb0001Mask & 0x1) == 0 {
			z.DiskIdx = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.SetIdx = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.PoolIdx = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.State = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Offline = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Hanging = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Healing = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.HealingInfo = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Cache = nil
		}
		if (zb0001Mask & 0x200) == 0 {
			z.LifetimeOps = nil
		}
		if (zb0001Mask & 0x400) == 0 {
			z.LastMinute = nil
		}
		if (zb0001Mask & 0x800) == 0 {
			z.LastDaySegmented = nil
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.IOStats = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DiskMetric) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	if z.DiskIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.SetIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.PoolIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.State == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Offline == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Hanging == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Healing == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.HealingInfo == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Cache == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.LifetimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.LastMinute == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.LastDaySegmented == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.IOStats == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "n_disks"
		err = en.Append(0xa7, 0x6e, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.NDisks)
		if err != nil {
			err = msgp.WrapError(err, "NDisks")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "disk_idx"
			err = en.Append(0xa8, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x69, 0x64, 0x78)
			if err != nil {
				return
			}
			if z.DiskIdx == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteInt(*z.DiskIdx)
				if err != nil {
					err = msgp.WrapError(err, "DiskIdx")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "set_idx"
			err = en.Append(0xa7, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x78)
			if err != nil {
				return
			}
			if z.SetIdx == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteInt(*z.SetIdx)
				if err != nil {
					err = msgp.WrapError(err, "SetIdx")
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "pool_idx"
			err = en.Append(0xa8, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x78)
			if err != nil {
				return
			}
			if z.PoolIdx == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteInt(*z.PoolIdx)
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx")
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "state"
			err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.State)))
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
			for za0001, za0002 := range z.State {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "State")
					return
				}
				err = en.WriteInt(za0002)
				if err != nil {
					err = msgp.WrapError(err, "State", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "offline"
			err = en.Append(0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Offline)
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "waiting"
			err = en.Append(0xa7, 0x77, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Hanging)
			if err != nil {
				err = msgp.WrapError(err, "Hanging")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "healing"
			err = en.Append(0xa7, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Healing)
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "healingInfo"
			err = en.Append(0xab, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x49, 0x6e, 0x66, 0x6f)
			if err != nil {
				return
			}
			if z.HealingInfo == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.HealingInfo.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "HealingInfo")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "cache"
			err = en.Append(0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			if err != nil {
				return
			}
			if z.Cache == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Cache.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
			}
		}
		// write "space"
		err = en.Append(0xa5, 0x73, 0x70, 0x61, 0x63, 0x65)
		if err != nil {
			return
		}
		err = z.Space.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Space")
			return
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "lifetime_ops"
			err = en.Append(0xac, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifetimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifetimeOps")
				return
			}
			for za0003, za0004 := range z.LifetimeOps {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LifetimeOps")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LifetimeOps", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "last_minute"
			err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinute)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			for za0005, za0006 := range z.LastMinute {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				err = za0006.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "last_day"
			err = en.Append(0xa8, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x64, 0x61, 0x79)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastDaySegmented)))
			if err != nil {
				err = msgp.WrapError(err, "LastDaySegmented")
				return
			}
			for za0007, za0008 := range z.LastDaySegmented {
				err = en.WriteString(za0007)
				if err != nil {
					err = msgp.WrapError(err, "LastDaySegmented")
					return
				}
				err = (*Segmented[DiskAction, *DiskAction])(&za0008).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastDaySegmented", za0007)
					return
				}
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "iostats"
			err = en.Append(0xa7, 0x69, 0x6f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if err != nil {
				return
			}
			if z.IOStats == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.IOStats.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "IOStats")
					return
				}
			}
		}
		// write "io_min"
		err = en.Append(0xa6, 0x69, 0x6f, 0x5f, 0x6d, 0x69, 0x6e)
		if err != nil {
			return
		}
		err = z.IOStatsMinute.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "IOStatsMinute")
			return
		}
		// write "io_day"
		err = en.Append(0xa6, 0x69, 0x6f, 0x5f, 0x64, 0x61, 0x79)
		if err != nil {
			return
		}
		err = (*Segmented[DiskIOStats, *DiskIOStats])(&z.IOStatsDay).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "IOStatsDay")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DiskMetric) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(18)
	var zb0001Mask uint32 /* 18 bits */
	_ = zb0001Mask
	if z.DiskIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.SetIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.PoolIdx == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.State == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Offline == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Hanging == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Healing == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.HealingInfo == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Cache == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.LifetimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.LastMinute == nil {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.LastDaySegmented == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.IOStats == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "n_disks"
		o = append(o, 0xa7, 0x6e, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x73)
		o = msgp.AppendInt(o, z.NDisks)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "disk_idx"
			o = append(o, 0xa8, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x69, 0x64, 0x78)
			if z.DiskIdx == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendInt(o, *z.DiskIdx)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "set_idx"
			o = append(o, 0xa7, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x78)
			if z.SetIdx == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendInt(o, *z.SetIdx)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "pool_idx"
			o = append(o, 0xa8, 0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x69, 0x64, 0x78)
			if z.PoolIdx == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendInt(o, *z.PoolIdx)
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "state"
			o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x65)
			o = msgp.AppendMapHeader(o, uint32(len(z.State)))
			for za0001, za0002 := range z.State {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendInt(o, za0002)
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "offline"
			o = append(o, 0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
			o = msgp.AppendInt(o, z.Offline)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "waiting"
			o = append(o, 0xa7, 0x77, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67)
			o = msgp.AppendInt(o, z.Hanging)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "healing"
			o = append(o, 0xa7, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67)
			o = msgp.AppendInt(o, z.Healing)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "healingInfo"
			o = append(o, 0xab, 0x68, 0x65, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x49, 0x6e, 0x66, 0x6f)
			if z.HealingInfo == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.HealingInfo.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "HealingInfo")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "cache"
			o = append(o, 0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			if z.Cache == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Cache.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
			}
		}
		// string "space"
		o = append(o, 0xa5, 0x73, 0x70, 0x61, 0x63, 0x65)
		o, err = z.Space.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Space")
			return
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "lifetime_ops"
			o = append(o, 0xac, 0x6c, 0x69, 0x66, 0x65, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifetimeOps)))
			for za0003, za0004 := range z.LifetimeOps {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LifetimeOps", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "last_minute"
			o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute)))
			for za0005, za0006 := range z.LastMinute {
				o = msgp.AppendString(o, za0005)
				o, err = za0006.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "last_day"
			o = append(o, 0xa8, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x64, 0x61, 0x79)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastDaySegmented)))
			for za0007, za0008 := range z.LastDaySegmented {
				o = msgp.AppendString(o, za0007)
				o, err = (*Segmented[DiskAction, *DiskAction])(&za0008).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastDaySegmented", za0007)
					return
				}
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "iostats"
			o = append(o, 0xa7, 0x69, 0x6f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if z.IOStats == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.IOStats.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "IOStats")
					return
				}
			}
		}
		// string "io_min"
		o = append(o, 0xa6, 0x69, 0x6f, 0x5f, 0x6d, 0x69, 0x6e)
		o, err = z.IOStatsMinute.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "IOStatsMinute")
			return
		}
		// string "io_day"
		o = append(o, 0xa6, 0x69, 0x6f, 0x5f, 0x64, 0x61, 0x79)
		o, err = (*Segmented[DiskIOStats, *DiskIOStats])(&z.IOStatsDay).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "IOStatsDay")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DiskMetric) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "n_disks":
			z.NDisks, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NDisks")
				return
			}
		case "disk_idx":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DiskIdx = nil
			} else {
				if z.DiskIdx == nil {
					z.DiskIdx = new(int)
				}
				*z.DiskIdx, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DiskIdx")
					return
				}
			}
			zb0001Mask |= 0x1
		case "set_idx":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SetIdx = nil
			} else {
				if z.SetIdx == nil {
					z.SetIdx = new(int)
				}
				*z.SetIdx, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SetIdx")
					return
				}
			}
			zb0001Mask |= 0x2
		case "pool_idx":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PoolIdx = nil
			} else {
				if z.PoolIdx == nil {
					z.PoolIdx = new(int)
				}
				*z.PoolIdx, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx")
					return
				}
			}
			zb0001Mask |= 0x4
		case "state":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "State")
				return
			}
			if z.State == nil {
				z.State = make(map[string]int, zb0002)
			} else if len(z.State) > 0 {
				clear(z.State)
			}
			for zb0002 > 0 {
				var za0002 int
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "State")
					return
				}
				za0002, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "State", za0001)
					return
				}
				z.State[za0001] = za0002
			}
			zb0001Mask |= 0x8
		case "offline":
			z.Offline, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
			zb0001Mask |= 0x10
		case "waiting":
			z.Hanging, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hanging")
				return
			}
			zb0001Mask |= 0x20
		case "healing":
			z.Healing, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Healing")
				return
			}
			zb0001Mask |= 0x40
		case "healingInfo":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HealingInfo = nil
			} else {
				if z.HealingInfo == nil {
					z.HealingInfo = new(DriveHealInfo)
				}
				bts, err = z.HealingInfo.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "HealingInfo")
					return
				}
			}
			zb0001Mask |= 0x80
		case "cache":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Cache = nil
			} else {
				if z.Cache == nil {
					z.Cache = new(CacheStats)
				}
				bts, err = z.Cache.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Cache")
					return
				}
			}
			zb0001Mask |= 0x100
		case "space":
			bts, err = z.Space.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Space")
				return
			}
		case "lifetime_ops":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifetimeOps")
				return
			}
			if z.LifetimeOps == nil {
				z.LifetimeOps = make(map[string]DiskAction, zb0003)
			} else if len(z.LifetimeOps) > 0 {
				clear(z.LifetimeOps)
			}
			for zb0003 > 0 {
				var za0004 DiskAction
				zb0003--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifetimeOps")
					return
				}
				bts, err = za0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifetimeOps", za0003)
					return
				}
				z.LifetimeOps[za0003] = za0004
			}
			zb0001Mask |= 0x200
		case "last_minute":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			if z.LastMinute == nil {
				z.LastMinute = make(map[string]DiskAction, zb0004)
			} else if len(z.LastMinute) > 0 {
				clear(z.LastMinute)
			}
			for zb0004 > 0 {
				var za0006 DiskAction
				zb0004--
				var za0005 string
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				bts, err = za0006.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0005)
					return
				}
				z.LastMinute[za0005] = za0006
			}
			zb0001Mask |= 0x400
		case "last_day":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastDaySegmented")
				return
			}
			if z.LastDaySegmented == nil {
				z.LastDaySegmented = make(map[string]SegmentedDiskActions, zb0005)
			} else if len(z.LastDaySegmented) > 0 {
				clear(z.LastDaySegmented)
			}
			for zb0005 > 0 {
				var za0008 SegmentedDiskActions
				zb0005--
				var za0007 string
				za0007, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDaySegmented")
					return
				}
				bts, err = (*Segmented[DiskAction, *DiskAction])(&za0008).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDaySegmented", za0007)
					return
				}
				z.LastDaySegmented[za0007] = za0008
			}
			zb0001Mask |= 0x800
		case "iostats":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.IOStats = nil
			} else {
				if z.IOStats == nil {
					z.IOStats = new(DiskIOStatsLegacy)
				}
				bts, err = z.IOStats.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "IOStats")
					return
				}
			}
			zb0001Mask |= 0x1000
		case "io_min":
			bts, err = z.IOStatsMinute.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "IOStatsMinute")
				return
			}
		case "io_day":
			bts, err = (*Segmented[DiskIOStats, *DiskIOStats])(&z.IOStatsDay).UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "IOStatsDay")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1fff {
		if (zb0001Mask & 0x1) == 0 {
			z.DiskIdx = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.SetIdx = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.PoolIdx = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.State = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Offline = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Hanging = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Healing = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.HealingInfo = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Cache = nil
		}
		if (zb0001Mask & 0x200) == 0 {
			z.LifetimeOps = nil
		}
		if (zb0001Mask & 0x400) == 0 {
			z.LastMinute = nil
		}
		if (zb0001Mask & 0x800) == 0 {
			z.LastDaySegmented = nil
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.IOStats = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DiskMetric) Msgsize() (s int) {
	s = 3 + 10 + msgp.TimeSize + 8 + msgp.IntSize + 9
	if z.DiskIdx == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 8
	if z.SetIdx == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 9
	if z.PoolIdx == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 6 + msgp.MapHeaderSize
	if z.State != nil {
		for za0001, za0002 := range z.State {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.IntSize
		}
	}
	s += 8 + msgp.IntSize + 8 + msgp.IntSize + 8 + msgp.IntSize + 12
	if z.HealingInfo == nil {
		s += msgp.NilSize
	} else {
		s += z.HealingInfo.Msgsize()
	}
	s += 6
	if z.Cache == nil {
		s += msgp.NilSize
	} else {
		s += z.Cache.Msgsize()
	}
	s += 6 + z.Space.Msgsize() + 13 + msgp.MapHeaderSize
	if z.LifetimeOps != nil {
		for za0003, za0004 := range z.LifetimeOps {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += 12 + msgp.MapHeaderSize
	if z.LastMinute != nil {
		for za0005, za0006 := range z.LastMinute {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + za0006.Msgsize()
		}
	}
	s += 9 + msgp.MapHeaderSize
	if z.LastDaySegmented != nil {
		for za0007, za0008 := range z.LastDaySegmented {
			_ = za0008
			s += msgp.StringPrefixSize + len(za0007) + (*Segmented[DiskAction, *DiskAction])(&za0008).Msgsize()
		}
	}
	s += 8
	if z.IOStats == nil {
		s += msgp.NilSize
	} else {
		s += z.IOStats.Msgsize()
	}
	s += 7 + z.IOStatsMinute.Msgsize() + 7 + (*Segmented[DiskIOStats, *DiskIOStats])(&z.IOStatsDay).Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DriveHealInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "itemsHealed":
			z.ItemsHealed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		case "itemsFailed":
			z.ItemsFailed, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ItemsFailed")
				return
			}
		case "healID":
			z.HealID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "HealID")
				return
			}
		case "finished":
			z.Finished, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Finished")
				return
			}
		case "started":
			z.Started, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "Started")
				return
			}
		case "updated":
			z.Updated, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "Updated")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DriveHealInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "itemsHealed"
	err = en.Append(0x86, 0xab, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x48, 0x65, 0x61, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsHealed)
	if err != nil {
		err = msgp.WrapError(err, "ItemsHealed")
		return
	}
	// write "itemsFailed"
	err = en.Append(0xab, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.ItemsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ItemsFailed")
		return
	}
	// write "healID"
	err = en.Append(0xa6, 0x68, 0x65, 0x61, 0x6c, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.HealID)
	if err != nil {
		err = msgp.WrapError(err, "HealID")
		return
	}
	// write "finished"
	err = en.Append(0xa8, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Finished)
	if err != nil {
		err = msgp.WrapError(err, "Finished")
		return
	}
	// write "started"
	err = en.Append(0xa7, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Started)
	if err != nil {
		err = msgp.WrapError(err, "Started")
		return
	}
	// write "updated"
	err = en.Append(0xa7, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.Updated)
	if err != nil {
		err = msgp.WrapError(err, "Updated")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DriveHealInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "itemsHealed"
	o = append(o, 0x86, 0xab, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x48, 0x65, 0x61, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsHealed)
	// string "itemsFailed"
	o = append(o, 0xab, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.ItemsFailed)
	// string "healID"
	o = append(o, 0xa6, 0x68, 0x65, 0x61, 0x6c, 0x49, 0x44)
	o = msgp.AppendString(o, z.HealID)
	// string "finished"
	o = append(o, 0xa8, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Finished)
	// string "started"
	o = append(o, 0xa7, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.Started)
	// string "updated"
	o = append(o, 0xa7, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.Updated)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DriveHealInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "itemsHealed":
			z.ItemsHealed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsHealed")
				return
			}
		case "itemsFailed":
			z.ItemsFailed, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemsFailed")
				return
			}
		case "healID":
			z.HealID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HealID")
				return
			}
		case "finished":
			z.Finished, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Finished")
				return
			}
		case "started":
			z.Started, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Started")
				return
			}
		case "updated":
			z.Updated, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Updated")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DriveHealInfo) Msgsize() (s int) {
	s = 1 + 12 + msgp.Uint64Size + 12 + msgp.Uint64Size + 7 + msgp.StringPrefixSize + len(z.HealID) + 9 + msgp.BoolSize + 8 + msgp.TimeSize + 8 + msgp.TimeSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DriveSpaceInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "free":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
			if zb0002 != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zb0002}
				return
			}
			z.Free.Total, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Free", "Total")
				return
			}
			z.Free.Min, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Free", "Min")
				return
			}
			z.Free.Max, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Free", "Max")
				return
			}
		case "used":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
			if zb0003 != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zb0003}
				return
			}
			z.Used.Total, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Used", "Total")
				return
			}
			z.Used.Min, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Used", "Min")
				return
			}
			z.Used.Max, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Used", "Max")
				return
			}
		case "used_inodes":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes")
				return
			}
			if zb0004 != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zb0004}
				return
			}
			z.UsedInodes.Total, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes", "Total")
				return
			}
			z.UsedInodes.Min, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes", "Min")
				return
			}
			z.UsedInodes.Max, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes", "Max")
				return
			}
		case "free_inodes":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes")
				return
			}
			if zb0005 != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zb0005}
				return
			}
			z.FreeInodes.Total, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes", "Total")
				return
			}
			z.FreeInodes.Min, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes", "Min")
				return
			}
			z.FreeInodes.Max, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes", "Max")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DriveSpaceInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "n"
	err = en.Append(0x85, 0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.N)
	if err != nil {
		err = msgp.WrapError(err, "N")
		return
	}
	// write "free"
	err = en.Append(0xa4, 0x66, 0x72, 0x65, 0x65)
	if err != nil {
		return
	}
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Free.Total)
	if err != nil {
		err = msgp.WrapError(err, "Free", "Total")
		return
	}
	err = en.WriteUint64(z.Free.Min)
	if err != nil {
		err = msgp.WrapError(err, "Free", "Min")
		return
	}
	err = en.WriteUint64(z.Free.Max)
	if err != nil {
		err = msgp.WrapError(err, "Free", "Max")
		return
	}
	// write "used"
	err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x64)
	if err != nil {
		return
	}
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Used.Total)
	if err != nil {
		err = msgp.WrapError(err, "Used", "Total")
		return
	}
	err = en.WriteUint64(z.Used.Min)
	if err != nil {
		err = msgp.WrapError(err, "Used", "Min")
		return
	}
	err = en.WriteUint64(z.Used.Max)
	if err != nil {
		err = msgp.WrapError(err, "Used", "Max")
		return
	}
	// write "used_inodes"
	err = en.Append(0xab, 0x75, 0x73, 0x65, 0x64, 0x5f, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.UsedInodes.Total)
	if err != nil {
		err = msgp.WrapError(err, "UsedInodes", "Total")
		return
	}
	err = en.WriteUint64(z.UsedInodes.Min)
	if err != nil {
		err = msgp.WrapError(err, "UsedInodes", "Min")
		return
	}
	err = en.WriteUint64(z.UsedInodes.Max)
	if err != nil {
		err = msgp.WrapError(err, "UsedInodes", "Max")
		return
	}
	// write "free_inodes"
	err = en.Append(0xab, 0x66, 0x72, 0x65, 0x65, 0x5f, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.FreeInodes.Total)
	if err != nil {
		err = msgp.WrapError(err, "FreeInodes", "Total")
		return
	}
	err = en.WriteUint64(z.FreeInodes.Min)
	if err != nil {
		err = msgp.WrapError(err, "FreeInodes", "Min")
		return
	}
	err = en.WriteUint64(z.FreeInodes.Max)
	if err != nil {
		err = msgp.WrapError(err, "FreeInodes", "Max")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DriveSpaceInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "n"
	o = append(o, 0x85, 0xa1, 0x6e)
	o = msgp.AppendInt(o, z.N)
	// string "free"
	o = append(o, 0xa4, 0x66, 0x72, 0x65, 0x65)
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendUint64(o, z.Free.Total)
	o = msgp.AppendUint64(o, z.Free.Min)
	o = msgp.AppendUint64(o, z.Free.Max)
	// string "used"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x64)
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendUint64(o, z.Used.Total)
	o = msgp.AppendUint64(o, z.Used.Min)
	o = msgp.AppendUint64(o, z.Used.Max)
	// string "used_inodes"
	o = append(o, 0xab, 0x75, 0x73, 0x65, 0x64, 0x5f, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendUint64(o, z.UsedInodes.Total)
	o = msgp.AppendUint64(o, z.UsedInodes.Min)
	o = msgp.AppendUint64(o, z.UsedInodes.Max)
	// string "free_inodes"
	o = append(o, 0xab, 0x66, 0x72, 0x65, 0x65, 0x5f, 0x69, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendUint64(o, z.FreeInodes.Total)
	o = msgp.AppendUint64(o, z.FreeInodes.Min)
	o = msgp.AppendUint64(o, z.FreeInodes.Max)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DriveSpaceInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "free":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
			if zb0002 != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zb0002}
				return
			}
			z.Free.Total, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Free", "Total")
				return
			}
			z.Free.Min, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Free", "Min")
				return
			}
			z.Free.Max, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Free", "Max")
				return
			}
		case "used":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
			if zb0003 != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zb0003}
				return
			}
			z.Used.Total, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Used", "Total")
				return
			}
			z.Used.Min, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Used", "Min")
				return
			}
			z.Used.Max, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Used", "Max")
				return
			}
		case "used_inodes":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes")
				return
			}
			if zb0004 != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zb0004}
				return
			}
			z.UsedInodes.Total, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes", "Total")
				return
			}
			z.UsedInodes.Min, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes", "Min")
				return
			}
			z.UsedInodes.Max, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UsedInodes", "Max")
				return
			}
		case "free_inodes":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes")
				return
			}
			if zb0005 != 3 {
				err = msgp.ArrayError{Wanted: 3, Got: zb0005}
				return
			}
			z.FreeInodes.Total, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes", "Total")
				return
			}
			z.FreeInodes.Min, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes", "Min")
				return
			}
			z.FreeInodes.Max, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FreeInodes", "Max")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DriveSpaceInfo) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 5 + 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size + 5 + 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size + 12 + 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size + 12 + 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ExpirationInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ExpirationInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "lastBucket"
	err = en.Append(0x86, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	// write "deleteMarkers"
	err = en.Append(0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkers)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkers")
		return
	}
	// write "deleteMarkersFailed"
	err = en.Append(0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkersFailed)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkersFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ExpirationInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "lastBucket"
	o = append(o, 0x86, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	// string "deleteMarkers"
	o = append(o, 0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	o = msgp.AppendInt64(o, z.DeleteMarkers)
	// string "deleteMarkersFailed"
	o = append(o, 0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.DeleteMarkersFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ExpirationInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ExpirationInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 20 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *InterfaceStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "stats":
			err = (*procfsNetDevLine)(&z.NetDevLine).DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "NetDevLine")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *InterfaceStats) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "n"
	err = en.Append(0x82, 0xa1, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.N)
	if err != nil {
		err = msgp.WrapError(err, "N")
		return
	}
	// write "stats"
	err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = (*procfsNetDevLine)(&z.NetDevLine).EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "NetDevLine")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *InterfaceStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "n"
	o = append(o, 0x82, 0xa1, 0x6e)
	o = msgp.AppendInt(o, z.N)
	// string "stats"
	o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x73)
	o, err = (*procfsNetDevLine)(&z.NetDevLine).MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "NetDevLine")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *InterfaceStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "n":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "stats":
			bts, err = (*procfsNetDevLine)(&z.NetDevLine).UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetDevLine")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *InterfaceStats) Msgsize() (s int) {
	s = 1 + 2 + msgp.IntSize + 6 + (*procfsNetDevLine)(&z.NetDevLine).Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *JobMetric) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "jobID":
			z.JobID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "JobID")
				return
			}
		case "jobType":
			z.JobType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "JobType")
				return
			}
		case "startTime":
			z.StartTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retryAttempts":
			z.RetryAttempts, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "complete":
			z.Complete, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Complete")
				return
			}
		case "failed":
			z.Failed, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Failed")
				return
			}
		case "status":
			z.Status, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "replicate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
				z.Replicate = nil
			} else {
				if z.Replicate == nil {
					z.Replicate = new(ReplicateInfo)
				}
				err = z.Replicate.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
			zb0001Mask |= 0x1
		case "rotation":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
				z.KeyRotate = nil
			} else {
				if z.KeyRotate == nil {
					z.KeyRotate = new(KeyRotationInfo)
				}
				err = z.KeyRotate.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
			zb0001Mask |= 0x2
		case "expired":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
				z.Expired = nil
			} else {
				if z.Expired == nil {
					z.Expired = new(ExpirationInfo)
				}
				err = z.Expired.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
			zb0001Mask |= 0x4
		case "catalog":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
				z.Catalog = nil
			} else {
				if z.Catalog == nil {
					z.Catalog = new(CatalogInfo)
				}
				err = z.Catalog.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Replicate = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.KeyRotate = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Expired = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Catalog = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *JobMetric) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(12)
	var zb0001Mask uint16 /* 12 bits */
	_ = zb0001Mask
	if z.Replicate == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.KeyRotate == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Expired == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.Catalog == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "jobID"
		err = en.Append(0xa5, 0x6a, 0x6f, 0x62, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.JobID)
		if err != nil {
			err = msgp.WrapError(err, "JobID")
			return
		}
		// write "jobType"
		err = en.Append(0xa7, 0x6a, 0x6f, 0x62, 0x54, 0x79, 0x70, 0x65)
		if err != nil {
			return
		}
		err = en.WriteString(z.JobType)
		if err != nil {
			err = msgp.WrapError(err, "JobType")
			return
		}
		// write "startTime"
		err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.StartTime)
		if err != nil {
			err = msgp.WrapError(err, "StartTime")
			return
		}
		// write "lastUpdate"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastUpdate)
		if err != nil {
			err = msgp.WrapError(err, "LastUpdate")
			return
		}
		// write "retryAttempts"
		err = en.Append(0xad, 0x72, 0x65, 0x74, 0x72, 0x79, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.RetryAttempts)
		if err != nil {
			err = msgp.WrapError(err, "RetryAttempts")
			return
		}
		// write "complete"
		err = en.Append(0xa8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Complete)
		if err != nil {
			err = msgp.WrapError(err, "Complete")
			return
		}
		// write "failed"
		err = en.Append(0xa6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Failed)
		if err != nil {
			err = msgp.WrapError(err, "Failed")
			return
		}
		// write "status"
		err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		if err != nil {
			return
		}
		err = en.WriteString(z.Status)
		if err != nil {
			err = msgp.WrapError(err, "Status")
			return
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "replicate"
			err = en.Append(0xa9, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65)
			if err != nil {
				return
			}
			if z.Replicate == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Replicate.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "rotation"
			err = en.Append(0xa8, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if err != nil {
				return
			}
			if z.KeyRotate == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.KeyRotate.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "expired"
			err = en.Append(0xa7, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64)
			if err != nil {
				return
			}
			if z.Expired == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Expired.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "catalog"
			err = en.Append(0xa7, 0x63, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67)
			if err != nil {
				return
			}
			if z.Catalog == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Catalog.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *JobMetric) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(12)
	var zb0001Mask uint16 /* 12 bits */
	_ = zb0001Mask
	if z.Replicate == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.KeyRotate == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Expired == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.Catalog == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "jobID"
		o = append(o, 0xa5, 0x6a, 0x6f, 0x62, 0x49, 0x44)
		o = msgp.AppendString(o, z.JobID)
		// string "jobType"
		o = append(o, 0xa7, 0x6a, 0x6f, 0x62, 0x54, 0x79, 0x70, 0x65)
		o = msgp.AppendString(o, z.JobType)
		// string "startTime"
		o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.StartTime)
		// string "lastUpdate"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		o = msgp.AppendTime(o, z.LastUpdate)
		// string "retryAttempts"
		o = append(o, 0xad, 0x72, 0x65, 0x74, 0x72, 0x79, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73)
		o = msgp.AppendInt(o, z.RetryAttempts)
		// string "complete"
		o = append(o, 0xa8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65)
		o = msgp.AppendBool(o, z.Complete)
		// string "failed"
		o = append(o, 0xa6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64)
		o = msgp.AppendBool(o, z.Failed)
		// string "status"
		o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
		o = msgp.AppendString(o, z.Status)
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "replicate"
			o = append(o, 0xa9, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65)
			if z.Replicate == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Replicate.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "rotation"
			o = append(o, 0xa8, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if z.KeyRotate == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.KeyRotate.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "expired"
			o = append(o, 0xa7, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x64)
			if z.Expired == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Expired.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "catalog"
			o = append(o, 0xa7, 0x63, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67)
			if z.Catalog == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Catalog.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *JobMetric) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "jobID":
			z.JobID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "JobID")
				return
			}
		case "jobType":
			z.JobType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "JobType")
				return
			}
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "retryAttempts":
			z.RetryAttempts, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RetryAttempts")
				return
			}
		case "complete":
			z.Complete, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Complete")
				return
			}
		case "failed":
			z.Failed, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Failed")
				return
			}
		case "status":
			z.Status, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Status")
				return
			}
		case "replicate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Replicate = nil
			} else {
				if z.Replicate == nil {
					z.Replicate = new(ReplicateInfo)
				}
				bts, err = z.Replicate.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Replicate")
					return
				}
			}
			zb0001Mask |= 0x1
		case "rotation":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.KeyRotate = nil
			} else {
				if z.KeyRotate == nil {
					z.KeyRotate = new(KeyRotationInfo)
				}
				bts, err = z.KeyRotate.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "KeyRotate")
					return
				}
			}
			zb0001Mask |= 0x2
		case "expired":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Expired = nil
			} else {
				if z.Expired == nil {
					z.Expired = new(ExpirationInfo)
				}
				bts, err = z.Expired.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Expired")
					return
				}
			}
			zb0001Mask |= 0x4
		case "catalog":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Catalog = nil
			} else {
				if z.Catalog == nil {
					z.Catalog = new(CatalogInfo)
				}
				bts, err = z.Catalog.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Catalog")
					return
				}
			}
			zb0001Mask |= 0x8
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Replicate = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.KeyRotate = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Expired = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Catalog = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *JobMetric) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.JobID) + 8 + msgp.StringPrefixSize + len(z.JobType) + 10 + msgp.TimeSize + 11 + msgp.TimeSize + 14 + msgp.IntSize + 9 + msgp.BoolSize + 7 + msgp.BoolSize + 7 + msgp.StringPrefixSize + len(z.Status) + 10
	if z.Replicate == nil {
		s += msgp.NilSize
	} else {
		s += z.Replicate.Msgsize()
	}
	s += 9
	if z.KeyRotate == nil {
		s += msgp.NilSize
	} else {
		s += z.KeyRotate.Msgsize()
	}
	s += 8
	if z.Expired == nil {
		s += msgp.NilSize
	} else {
		s += z.Expired.Msgsize()
	}
	s += 8
	if z.Catalog == nil {
		s += msgp.NilSize
	} else {
		s += z.Catalog.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *KeyRotationInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *KeyRotationInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "lastBucket"
	err = en.Append(0x84, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *KeyRotationInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "lastBucket"
	o = append(o, 0x84, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *KeyRotationInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *KeyRotationInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MemInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "NodeCommon":
			err = (*nodeCommon)(&z.NodeCommon).DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "NodeCommon")
				return
			}
		case "total":
			z.Total, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
			zb0001Mask |= 0x1
		case "used":
			z.Used, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
			zb0001Mask |= 0x2
		case "free":
			z.Free, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
			zb0001Mask |= 0x4
		case "available":
			z.Available, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
			zb0001Mask |= 0x8
		case "shared":
			z.Shared, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
			zb0001Mask |= 0x10
		case "cache":
			z.Cache, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
			zb0001Mask |= 0x20
		case "buffer":
			z.Buffers, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
			zb0001Mask |= 0x40
		case "swap_space_total":
			z.SwapSpaceTotal, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
			zb0001Mask |= 0x80
		case "swap_space_free":
			z.SwapSpaceFree, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
			zb0001Mask |= 0x100
		case "limit":
			z.Limit, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
			zb0001Mask |= 0x200
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Total = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Used = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Free = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Available = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Shared = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Cache = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Buffers = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.SwapSpaceTotal = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.SwapSpaceFree = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Limit = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MemInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Total == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Used == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Free == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Available == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Shared == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Cache == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Buffers == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.SwapSpaceTotal == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.SwapSpaceFree == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Limit == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "NodeCommon"
		err = en.Append(0xaa, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e)
		if err != nil {
			return
		}
		err = (*nodeCommon)(&z.NodeCommon).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "NodeCommon")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "total"
			err = en.Append(0xa5, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Total)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "used"
			err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Used)
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "free"
			err = en.Append(0xa4, 0x66, 0x72, 0x65, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Free)
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "available"
			err = en.Append(0xa9, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Available)
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "shared"
			err = en.Append(0xa6, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Shared)
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "cache"
			err = en.Append(0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Cache)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "buffer"
			err = en.Append(0xa6, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Buffers)
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "swap_space_total"
			err = en.Append(0xb0, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.SwapSpaceTotal)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "swap_space_free"
			err = en.Append(0xaf, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x66, 0x72, 0x65, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.SwapSpaceFree)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "limit"
			err = en.Append(0xa5, 0x6c, 0x69, 0x6d, 0x69, 0x74)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Limit)
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MemInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.Total == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Used == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Free == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Available == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Shared == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Cache == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Buffers == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.SwapSpaceTotal == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.SwapSpaceFree == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Limit == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "NodeCommon"
		o = append(o, 0xaa, 0x4e, 0x6f, 0x64, 0x65, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e)
		o, err = (*nodeCommon)(&z.NodeCommon).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "NodeCommon")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "total"
			o = append(o, 0xa5, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			o = msgp.AppendUint64(o, z.Total)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "used"
			o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.Used)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "free"
			o = append(o, 0xa4, 0x66, 0x72, 0x65, 0x65)
			o = msgp.AppendUint64(o, z.Free)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "available"
			o = append(o, 0xa9, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65)
			o = msgp.AppendUint64(o, z.Available)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "shared"
			o = append(o, 0xa6, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.Shared)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "cache"
			o = append(o, 0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			o = msgp.AppendUint64(o, z.Cache)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "buffer"
			o = append(o, 0xa6, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72)
			o = msgp.AppendUint64(o, z.Buffers)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "swap_space_total"
			o = append(o, 0xb0, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c)
			o = msgp.AppendUint64(o, z.SwapSpaceTotal)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "swap_space_free"
			o = append(o, 0xaf, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x5f, 0x66, 0x72, 0x65, 0x65)
			o = msgp.AppendUint64(o, z.SwapSpaceFree)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "limit"
			o = append(o, 0xa5, 0x6c, 0x69, 0x6d, 0x69, 0x74)
			o = msgp.AppendUint64(o, z.Limit)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MemInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 10 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "NodeCommon":
			bts, err = (*nodeCommon)(&z.NodeCommon).UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "NodeCommon")
				return
			}
		case "total":
			z.Total, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Total")
				return
			}
			zb0001Mask |= 0x1
		case "used":
			z.Used, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Used")
				return
			}
			zb0001Mask |= 0x2
		case "free":
			z.Free, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Free")
				return
			}
			zb0001Mask |= 0x4
		case "available":
			z.Available, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Available")
				return
			}
			zb0001Mask |= 0x8
		case "shared":
			z.Shared, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
			zb0001Mask |= 0x10
		case "cache":
			z.Cache, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cache")
				return
			}
			zb0001Mask |= 0x20
		case "buffer":
			z.Buffers, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Buffers")
				return
			}
			zb0001Mask |= 0x40
		case "swap_space_total":
			z.SwapSpaceTotal, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceTotal")
				return
			}
			zb0001Mask |= 0x80
		case "swap_space_free":
			z.SwapSpaceFree, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SwapSpaceFree")
				return
			}
			zb0001Mask |= 0x100
		case "limit":
			z.Limit, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Limit")
				return
			}
			zb0001Mask |= 0x200
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3ff {
		if (zb0001Mask & 0x1) == 0 {
			z.Total = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Used = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Free = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Available = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Shared = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Cache = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Buffers = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.SwapSpaceTotal = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.SwapSpaceFree = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Limit = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MemInfo) Msgsize() (s int) {
	s = 1 + 11 + (*nodeCommon)(&z.NodeCommon).Msgsize() + 6 + msgp.Uint64Size + 5 + msgp.Uint64Size + 5 + msgp.Uint64Size + 10 + msgp.Uint64Size + 7 + msgp.Uint64Size + 6 + msgp.Uint64Size + 7 + msgp.Uint64Size + 17 + msgp.Uint64Size + 16 + msgp.Uint64Size + 6 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MemMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "memInfo":
			err = z.Info.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MemMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "collected"
	err = en.Append(0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "nodes"
	err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Nodes)
	if err != nil {
		err = msgp.WrapError(err, "Nodes")
		return
	}
	// write "memInfo"
	err = en.Append(0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
	if err != nil {
		return
	}
	err = z.Info.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Info")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MemMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "collected"
	o = append(o, 0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "nodes"
	o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendInt(o, z.Nodes)
	// string "memInfo"
	o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
	o, err = z.Info.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Info")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MemMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "memInfo":
			bts, err = z.Info.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Info")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MemMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 6 + msgp.IntSize + 8 + z.Info.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MetricFlags) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint64
		zb0001, err = dc.ReadUint64()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MetricFlags(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MetricFlags) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint64(uint64(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MetricFlags) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint64(o, uint64(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MetricFlags) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint64
		zb0001, bts, err = msgp.ReadUint64Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MetricFlags(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MetricFlags) Msgsize() (s int) {
	s = msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MetricType) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 uint32
		zb0001, err = dc.ReadUint32()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MetricType(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MetricType) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteUint32(uint32(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MetricType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendUint32(o, uint32(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MetricType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 uint32
		zb0001, bts, err = msgp.ReadUint32Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MetricType(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MetricType) Msgsize() (s int) {
	s = msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Metrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "scanner":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
				z.Scanner = nil
			} else {
				if z.Scanner == nil {
					z.Scanner = new(ScannerMetrics)
				}
				err = z.Scanner.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
			zb0001Mask |= 0x1
		case "disk":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
				z.Disk = nil
			} else {
				if z.Disk == nil {
					z.Disk = new(DiskMetric)
				}
				err = z.Disk.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
			zb0001Mask |= 0x2
		case "os":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
				z.OS = nil
			} else {
				if z.OS == nil {
					z.OS = new(OSMetrics)
				}
				err = z.OS.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
			zb0001Mask |= 0x4
		case "batchJobs":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
				z.BatchJobs = nil
			} else {
				if z.BatchJobs == nil {
					z.BatchJobs = new(BatchJobMetrics)
				}
				err = z.BatchJobs.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
			zb0001Mask |= 0x8
		case "siteResync":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
				z.SiteResync = nil
			} else {
				if z.SiteResync == nil {
					z.SiteResync = new(SiteResyncMetrics)
				}
				err = z.SiteResync.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
			zb0001Mask |= 0x10
		case "net":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
				z.Net = nil
			} else {
				if z.Net == nil {
					z.Net = new(NetMetrics)
				}
				err = z.Net.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
			}
			zb0001Mask |= 0x20
		case "mem":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				z.Mem = nil
			} else {
				if z.Mem == nil {
					z.Mem = new(MemMetrics)
				}
				var zb0002 uint32
				zb0002, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Mem")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Mem.CollectedAt, err = dc.ReadTimeUTC()
						if err != nil {
							err = msgp.WrapError(err, "Mem", "CollectedAt")
							return
						}
					case "nodes":
						z.Mem.Nodes, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Mem", "Nodes")
							return
						}
					case "memInfo":
						err = z.Mem.Info.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "Info")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Mem")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x40
		case "cpu":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
				z.CPU = nil
			} else {
				if z.CPU == nil {
					z.CPU = new(CPUMetrics)
				}
				err = z.CPU.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
			zb0001Mask |= 0x80
		case "rpc":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
				z.RPC = nil
			} else {
				if z.RPC == nil {
					z.RPC = new(RPCMetrics)
				}
				err = z.RPC.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
			zb0001Mask |= 0x100
		case "go":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
				z.Go = nil
			} else {
				if z.Go == nil {
					z.Go = new(RuntimeMetrics)
				}
				err = z.Go.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
			zb0001Mask |= 0x200
		case "api":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
				z.API = nil
			} else {
				if z.API == nil {
					z.API = new(APIMetrics)
				}
				err = z.API.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
			}
			zb0001Mask |= 0x400
		case "replication":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Replication")
					return
				}
				z.Replication = nil
			} else {
				if z.Replication == nil {
					z.Replication = new(ReplicationMetrics)
				}
				err = z.Replication.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Replication")
					return
				}
			}
			zb0001Mask |= 0x800
		case "process":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Process")
					return
				}
				z.Process = nil
			} else {
				if z.Process == nil {
					z.Process = new(ProcessMetrics)
				}
				err = z.Process.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Process")
					return
				}
			}
			zb0001Mask |= 0x1000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1fff {
		if (zb0001Mask & 0x1) == 0 {
			z.Scanner = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Disk = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.OS = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.BatchJobs = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.SiteResync = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Net = nil
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Mem = nil
		}
		if (zb0001Mask & 0x80) == 0 {
			z.CPU = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.RPC = nil
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Go = nil
		}
		if (zb0001Mask & 0x400) == 0 {
			z.API = nil
		}
		if (zb0001Mask & 0x800) == 0 {
			z.Replication = nil
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.Process = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Metrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.Scanner == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Disk == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.OS == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.BatchJobs == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.SiteResync == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Net == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mem == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.CPU == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.RPC == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Go == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.API == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.Replication == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.Process == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "scanner"
			err = en.Append(0xa7, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x72)
			if err != nil {
				return
			}
			if z.Scanner == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Scanner.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "disk"
			err = en.Append(0xa4, 0x64, 0x69, 0x73, 0x6b)
			if err != nil {
				return
			}
			if z.Disk == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Disk.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "os"
			err = en.Append(0xa2, 0x6f, 0x73)
			if err != nil {
				return
			}
			if z.OS == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.OS.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "batchJobs"
			err = en.Append(0xa9, 0x62, 0x61, 0x74, 0x63, 0x68, 0x4a, 0x6f, 0x62, 0x73)
			if err != nil {
				return
			}
			if z.BatchJobs == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.BatchJobs.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "siteResync"
			err = en.Append(0xaa, 0x73, 0x69, 0x74, 0x65, 0x52, 0x65, 0x73, 0x79, 0x6e, 0x63)
			if err != nil {
				return
			}
			if z.SiteResync == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.SiteResync.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "net"
			err = en.Append(0xa3, 0x6e, 0x65, 0x74)
			if err != nil {
				return
			}
			if z.Net == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Net.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "mem"
			err = en.Append(0xa3, 0x6d, 0x65, 0x6d)
			if err != nil {
				return
			}
			if z.Mem == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				// map header, size 3
				// write "collected"
				err = en.Append(0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				if err != nil {
					return
				}
				err = en.WriteTime(z.Mem.CollectedAt)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "CollectedAt")
					return
				}
				// write "nodes"
				err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
				if err != nil {
					return
				}
				err = en.WriteInt(z.Mem.Nodes)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "Nodes")
					return
				}
				// write "memInfo"
				err = en.Append(0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
				if err != nil {
					return
				}
				err = z.Mem.Info.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "Info")
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "cpu"
			err = en.Append(0xa3, 0x63, 0x70, 0x75)
			if err != nil {
				return
			}
			if z.CPU == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.CPU.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "rpc"
			err = en.Append(0xa3, 0x72, 0x70, 0x63)
			if err != nil {
				return
			}
			if z.RPC == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.RPC.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "go"
			err = en.Append(0xa2, 0x67, 0x6f)
			if err != nil {
				return
			}
			if z.Go == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Go.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "api"
			err = en.Append(0xa3, 0x61, 0x70, 0x69)
			if err != nil {
				return
			}
			if z.API == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.API.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "replication"
			err = en.Append(0xab, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if err != nil {
				return
			}
			if z.Replication == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Replication.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Replication")
					return
				}
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "process"
			err = en.Append(0xa7, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
			if err != nil {
				return
			}
			if z.Process == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = z.Process.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Process")
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Metrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(13)
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	if z.Scanner == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Disk == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.OS == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.BatchJobs == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.SiteResync == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Net == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Mem == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.CPU == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.RPC == nil {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.Go == nil {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.API == nil {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.Replication == nil {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.Process == nil {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "scanner"
			o = append(o, 0xa7, 0x73, 0x63, 0x61, 0x6e, 0x6e, 0x65, 0x72)
			if z.Scanner == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Scanner.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "disk"
			o = append(o, 0xa4, 0x64, 0x69, 0x73, 0x6b)
			if z.Disk == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Disk.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "os"
			o = append(o, 0xa2, 0x6f, 0x73)
			if z.OS == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.OS.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "batchJobs"
			o = append(o, 0xa9, 0x62, 0x61, 0x74, 0x63, 0x68, 0x4a, 0x6f, 0x62, 0x73)
			if z.BatchJobs == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.BatchJobs.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "siteResync"
			o = append(o, 0xaa, 0x73, 0x69, 0x74, 0x65, 0x52, 0x65, 0x73, 0x79, 0x6e, 0x63)
			if z.SiteResync == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.SiteResync.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "net"
			o = append(o, 0xa3, 0x6e, 0x65, 0x74)
			if z.Net == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Net.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "mem"
			o = append(o, 0xa3, 0x6d, 0x65, 0x6d)
			if z.Mem == nil {
				o = msgp.AppendNil(o)
			} else {
				// map header, size 3
				// string "collected"
				o = append(o, 0x83, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
				o = msgp.AppendTime(o, z.Mem.CollectedAt)
				// string "nodes"
				o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
				o = msgp.AppendInt(o, z.Mem.Nodes)
				// string "memInfo"
				o = append(o, 0xa7, 0x6d, 0x65, 0x6d, 0x49, 0x6e, 0x66, 0x6f)
				o, err = z.Mem.Info.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Mem", "Info")
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "cpu"
			o = append(o, 0xa3, 0x63, 0x70, 0x75)
			if z.CPU == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.CPU.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "rpc"
			o = append(o, 0xa3, 0x72, 0x70, 0x63)
			if z.RPC == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.RPC.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "go"
			o = append(o, 0xa2, 0x67, 0x6f)
			if z.Go == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Go.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "api"
			o = append(o, 0xa3, 0x61, 0x70, 0x69)
			if z.API == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.API.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "replication"
			o = append(o, 0xab, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if z.Replication == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Replication.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Replication")
					return
				}
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "process"
			o = append(o, 0xa7, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
			if z.Process == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = z.Process.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Process")
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Metrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 13 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "scanner":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Scanner = nil
			} else {
				if z.Scanner == nil {
					z.Scanner = new(ScannerMetrics)
				}
				bts, err = z.Scanner.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Scanner")
					return
				}
			}
			zb0001Mask |= 0x1
		case "disk":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Disk = nil
			} else {
				if z.Disk == nil {
					z.Disk = new(DiskMetric)
				}
				bts, err = z.Disk.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disk")
					return
				}
			}
			zb0001Mask |= 0x2
		case "os":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OS = nil
			} else {
				if z.OS == nil {
					z.OS = new(OSMetrics)
				}
				bts, err = z.OS.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "OS")
					return
				}
			}
			zb0001Mask |= 0x4
		case "batchJobs":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BatchJobs = nil
			} else {
				if z.BatchJobs == nil {
					z.BatchJobs = new(BatchJobMetrics)
				}
				bts, err = z.BatchJobs.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "BatchJobs")
					return
				}
			}
			zb0001Mask |= 0x8
		case "siteResync":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SiteResync = nil
			} else {
				if z.SiteResync == nil {
					z.SiteResync = new(SiteResyncMetrics)
				}
				bts, err = z.SiteResync.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "SiteResync")
					return
				}
			}
			zb0001Mask |= 0x10
		case "net":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Net = nil
			} else {
				if z.Net == nil {
					z.Net = new(NetMetrics)
				}
				bts, err = z.Net.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Net")
					return
				}
			}
			zb0001Mask |= 0x20
		case "mem":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Mem = nil
			} else {
				if z.Mem == nil {
					z.Mem = new(MemMetrics)
				}
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Mem")
					return
				}
				for zb0002 > 0 {
					zb0002--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Mem")
						return
					}
					switch msgp.UnsafeString(field) {
					case "collected":
						z.Mem.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "CollectedAt")
							return
						}
					case "nodes":
						z.Mem.Nodes, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "Nodes")
							return
						}
					case "memInfo":
						bts, err = z.Mem.Info.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem", "Info")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Mem")
							return
						}
					}
				}
			}
			zb0001Mask |= 0x40
		case "cpu":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CPU = nil
			} else {
				if z.CPU == nil {
					z.CPU = new(CPUMetrics)
				}
				bts, err = z.CPU.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "CPU")
					return
				}
			}
			zb0001Mask |= 0x80
		case "rpc":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RPC = nil
			} else {
				if z.RPC == nil {
					z.RPC = new(RPCMetrics)
				}
				bts, err = z.RPC.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "RPC")
					return
				}
			}
			zb0001Mask |= 0x100
		case "go":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Go = nil
			} else {
				if z.Go == nil {
					z.Go = new(RuntimeMetrics)
				}
				bts, err = z.Go.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Go")
					return
				}
			}
			zb0001Mask |= 0x200
		case "api":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.API = nil
			} else {
				if z.API == nil {
					z.API = new(APIMetrics)
				}
				bts, err = z.API.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "API")
					return
				}
			}
			zb0001Mask |= 0x400
		case "replication":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Replication = nil
			} else {
				if z.Replication == nil {
					z.Replication = new(ReplicationMetrics)
				}
				bts, err = z.Replication.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Replication")
					return
				}
			}
			zb0001Mask |= 0x800
		case "process":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Process = nil
			} else {
				if z.Process == nil {
					z.Process = new(ProcessMetrics)
				}
				bts, err = z.Process.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Process")
					return
				}
			}
			zb0001Mask |= 0x1000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1fff {
		if (zb0001Mask & 0x1) == 0 {
			z.Scanner = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Disk = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.OS = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.BatchJobs = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.SiteResync = nil
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Net = nil
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Mem = nil
		}
		if (zb0001Mask & 0x80) == 0 {
			z.CPU = nil
		}
		if (zb0001Mask & 0x100) == 0 {
			z.RPC = nil
		}
		if (zb0001Mask & 0x200) == 0 {
			z.Go = nil
		}
		if (zb0001Mask & 0x400) == 0 {
			z.API = nil
		}
		if (zb0001Mask & 0x800) == 0 {
			z.Replication = nil
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.Process = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Metrics) Msgsize() (s int) {
	s = 1 + 8
	if z.Scanner == nil {
		s += msgp.NilSize
	} else {
		s += z.Scanner.Msgsize()
	}
	s += 5
	if z.Disk == nil {
		s += msgp.NilSize
	} else {
		s += z.Disk.Msgsize()
	}
	s += 3
	if z.OS == nil {
		s += msgp.NilSize
	} else {
		s += z.OS.Msgsize()
	}
	s += 10
	if z.BatchJobs == nil {
		s += msgp.NilSize
	} else {
		s += z.BatchJobs.Msgsize()
	}
	s += 11
	if z.SiteResync == nil {
		s += msgp.NilSize
	} else {
		s += z.SiteResync.Msgsize()
	}
	s += 4
	if z.Net == nil {
		s += msgp.NilSize
	} else {
		s += z.Net.Msgsize()
	}
	s += 4
	if z.Mem == nil {
		s += msgp.NilSize
	} else {
		s += 1 + 10 + msgp.TimeSize + 6 + msgp.IntSize + 8 + z.Mem.Info.Msgsize()
	}
	s += 4
	if z.CPU == nil {
		s += msgp.NilSize
	} else {
		s += z.CPU.Msgsize()
	}
	s += 4
	if z.RPC == nil {
		s += msgp.NilSize
	} else {
		s += z.RPC.Msgsize()
	}
	s += 3
	if z.Go == nil {
		s += msgp.NilSize
	} else {
		s += z.Go.Msgsize()
	}
	s += 4
	if z.API == nil {
		s += msgp.NilSize
	} else {
		s += z.API.Msgsize()
	}
	s += 12
	if z.Replication == nil {
		s += msgp.NilSize
	} else {
		s += z.Replication.Msgsize()
	}
	s += 8
	if z.Process == nil {
		s += msgp.NilSize
	} else {
		s += z.Process.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MetricsOptions) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			{
				var zb0002 uint32
				zb0002, err = dc.ReadUint32()
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = MetricType(zb0002)
			}
		case "Flags":
			{
				var zb0003 uint64
				zb0003, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "Flags")
					return
				}
				z.Flags = MetricFlags(zb0003)
			}
		case "N":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "Interval":
			z.Interval, err = dc.ReadDuration()
			if err != nil {
				err = msgp.WrapError(err, "Interval")
				return
			}
		case "PoolIdx":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PoolIdx")
				return
			}
			if cap(z.PoolIdx) >= int(zb0004) {
				z.PoolIdx = (z.PoolIdx)[:zb0004]
			} else {
				z.PoolIdx = make([]int, zb0004)
			}
			for za0001 := range z.PoolIdx {
				z.PoolIdx[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx", za0001)
					return
				}
			}
		case "Hosts":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0005) {
				z.Hosts = (z.Hosts)[:zb0005]
			} else {
				z.Hosts = make([]string, zb0005)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "DrivePoolIdx":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DrivePoolIdx")
				return
			}
			if cap(z.DrivePoolIdx) >= int(zb0006) {
				z.DrivePoolIdx = (z.DrivePoolIdx)[:zb0006]
			} else {
				z.DrivePoolIdx = make([]int, zb0006)
			}
			for za0003 := range z.DrivePoolIdx {
				z.DrivePoolIdx[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DrivePoolIdx", za0003)
					return
				}
			}
		case "DriveSetIdx":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DriveSetIdx")
				return
			}
			if cap(z.DriveSetIdx) >= int(zb0007) {
				z.DriveSetIdx = (z.DriveSetIdx)[:zb0007]
			} else {
				z.DriveSetIdx = make([]int, zb0007)
			}
			for za0004 := range z.DriveSetIdx {
				z.DriveSetIdx[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DriveSetIdx", za0004)
					return
				}
			}
		case "Disks":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0008) {
				z.Disks = (z.Disks)[:zb0008]
			} else {
				z.Disks = make([]string, zb0008)
			}
			for za0005 := range z.Disks {
				z.Disks[za0005], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0005)
					return
				}
			}
		case "ByJobID":
			z.ByJobID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ByJobID")
				return
			}
		case "ByDepID":
			z.ByDepID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ByDepID")
				return
			}
		case "ByHost":
			z.ByHost, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
		case "ByDisk":
			z.ByDisk, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MetricsOptions) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 13
	// write "Type"
	err = en.Append(0x8d, 0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(uint32(z.Type))
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "Flags"
	err = en.Append(0xa5, 0x46, 0x6c, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint64(uint64(z.Flags))
	if err != nil {
		err = msgp.WrapError(err, "Flags")
		return
	}
	// write "N"
	err = en.Append(0xa1, 0x4e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.N)
	if err != nil {
		err = msgp.WrapError(err, "N")
		return
	}
	// write "Interval"
	err = en.Append(0xa8, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteDuration(z.Interval)
	if err != nil {
		err = msgp.WrapError(err, "Interval")
		return
	}
	// write "PoolIdx"
	err = en.Append(0xa7, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x78)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PoolIdx)))
	if err != nil {
		err = msgp.WrapError(err, "PoolIdx")
		return
	}
	for za0001 := range z.PoolIdx {
		err = en.WriteInt(z.PoolIdx[za0001])
		if err != nil {
			err = msgp.WrapError(err, "PoolIdx", za0001)
			return
		}
	}
	// write "Hosts"
	err = en.Append(0xa5, 0x48, 0x6f, 0x73, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Hosts)))
	if err != nil {
		err = msgp.WrapError(err, "Hosts")
		return
	}
	for za0002 := range z.Hosts {
		err = en.WriteString(z.Hosts[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Hosts", za0002)
			return
		}
	}
	// write "DrivePoolIdx"
	err = en.Append(0xac, 0x44, 0x72, 0x69, 0x76, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x78)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DrivePoolIdx)))
	if err != nil {
		err = msgp.WrapError(err, "DrivePoolIdx")
		return
	}
	for za0003 := range z.DrivePoolIdx {
		err = en.WriteInt(z.DrivePoolIdx[za0003])
		if err != nil {
			err = msgp.WrapError(err, "DrivePoolIdx", za0003)
			return
		}
	}
	// write "DriveSetIdx"
	err = en.Append(0xab, 0x44, 0x72, 0x69, 0x76, 0x65, 0x53, 0x65, 0x74, 0x49, 0x64, 0x78)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DriveSetIdx)))
	if err != nil {
		err = msgp.WrapError(err, "DriveSetIdx")
		return
	}
	for za0004 := range z.DriveSetIdx {
		err = en.WriteInt(z.DriveSetIdx[za0004])
		if err != nil {
			err = msgp.WrapError(err, "DriveSetIdx", za0004)
			return
		}
	}
	// write "Disks"
	err = en.Append(0xa5, 0x44, 0x69, 0x73, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Disks)))
	if err != nil {
		err = msgp.WrapError(err, "Disks")
		return
	}
	for za0005 := range z.Disks {
		err = en.WriteString(z.Disks[za0005])
		if err != nil {
			err = msgp.WrapError(err, "Disks", za0005)
			return
		}
	}
	// write "ByJobID"
	err = en.Append(0xa7, 0x42, 0x79, 0x4a, 0x6f, 0x62, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ByJobID)
	if err != nil {
		err = msgp.WrapError(err, "ByJobID")
		return
	}
	// write "ByDepID"
	err = en.Append(0xa7, 0x42, 0x79, 0x44, 0x65, 0x70, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ByDepID)
	if err != nil {
		err = msgp.WrapError(err, "ByDepID")
		return
	}
	// write "ByHost"
	err = en.Append(0xa6, 0x42, 0x79, 0x48, 0x6f, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ByHost)
	if err != nil {
		err = msgp.WrapError(err, "ByHost")
		return
	}
	// write "ByDisk"
	err = en.Append(0xa6, 0x42, 0x79, 0x44, 0x69, 0x73, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ByDisk)
	if err != nil {
		err = msgp.WrapError(err, "ByDisk")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MetricsOptions) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 13
	// string "Type"
	o = append(o, 0x8d, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendUint32(o, uint32(z.Type))
	// string "Flags"
	o = append(o, 0xa5, 0x46, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendUint64(o, uint64(z.Flags))
	// string "N"
	o = append(o, 0xa1, 0x4e)
	o = msgp.AppendInt(o, z.N)
	// string "Interval"
	o = append(o, 0xa8, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	o = msgp.AppendDuration(o, z.Interval)
	// string "PoolIdx"
	o = append(o, 0xa7, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PoolIdx)))
	for za0001 := range z.PoolIdx {
		o = msgp.AppendInt(o, z.PoolIdx[za0001])
	}
	// string "Hosts"
	o = append(o, 0xa5, 0x48, 0x6f, 0x73, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Hosts)))
	for za0002 := range z.Hosts {
		o = msgp.AppendString(o, z.Hosts[za0002])
	}
	// string "DrivePoolIdx"
	o = append(o, 0xac, 0x44, 0x72, 0x69, 0x76, 0x65, 0x50, 0x6f, 0x6f, 0x6c, 0x49, 0x64, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DrivePoolIdx)))
	for za0003 := range z.DrivePoolIdx {
		o = msgp.AppendInt(o, z.DrivePoolIdx[za0003])
	}
	// string "DriveSetIdx"
	o = append(o, 0xab, 0x44, 0x72, 0x69, 0x76, 0x65, 0x53, 0x65, 0x74, 0x49, 0x64, 0x78)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DriveSetIdx)))
	for za0004 := range z.DriveSetIdx {
		o = msgp.AppendInt(o, z.DriveSetIdx[za0004])
	}
	// string "Disks"
	o = append(o, 0xa5, 0x44, 0x69, 0x73, 0x6b, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Disks)))
	for za0005 := range z.Disks {
		o = msgp.AppendString(o, z.Disks[za0005])
	}
	// string "ByJobID"
	o = append(o, 0xa7, 0x42, 0x79, 0x4a, 0x6f, 0x62, 0x49, 0x44)
	o = msgp.AppendString(o, z.ByJobID)
	// string "ByDepID"
	o = append(o, 0xa7, 0x42, 0x79, 0x44, 0x65, 0x70, 0x49, 0x44)
	o = msgp.AppendString(o, z.ByDepID)
	// string "ByHost"
	o = append(o, 0xa6, 0x42, 0x79, 0x48, 0x6f, 0x73, 0x74)
	o = msgp.AppendBool(o, z.ByHost)
	// string "ByDisk"
	o = append(o, 0xa6, 0x42, 0x79, 0x44, 0x69, 0x73, 0x6b)
	o = msgp.AppendBool(o, z.ByDisk)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MetricsOptions) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Type":
			{
				var zb0002 uint32
				zb0002, bts, err = msgp.ReadUint32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Type")
					return
				}
				z.Type = MetricType(zb0002)
			}
		case "Flags":
			{
				var zb0003 uint64
				zb0003, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Flags")
					return
				}
				z.Flags = MetricFlags(zb0003)
			}
		case "N":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		case "Interval":
			z.Interval, bts, err = msgp.ReadDurationBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Interval")
				return
			}
		case "PoolIdx":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PoolIdx")
				return
			}
			if cap(z.PoolIdx) >= int(zb0004) {
				z.PoolIdx = (z.PoolIdx)[:zb0004]
			} else {
				z.PoolIdx = make([]int, zb0004)
			}
			for za0001 := range z.PoolIdx {
				z.PoolIdx[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PoolIdx", za0001)
					return
				}
			}
		case "Hosts":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0005) {
				z.Hosts = (z.Hosts)[:zb0005]
			} else {
				z.Hosts = make([]string, zb0005)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "DrivePoolIdx":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DrivePoolIdx")
				return
			}
			if cap(z.DrivePoolIdx) >= int(zb0006) {
				z.DrivePoolIdx = (z.DrivePoolIdx)[:zb0006]
			} else {
				z.DrivePoolIdx = make([]int, zb0006)
			}
			for za0003 := range z.DrivePoolIdx {
				z.DrivePoolIdx[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DrivePoolIdx", za0003)
					return
				}
			}
		case "DriveSetIdx":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DriveSetIdx")
				return
			}
			if cap(z.DriveSetIdx) >= int(zb0007) {
				z.DriveSetIdx = (z.DriveSetIdx)[:zb0007]
			} else {
				z.DriveSetIdx = make([]int, zb0007)
			}
			for za0004 := range z.DriveSetIdx {
				z.DriveSetIdx[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DriveSetIdx", za0004)
					return
				}
			}
		case "Disks":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disks")
				return
			}
			if cap(z.Disks) >= int(zb0008) {
				z.Disks = (z.Disks)[:zb0008]
			} else {
				z.Disks = make([]string, zb0008)
			}
			for za0005 := range z.Disks {
				z.Disks[za0005], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Disks", za0005)
					return
				}
			}
		case "ByJobID":
			z.ByJobID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByJobID")
				return
			}
		case "ByDepID":
			z.ByDepID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDepID")
				return
			}
		case "ByHost":
			z.ByHost, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
		case "ByDisk":
			z.ByDisk, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MetricsOptions) Msgsize() (s int) {
	s = 1 + 5 + msgp.Uint32Size + 6 + msgp.Uint64Size + 2 + msgp.IntSize + 9 + msgp.DurationSize + 8 + msgp.ArrayHeaderSize + (len(z.PoolIdx) * (msgp.IntSize)) + 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Hosts {
		s += msgp.StringPrefixSize + len(z.Hosts[za0002])
	}
	s += 13 + msgp.ArrayHeaderSize + (len(z.DrivePoolIdx) * (msgp.IntSize)) + 12 + msgp.ArrayHeaderSize + (len(z.DriveSetIdx) * (msgp.IntSize)) + 6 + msgp.ArrayHeaderSize
	for za0005 := range z.Disks {
		s += msgp.StringPrefixSize + len(z.Disks[za0005])
	}
	s += 8 + msgp.StringPrefixSize + len(z.ByJobID) + 8 + msgp.StringPrefixSize + len(z.ByDepID) + 7 + msgp.BoolSize + 7 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *NetMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "Interfaces":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Interfaces")
				return
			}
			if z.Interfaces == nil {
				z.Interfaces = make(map[string]InterfaceStats, zb0002)
			} else if len(z.Interfaces) > 0 {
				clear(z.Interfaces)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Interfaces")
					return
				}
				var za0002 InterfaceStats
				var zb0003 uint32
				zb0003, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Interfaces", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, err = dc.ReadMapKeyPtr()
					if err != nil {
						err = msgp.WrapError(err, "Interfaces", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "n":
						za0002.N, err = dc.ReadInt()
						if err != nil {
							err = msgp.WrapError(err, "Interfaces", za0001, "N")
							return
						}
					case "stats":
						err = (*procfsNetDevLine)(&za0002.NetDevLine).DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "Interfaces", za0001, "NetDevLine")
							return
						}
					default:
						err = dc.Skip()
						if err != nil {
							err = msgp.WrapError(err, "Interfaces", za0001)
							return
						}
					}
				}
				z.Interfaces[za0001] = za0002
			}
		case "interfaceName":
			z.InterfaceName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InterfaceName")
				return
			}
		case "netstats":
			err = (*procfsNetDevLine)(&z.NetStats).DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "NetStats")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *NetMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "collected"
	err = en.Append(0x84, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteTime(z.CollectedAt)
	if err != nil {
		err = msgp.WrapError(err, "CollectedAt")
		return
	}
	// write "Interfaces"
	err = en.Append(0xaa, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Interfaces)))
	if err != nil {
		err = msgp.WrapError(err, "Interfaces")
		return
	}
	for za0001, za0002 := range z.Interfaces {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Interfaces")
			return
		}
		// map header, size 2
		// write "n"
		err = en.Append(0x82, 0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteInt(za0002.N)
		if err != nil {
			err = msgp.WrapError(err, "Interfaces", za0001, "N")
			return
		}
		// write "stats"
		err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x74, 0x73)
		if err != nil {
			return
		}
		err = (*procfsNetDevLine)(&za0002.NetDevLine).EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Interfaces", za0001, "NetDevLine")
			return
		}
	}
	// write "interfaceName"
	err = en.Append(0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.InterfaceName)
	if err != nil {
		err = msgp.WrapError(err, "InterfaceName")
		return
	}
	// write "netstats"
	err = en.Append(0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = (*procfsNetDevLine)(&z.NetStats).EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "NetStats")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *NetMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "collected"
	o = append(o, 0x84, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
	o = msgp.AppendTime(o, z.CollectedAt)
	// string "Interfaces"
	o = append(o, 0xaa, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Interfaces)))
	for za0001, za0002 := range z.Interfaces {
		o = msgp.AppendString(o, za0001)
		// map header, size 2
		// string "n"
		o = append(o, 0x82, 0xa1, 0x6e)
		o = msgp.AppendInt(o, za0002.N)
		// string "stats"
		o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x74, 0x73)
		o, err = (*procfsNetDevLine)(&za0002.NetDevLine).MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Interfaces", za0001, "NetDevLine")
			return
		}
	}
	// string "interfaceName"
	o = append(o, 0xad, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.InterfaceName)
	// string "netstats"
	o = append(o, 0xa8, 0x6e, 0x65, 0x74, 0x73, 0x74, 0x61, 0x74, 0x73)
	o, err = (*procfsNetDevLine)(&z.NetStats).MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "NetStats")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *NetMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "Interfaces":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Interfaces")
				return
			}
			if z.Interfaces == nil {
				z.Interfaces = make(map[string]InterfaceStats, zb0002)
			} else if len(z.Interfaces) > 0 {
				clear(z.Interfaces)
			}
			for zb0002 > 0 {
				var za0002 InterfaceStats
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Interfaces")
					return
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Interfaces", za0001)
					return
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "Interfaces", za0001)
						return
					}
					switch msgp.UnsafeString(field) {
					case "n":
						za0002.N, bts, err = msgp.ReadIntBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interfaces", za0001, "N")
							return
						}
					case "stats":
						bts, err = (*procfsNetDevLine)(&za0002.NetDevLine).UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interfaces", za0001, "NetDevLine")
							return
						}
					default:
						bts, err = msgp.Skip(bts)
						if err != nil {
							err = msgp.WrapError(err, "Interfaces", za0001)
							return
						}
					}
				}
				z.Interfaces[za0001] = za0002
			}
		case "interfaceName":
			z.InterfaceName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InterfaceName")
				return
			}
		case "netstats":
			bts, err = (*procfsNetDevLine)(&z.NetStats).UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "NetStats")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *NetMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 11 + msgp.MapHeaderSize
	if z.Interfaces != nil {
		for za0001, za0002 := range z.Interfaces {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + 1 + 2 + msgp.IntSize + 6 + (*procfsNetDevLine)(&za0002.NetDevLine).Msgsize()
		}
	}
	s += 14 + msgp.StringPrefixSize + len(z.InterfaceName) + 9 + (*procfsNetDevLine)(&z.NetStats).Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *OSMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "life_time_ops":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				clear(z.LifeTimeOps)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				var za0002 uint64
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "last_minute":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						clear(z.LastMinute.Operations)
					}
					for zb0004 > 0 {
						zb0004--
						var za0003 string
						za0003, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						var za0004 TimedAction
						err = za0004.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		case "sensors":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Sensors")
				return
			}
			if z.Sensors == nil {
				z.Sensors = make(map[string]SensorMetrics, zb0005)
			} else if len(z.Sensors) > 0 {
				clear(z.Sensors)
			}
			for zb0005 > 0 {
				zb0005--
				var za0005 string
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Sensors")
					return
				}
				var za0006 SensorMetrics
				err = za0006.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Sensors", za0005)
					return
				}
				z.Sensors[za0005] = za0006
			}
			zb0001Mask |= 0x2
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Sensors = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *OSMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Sensors == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "life_time_ops"
			err = en.Append(0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			for za0001, za0002 := range z.LifeTimeOps {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				err = en.WriteUint64(za0002)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
			}
		}
		// write "last_minute"
		err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// write "operations"
			err = en.Append(0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinute.Operations)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinute", "Operations")
				return
			}
			for za0003, za0004 := range z.LastMinute.Operations {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "sensors"
			err = en.Append(0xa7, 0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.Sensors)))
			if err != nil {
				err = msgp.WrapError(err, "Sensors")
				return
			}
			for za0005, za0006 := range z.Sensors {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "Sensors")
					return
				}
				err = za0006.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "Sensors", za0005)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *OSMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Sensors == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "life_time_ops"
			o = append(o, 0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeOps)))
			for za0001, za0002 := range z.LifeTimeOps {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendUint64(o, za0002)
			}
		}
		// string "last_minute"
		o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		// check for omitted fields
		zb0002Len := uint32(1)
		var zb0002Mask uint8 /* 1 bits */
		_ = zb0002Mask
		if z.LastMinute.Operations == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))
		if (zb0002Mask & 0x1) == 0 { // if not omitted
			// string "operations"
			o = append(o, 0xaa, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.Operations)))
			for za0003, za0004 := range z.LastMinute.Operations {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "sensors"
			o = append(o, 0xa7, 0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.Sensors)))
			for za0005, za0006 := range z.Sensors {
				o = msgp.AppendString(o, za0005)
				o, err = za0006.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "Sensors", za0005)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *OSMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "life_time_ops":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0002)
			} else if len(z.LifeTimeOps) > 0 {
				clear(z.LifeTimeOps)
			}
			for zb0002 > 0 {
				var za0002 uint64
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0001)
					return
				}
				z.LifeTimeOps[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "last_minute":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0003Mask uint8 /* 1 bits */
			_ = zb0003Mask
			for zb0003 > 0 {
				zb0003--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "operations":
					var zb0004 uint32
					zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Operations")
						return
					}
					if z.LastMinute.Operations == nil {
						z.LastMinute.Operations = make(map[string]TimedAction, zb0004)
					} else if len(z.LastMinute.Operations) > 0 {
						clear(z.LastMinute.Operations)
					}
					for zb0004 > 0 {
						var za0004 TimedAction
						zb0004--
						var za0003 string
						za0003, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations")
							return
						}
						bts, err = za0004.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Operations", za0003)
							return
						}
						z.LastMinute.Operations[za0003] = za0004
					}
					zb0003Mask |= 0x1
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if (zb0003Mask & 0x1) == 0 {
				z.LastMinute.Operations = nil
			}

		case "sensors":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sensors")
				return
			}
			if z.Sensors == nil {
				z.Sensors = make(map[string]SensorMetrics, zb0005)
			} else if len(z.Sensors) > 0 {
				clear(z.Sensors)
			}
			for zb0005 > 0 {
				var za0006 SensorMetrics
				zb0005--
				var za0005 string
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sensors")
					return
				}
				bts, err = za0006.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Sensors", za0005)
					return
				}
				z.Sensors[za0005] = za0006
			}
			zb0001Mask |= 0x2
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Sensors = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *OSMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 14 + msgp.MapHeaderSize
	if z.LifeTimeOps != nil {
		for za0001, za0002 := range z.LifeTimeOps {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 12 + 1 + 11 + msgp.MapHeaderSize
	if z.LastMinute.Operations != nil {
		for za0003, za0004 := range z.LastMinute.Operations {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.Sensors != nil {
		for za0005, za0006 := range z.Sensors {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + za0006.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessCPUTimes) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "user":
			z.User, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
			zb0001Mask |= 0x1
		case "system":
			z.System, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "System")
				return
			}
			zb0001Mask |= 0x2
		case "idle":
			z.Idle, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Idle")
				return
			}
			zb0001Mask |= 0x4
		case "nice":
			z.Nice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Nice")
				return
			}
			zb0001Mask |= 0x8
		case "iowait":
			z.Iowait, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Iowait")
				return
			}
			zb0001Mask |= 0x10
		case "irq":
			z.Irq, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Irq")
				return
			}
			zb0001Mask |= 0x20
		case "softirq":
			z.Softirq, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Softirq")
				return
			}
			zb0001Mask |= 0x40
		case "steal":
			z.Steal, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Steal")
				return
			}
			zb0001Mask |= 0x80
		case "guest":
			z.Guest, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Guest")
				return
			}
			zb0001Mask |= 0x100
		case "guest_nice":
			z.GuestNice, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "GuestNice")
				return
			}
			zb0001Mask |= 0x200
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x400
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7ff {
		if (zb0001Mask & 0x1) == 0 {
			z.User = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.System = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Idle = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Nice = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Iowait = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Irq = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Softirq = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Steal = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Guest = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.GuestNice = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.Count = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessCPUTimes) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.User == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.System == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Idle == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Nice == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Iowait == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Irq == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Softirq == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Steal == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Guest == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.GuestNice == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "user"
			err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.User)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "system"
			err = en.Append(0xa6, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.System)
			if err != nil {
				err = msgp.WrapError(err, "System")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "idle"
			err = en.Append(0xa4, 0x69, 0x64, 0x6c, 0x65)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.Idle)
			if err != nil {
				err = msgp.WrapError(err, "Idle")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "nice"
			err = en.Append(0xa4, 0x6e, 0x69, 0x63, 0x65)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.Nice)
			if err != nil {
				err = msgp.WrapError(err, "Nice")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "iowait"
			err = en.Append(0xa6, 0x69, 0x6f, 0x77, 0x61, 0x69, 0x74)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.Iowait)
			if err != nil {
				err = msgp.WrapError(err, "Iowait")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "irq"
			err = en.Append(0xa3, 0x69, 0x72, 0x71)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.Irq)
			if err != nil {
				err = msgp.WrapError(err, "Irq")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "softirq"
			err = en.Append(0xa7, 0x73, 0x6f, 0x66, 0x74, 0x69, 0x72, 0x71)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.Softirq)
			if err != nil {
				err = msgp.WrapError(err, "Softirq")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "steal"
			err = en.Append(0xa5, 0x73, 0x74, 0x65, 0x61, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.Steal)
			if err != nil {
				err = msgp.WrapError(err, "Steal")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "guest"
			err = en.Append(0xa5, 0x67, 0x75, 0x65, 0x73, 0x74)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.Guest)
			if err != nil {
				err = msgp.WrapError(err, "Guest")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "guest_nice"
			err = en.Append(0xaa, 0x67, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x6e, 0x69, 0x63, 0x65)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.GuestNice)
			if err != nil {
				err = msgp.WrapError(err, "GuestNice")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "count"
			err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Count)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessCPUTimes) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.User == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.System == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Idle == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Nice == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Iowait == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Irq == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Softirq == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Steal == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Guest == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.GuestNice == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "user"
			o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
			o = msgp.AppendFloat64(o, z.User)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "system"
			o = append(o, 0xa6, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
			o = msgp.AppendFloat64(o, z.System)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "idle"
			o = append(o, 0xa4, 0x69, 0x64, 0x6c, 0x65)
			o = msgp.AppendFloat64(o, z.Idle)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "nice"
			o = append(o, 0xa4, 0x6e, 0x69, 0x63, 0x65)
			o = msgp.AppendFloat64(o, z.Nice)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "iowait"
			o = append(o, 0xa6, 0x69, 0x6f, 0x77, 0x61, 0x69, 0x74)
			o = msgp.AppendFloat64(o, z.Iowait)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "irq"
			o = append(o, 0xa3, 0x69, 0x72, 0x71)
			o = msgp.AppendFloat64(o, z.Irq)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "softirq"
			o = append(o, 0xa7, 0x73, 0x6f, 0x66, 0x74, 0x69, 0x72, 0x71)
			o = msgp.AppendFloat64(o, z.Softirq)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "steal"
			o = append(o, 0xa5, 0x73, 0x74, 0x65, 0x61, 0x6c)
			o = msgp.AppendFloat64(o, z.Steal)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "guest"
			o = append(o, 0xa5, 0x67, 0x75, 0x65, 0x73, 0x74)
			o = msgp.AppendFloat64(o, z.Guest)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "guest_nice"
			o = append(o, 0xaa, 0x67, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x6e, 0x69, 0x63, 0x65)
			o = msgp.AppendFloat64(o, z.GuestNice)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "count"
			o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.Count)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessCPUTimes) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "user":
			z.User, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
			zb0001Mask |= 0x1
		case "system":
			z.System, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "System")
				return
			}
			zb0001Mask |= 0x2
		case "idle":
			z.Idle, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Idle")
				return
			}
			zb0001Mask |= 0x4
		case "nice":
			z.Nice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nice")
				return
			}
			zb0001Mask |= 0x8
		case "iowait":
			z.Iowait, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Iowait")
				return
			}
			zb0001Mask |= 0x10
		case "irq":
			z.Irq, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Irq")
				return
			}
			zb0001Mask |= 0x20
		case "softirq":
			z.Softirq, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Softirq")
				return
			}
			zb0001Mask |= 0x40
		case "steal":
			z.Steal, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Steal")
				return
			}
			zb0001Mask |= 0x80
		case "guest":
			z.Guest, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Guest")
				return
			}
			zb0001Mask |= 0x100
		case "guest_nice":
			z.GuestNice, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GuestNice")
				return
			}
			zb0001Mask |= 0x200
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x400
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7ff {
		if (zb0001Mask & 0x1) == 0 {
			z.User = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.System = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Idle = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Nice = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Iowait = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Irq = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Softirq = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Steal = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Guest = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.GuestNice = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.Count = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessCPUTimes) Msgsize() (s int) {
	s = 1 + 5 + msgp.Float64Size + 7 + msgp.Float64Size + 5 + msgp.Float64Size + 5 + msgp.Float64Size + 7 + msgp.Float64Size + 4 + msgp.Float64Size + 8 + msgp.Float64Size + 6 + msgp.Float64Size + 6 + msgp.Float64Size + 11 + msgp.Float64Size + 6 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessCtxSwitches) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "voluntary":
			z.Voluntary, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Voluntary")
				return
			}
			zb0001Mask |= 0x1
		case "involuntary":
			z.Involuntary, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Involuntary")
				return
			}
			zb0001Mask |= 0x2
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x4
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.Voluntary = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Involuntary = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Count = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ProcessCtxSwitches) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	if z.Voluntary == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Involuntary == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "voluntary"
			err = en.Append(0xa9, 0x76, 0x6f, 0x6c, 0x75, 0x6e, 0x74, 0x61, 0x72, 0x79)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Voluntary)
			if err != nil {
				err = msgp.WrapError(err, "Voluntary")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "involuntary"
			err = en.Append(0xab, 0x69, 0x6e, 0x76, 0x6f, 0x6c, 0x75, 0x6e, 0x74, 0x61, 0x72, 0x79)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Involuntary)
			if err != nil {
				err = msgp.WrapError(err, "Involuntary")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "count"
			err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Count)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ProcessCtxSwitches) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(3)
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	if z.Voluntary == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Involuntary == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "voluntary"
			o = append(o, 0xa9, 0x76, 0x6f, 0x6c, 0x75, 0x6e, 0x74, 0x61, 0x72, 0x79)
			o = msgp.AppendInt64(o, z.Voluntary)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "involuntary"
			o = append(o, 0xab, 0x69, 0x6e, 0x76, 0x6f, 0x6c, 0x75, 0x6e, 0x74, 0x61, 0x72, 0x79)
			o = msgp.AppendInt64(o, z.Involuntary)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "count"
			o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.Count)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessCtxSwitches) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "voluntary":
			z.Voluntary, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Voluntary")
				return
			}
			zb0001Mask |= 0x1
		case "involuntary":
			z.Involuntary, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Involuntary")
				return
			}
			zb0001Mask |= 0x2
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x4
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.Voluntary = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Involuntary = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Count = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ProcessCtxSwitches) Msgsize() (s int) {
	s = 1 + 10 + msgp.Int64Size + 12 + msgp.Int64Size + 6 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessIOCounters) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "read_count":
			z.ReadCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadCount")
				return
			}
			zb0001Mask |= 0x1
		case "write_count":
			z.WriteCount, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteCount")
				return
			}
			zb0001Mask |= 0x2
		case "read_bytes":
			z.ReadBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ReadBytes")
				return
			}
			zb0001Mask |= 0x4
		case "write_bytes":
			z.WriteBytes, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "WriteBytes")
				return
			}
			zb0001Mask |= 0x8
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x10
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.ReadCount = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.WriteCount = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReadBytes = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.WriteBytes = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Count = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessIOCounters) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.ReadCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.WriteCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReadBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.WriteBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "read_count"
			err = en.Append(0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadCount)
			if err != nil {
				err = msgp.WrapError(err, "ReadCount")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "write_count"
			err = en.Append(0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteCount)
			if err != nil {
				err = msgp.WrapError(err, "WriteCount")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "read_bytes"
			err = en.Append(0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ReadBytes)
			if err != nil {
				err = msgp.WrapError(err, "ReadBytes")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "write_bytes"
			err = en.Append(0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.WriteBytes)
			if err != nil {
				err = msgp.WrapError(err, "WriteBytes")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "count"
			err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Count)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessIOCounters) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.ReadCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.WriteCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ReadBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.WriteBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "read_count"
			o = append(o, 0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendUint64(o, z.ReadCount)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "write_count"
			o = append(o, 0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendUint64(o, z.WriteCount)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "read_bytes"
			o = append(o, 0xaa, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.ReadBytes)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "write_bytes"
			o = append(o, 0xab, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendUint64(o, z.WriteBytes)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "count"
			o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.Count)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessIOCounters) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "read_count":
			z.ReadCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadCount")
				return
			}
			zb0001Mask |= 0x1
		case "write_count":
			z.WriteCount, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteCount")
				return
			}
			zb0001Mask |= 0x2
		case "read_bytes":
			z.ReadBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReadBytes")
				return
			}
			zb0001Mask |= 0x4
		case "write_bytes":
			z.WriteBytes, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WriteBytes")
				return
			}
			zb0001Mask |= 0x8
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x10
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.ReadCount = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.WriteCount = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ReadBytes = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.WriteBytes = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Count = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessIOCounters) Msgsize() (s int) {
	s = 1 + 11 + msgp.Uint64Size + 12 + msgp.Uint64Size + 11 + msgp.Uint64Size + 12 + msgp.Uint64Size + 6 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessMemoryInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rss":
			z.RSS, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "RSS")
				return
			}
			zb0001Mask |= 0x1
		case "vms":
			z.VMS, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "VMS")
				return
			}
			zb0001Mask |= 0x2
		case "hwm":
			z.HWM, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "HWM")
				return
			}
			zb0001Mask |= 0x4
		case "data":
			z.Data, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			zb0001Mask |= 0x8
		case "stack":
			z.Stack, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Stack")
				return
			}
			zb0001Mask |= 0x10
		case "locked":
			z.Locked, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Locked")
				return
			}
			zb0001Mask |= 0x20
		case "swap":
			z.Swap, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Swap")
				return
			}
			zb0001Mask |= 0x40
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x80
		case "shared":
			z.Shared, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
			zb0001Mask |= 0x100
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ff {
		if (zb0001Mask & 0x1) == 0 {
			z.RSS = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.VMS = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.HWM = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Data = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Stack = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Locked = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Swap = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Count = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Shared = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessMemoryInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.RSS == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.VMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.HWM == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Data == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Stack == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Locked == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Swap == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Shared == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "rss"
			err = en.Append(0xa3, 0x72, 0x73, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.RSS)
			if err != nil {
				err = msgp.WrapError(err, "RSS")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "vms"
			err = en.Append(0xa3, 0x76, 0x6d, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.VMS)
			if err != nil {
				err = msgp.WrapError(err, "VMS")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "hwm"
			err = en.Append(0xa3, 0x68, 0x77, 0x6d)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.HWM)
			if err != nil {
				err = msgp.WrapError(err, "HWM")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "data"
			err = en.Append(0xa4, 0x64, 0x61, 0x74, 0x61)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Data)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "stack"
			err = en.Append(0xa5, 0x73, 0x74, 0x61, 0x63, 0x6b)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Stack)
			if err != nil {
				err = msgp.WrapError(err, "Stack")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "locked"
			err = en.Append(0xa6, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Locked)
			if err != nil {
				err = msgp.WrapError(err, "Locked")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "swap"
			err = en.Append(0xa4, 0x73, 0x77, 0x61, 0x70)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Swap)
			if err != nil {
				err = msgp.WrapError(err, "Swap")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "count"
			err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Count)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "shared"
			err = en.Append(0xa6, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.Shared)
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessMemoryInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(9)
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	if z.RSS == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.VMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.HWM == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Data == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Stack == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Locked == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.Swap == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Shared == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "rss"
			o = append(o, 0xa3, 0x72, 0x73, 0x73)
			o = msgp.AppendUint64(o, z.RSS)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "vms"
			o = append(o, 0xa3, 0x76, 0x6d, 0x73)
			o = msgp.AppendUint64(o, z.VMS)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "hwm"
			o = append(o, 0xa3, 0x68, 0x77, 0x6d)
			o = msgp.AppendUint64(o, z.HWM)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "data"
			o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
			o = msgp.AppendUint64(o, z.Data)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "stack"
			o = append(o, 0xa5, 0x73, 0x74, 0x61, 0x63, 0x6b)
			o = msgp.AppendUint64(o, z.Stack)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "locked"
			o = append(o, 0xa6, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.Locked)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "swap"
			o = append(o, 0xa4, 0x73, 0x77, 0x61, 0x70)
			o = msgp.AppendUint64(o, z.Swap)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "count"
			o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.Count)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "shared"
			o = append(o, 0xa6, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.Shared)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessMemoryInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 9 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "rss":
			z.RSS, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RSS")
				return
			}
			zb0001Mask |= 0x1
		case "vms":
			z.VMS, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VMS")
				return
			}
			zb0001Mask |= 0x2
		case "hwm":
			z.HWM, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HWM")
				return
			}
			zb0001Mask |= 0x4
		case "data":
			z.Data, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			zb0001Mask |= 0x8
		case "stack":
			z.Stack, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stack")
				return
			}
			zb0001Mask |= 0x10
		case "locked":
			z.Locked, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Locked")
				return
			}
			zb0001Mask |= 0x20
		case "swap":
			z.Swap, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Swap")
				return
			}
			zb0001Mask |= 0x40
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x80
		case "shared":
			z.Shared, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Shared")
				return
			}
			zb0001Mask |= 0x100
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ff {
		if (zb0001Mask & 0x1) == 0 {
			z.RSS = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.VMS = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.HWM = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Data = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Stack = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Locked = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.Swap = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.Count = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Shared = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessMemoryInfo) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 4 + msgp.Uint64Size + 5 + msgp.Uint64Size + 6 + msgp.Uint64Size + 7 + msgp.Uint64Size + 5 + msgp.Uint64Size + 6 + msgp.IntSize + 7 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessMemoryMaps) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "total_size":
			z.TotalSize, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalSize")
				return
			}
			zb0001Mask |= 0x1
		case "total_rss":
			z.TotalRSS, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalRSS")
				return
			}
			zb0001Mask |= 0x2
		case "total_pss":
			z.TotalPSS, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalPSS")
				return
			}
			zb0001Mask |= 0x4
		case "total_shared_clean":
			z.TotalSharedClean, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalSharedClean")
				return
			}
			zb0001Mask |= 0x8
		case "total_shared_dirty":
			z.TotalSharedDirty, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalSharedDirty")
				return
			}
			zb0001Mask |= 0x10
		case "total_private_clean":
			z.TotalPrivateClean, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalPrivateClean")
				return
			}
			zb0001Mask |= 0x20
		case "total_private_dirty":
			z.TotalPrivateDirty, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalPrivateDirty")
				return
			}
			zb0001Mask |= 0x40
		case "total_referenced":
			z.TotalReferenced, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalReferenced")
				return
			}
			zb0001Mask |= 0x80
		case "total_anonymous":
			z.TotalAnonymous, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalAnonymous")
				return
			}
			zb0001Mask |= 0x100
		case "total_swap":
			z.TotalSwap, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TotalSwap")
				return
			}
			zb0001Mask |= 0x200
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x400
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7ff {
		if (zb0001Mask & 0x1) == 0 {
			z.TotalSize = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.TotalRSS = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.TotalPSS = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.TotalSharedClean = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.TotalSharedDirty = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.TotalPrivateClean = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.TotalPrivateDirty = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.TotalReferenced = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.TotalAnonymous = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.TotalSwap = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.Count = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessMemoryMaps) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.TotalSize == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.TotalRSS == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.TotalPSS == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.TotalSharedClean == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TotalSharedDirty == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TotalPrivateClean == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TotalPrivateDirty == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.TotalReferenced == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.TotalAnonymous == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.TotalSwap == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "total_size"
			err = en.Append(0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalSize)
			if err != nil {
				err = msgp.WrapError(err, "TotalSize")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "total_rss"
			err = en.Append(0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x72, 0x73, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalRSS)
			if err != nil {
				err = msgp.WrapError(err, "TotalRSS")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "total_pss"
			err = en.Append(0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x73, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalPSS)
			if err != nil {
				err = msgp.WrapError(err, "TotalPSS")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "total_shared_clean"
			err = en.Append(0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64, 0x5f, 0x63, 0x6c, 0x65, 0x61, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalSharedClean)
			if err != nil {
				err = msgp.WrapError(err, "TotalSharedClean")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "total_shared_dirty"
			err = en.Append(0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64, 0x5f, 0x64, 0x69, 0x72, 0x74, 0x79)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalSharedDirty)
			if err != nil {
				err = msgp.WrapError(err, "TotalSharedDirty")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "total_private_clean"
			err = en.Append(0xb3, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x5f, 0x63, 0x6c, 0x65, 0x61, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalPrivateClean)
			if err != nil {
				err = msgp.WrapError(err, "TotalPrivateClean")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "total_private_dirty"
			err = en.Append(0xb3, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x5f, 0x64, 0x69, 0x72, 0x74, 0x79)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalPrivateDirty)
			if err != nil {
				err = msgp.WrapError(err, "TotalPrivateDirty")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "total_referenced"
			err = en.Append(0xb0, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalReferenced)
			if err != nil {
				err = msgp.WrapError(err, "TotalReferenced")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "total_anonymous"
			err = en.Append(0xaf, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x61, 0x6e, 0x6f, 0x6e, 0x79, 0x6d, 0x6f, 0x75, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalAnonymous)
			if err != nil {
				err = msgp.WrapError(err, "TotalAnonymous")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "total_swap"
			err = en.Append(0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x77, 0x61, 0x70)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.TotalSwap)
			if err != nil {
				err = msgp.WrapError(err, "TotalSwap")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "count"
			err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Count)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessMemoryMaps) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(11)
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	if z.TotalSize == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.TotalRSS == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.TotalPSS == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.TotalSharedClean == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TotalSharedDirty == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TotalPrivateClean == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TotalPrivateDirty == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.TotalReferenced == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.TotalAnonymous == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.TotalSwap == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "total_size"
			o = append(o, 0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x69, 0x7a, 0x65)
			o = msgp.AppendUint64(o, z.TotalSize)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "total_rss"
			o = append(o, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x72, 0x73, 0x73)
			o = msgp.AppendUint64(o, z.TotalRSS)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "total_pss"
			o = append(o, 0xa9, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x73, 0x73)
			o = msgp.AppendUint64(o, z.TotalPSS)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "total_shared_clean"
			o = append(o, 0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64, 0x5f, 0x63, 0x6c, 0x65, 0x61, 0x6e)
			o = msgp.AppendUint64(o, z.TotalSharedClean)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "total_shared_dirty"
			o = append(o, 0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64, 0x5f, 0x64, 0x69, 0x72, 0x74, 0x79)
			o = msgp.AppendUint64(o, z.TotalSharedDirty)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "total_private_clean"
			o = append(o, 0xb3, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x5f, 0x63, 0x6c, 0x65, 0x61, 0x6e)
			o = msgp.AppendUint64(o, z.TotalPrivateClean)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "total_private_dirty"
			o = append(o, 0xb3, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x5f, 0x64, 0x69, 0x72, 0x74, 0x79)
			o = msgp.AppendUint64(o, z.TotalPrivateDirty)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "total_referenced"
			o = append(o, 0xb0, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x64)
			o = msgp.AppendUint64(o, z.TotalReferenced)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "total_anonymous"
			o = append(o, 0xaf, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x61, 0x6e, 0x6f, 0x6e, 0x79, 0x6d, 0x6f, 0x75, 0x73)
			o = msgp.AppendUint64(o, z.TotalAnonymous)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "total_swap"
			o = append(o, 0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x77, 0x61, 0x70)
			o = msgp.AppendUint64(o, z.TotalSwap)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "count"
			o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.Count)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessMemoryMaps) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint16 /* 11 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "total_size":
			z.TotalSize, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSize")
				return
			}
			zb0001Mask |= 0x1
		case "total_rss":
			z.TotalRSS, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalRSS")
				return
			}
			zb0001Mask |= 0x2
		case "total_pss":
			z.TotalPSS, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalPSS")
				return
			}
			zb0001Mask |= 0x4
		case "total_shared_clean":
			z.TotalSharedClean, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSharedClean")
				return
			}
			zb0001Mask |= 0x8
		case "total_shared_dirty":
			z.TotalSharedDirty, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSharedDirty")
				return
			}
			zb0001Mask |= 0x10
		case "total_private_clean":
			z.TotalPrivateClean, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalPrivateClean")
				return
			}
			zb0001Mask |= 0x20
		case "total_private_dirty":
			z.TotalPrivateDirty, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalPrivateDirty")
				return
			}
			zb0001Mask |= 0x40
		case "total_referenced":
			z.TotalReferenced, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalReferenced")
				return
			}
			zb0001Mask |= 0x80
		case "total_anonymous":
			z.TotalAnonymous, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalAnonymous")
				return
			}
			zb0001Mask |= 0x100
		case "total_swap":
			z.TotalSwap, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalSwap")
				return
			}
			zb0001Mask |= 0x200
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x400
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7ff {
		if (zb0001Mask & 0x1) == 0 {
			z.TotalSize = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.TotalRSS = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.TotalPSS = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.TotalSharedClean = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.TotalSharedDirty = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.TotalPrivateClean = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.TotalPrivateDirty = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.TotalReferenced = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.TotalAnonymous = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.TotalSwap = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.Count = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessMemoryMaps) Msgsize() (s int) {
	s = 1 + 11 + msgp.Uint64Size + 10 + msgp.Uint64Size + 10 + msgp.Uint64Size + 19 + msgp.Uint64Size + 19 + msgp.Uint64Size + 20 + msgp.Uint64Size + 20 + msgp.Uint64Size + 17 + msgp.Uint64Size + 16 + msgp.Uint64Size + 11 + msgp.Uint64Size + 6 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected_at":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
			zb0001Mask |= 0x1
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x2
		case "total_cpu_percent":
			z.TotalCPUPercent, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TotalCPUPercent")
				return
			}
			zb0001Mask |= 0x4
		case "total_num_connections":
			z.TotalNumConnections, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TotalNumConnections")
				return
			}
			zb0001Mask |= 0x8
		case "total_running_secs":
			z.TotalRunningSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TotalRunningSecs")
				return
			}
			zb0001Mask |= 0x10
		case "total_num_fds":
			z.TotalNumFDs, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TotalNumFDs")
				return
			}
			zb0001Mask |= 0x20
		case "total_num_threads":
			z.TotalNumThreads, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TotalNumThreads")
				return
			}
			zb0001Mask |= 0x40
		case "total_nice":
			z.TotalNice, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "TotalNice")
				return
			}
			zb0001Mask |= 0x80
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x100
		case "background_processes":
			z.BackgroundProcesses, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BackgroundProcesses")
				return
			}
			zb0001Mask |= 0x200
		case "running_processes":
			z.RunningProcesses, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RunningProcesses")
				return
			}
			zb0001Mask |= 0x400
		case "mem_info":
			err = z.MemInfo.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "MemInfo")
				return
			}
			zb0001Mask |= 0x800
		case "io_counters":
			err = z.IOCounters.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "IOCounters")
				return
			}
			zb0001Mask |= 0x1000
		case "num_ctx_switches":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "NumCtxSwitches")
				return
			}
			var zb0002Mask uint8 /* 3 bits */
			_ = zb0002Mask
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "NumCtxSwitches")
					return
				}
				switch msgp.UnsafeString(field) {
				case "voluntary":
					z.NumCtxSwitches.Voluntary, err = dc.ReadInt64()
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Voluntary")
						return
					}
					zb0002Mask |= 0x1
				case "involuntary":
					z.NumCtxSwitches.Involuntary, err = dc.ReadInt64()
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Involuntary")
						return
					}
					zb0002Mask |= 0x2
				case "count":
					z.NumCtxSwitches.Count, err = dc.ReadInt()
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Count")
						return
					}
					zb0002Mask |= 0x4
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0002Mask != 0x7 {
				if (zb0002Mask & 0x1) == 0 {
					z.NumCtxSwitches.Voluntary = 0
				}
				if (zb0002Mask & 0x2) == 0 {
					z.NumCtxSwitches.Involuntary = 0
				}
				if (zb0002Mask & 0x4) == 0 {
					z.NumCtxSwitches.Count = 0
				}
			}
			zb0001Mask |= 0x2000
		case "page_faults":
			err = z.PageFaults.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "PageFaults")
				return
			}
			zb0001Mask |= 0x4000
		case "cpu_times":
			err = z.CPUTimes.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "CPUTimes")
				return
			}
			zb0001Mask |= 0x8000
		case "mem_maps":
			err = z.MemMaps.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "MemMaps")
				return
			}
			zb0001Mask |= 0x10000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.CollectedAt = (time.Time{})
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.TotalCPUPercent = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.TotalNumConnections = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.TotalRunningSecs = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.TotalNumFDs = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.TotalNumThreads = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.TotalNice = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Count = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.BackgroundProcesses = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.RunningProcesses = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.MemInfo = ProcessMemoryInfo{}
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.IOCounters = ProcessIOCounters{}
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.NumCtxSwitches = (ProcessCtxSwitches{})
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.PageFaults = ProcessPageFaults{}
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.CPUTimes = ProcessCPUTimes{}
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.MemMaps = ProcessMemoryMaps{}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.CollectedAt == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.TotalCPUPercent == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.TotalNumConnections == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TotalRunningSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TotalNumFDs == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TotalNumThreads == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.TotalNice == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.BackgroundProcesses == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RunningProcesses == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.NumCtxSwitches == (ProcessCtxSwitches{}) {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "collected_at"
			err = en.Append(0xac, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74)
			if err != nil {
				return
			}
			err = en.WriteTime(z.CollectedAt)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "nodes"
			err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Nodes)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "total_cpu_percent"
			err = en.Append(0xb1, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x70, 0x75, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.TotalCPUPercent)
			if err != nil {
				err = msgp.WrapError(err, "TotalCPUPercent")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "total_num_connections"
			err = en.Append(0xb5, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.TotalNumConnections)
			if err != nil {
				err = msgp.WrapError(err, "TotalNumConnections")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "total_running_secs"
			err = en.Append(0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.TotalRunningSecs)
			if err != nil {
				err = msgp.WrapError(err, "TotalRunningSecs")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "total_num_fds"
			err = en.Append(0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x5f, 0x66, 0x64, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.TotalNumFDs)
			if err != nil {
				err = msgp.WrapError(err, "TotalNumFDs")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "total_num_threads"
			err = en.Append(0xb1, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.TotalNumThreads)
			if err != nil {
				err = msgp.WrapError(err, "TotalNumThreads")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "total_nice"
			err = en.Append(0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x69, 0x63, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.TotalNice)
			if err != nil {
				err = msgp.WrapError(err, "TotalNice")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "count"
			err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Count)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "background_processes"
			err = en.Append(0xb4, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.BackgroundProcesses)
			if err != nil {
				err = msgp.WrapError(err, "BackgroundProcesses")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "running_processes"
			err = en.Append(0xb1, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.RunningProcesses)
			if err != nil {
				err = msgp.WrapError(err, "RunningProcesses")
				return
			}
		}
		// write "mem_info"
		err = en.Append(0xa8, 0x6d, 0x65, 0x6d, 0x5f, 0x69, 0x6e, 0x66, 0x6f)
		if err != nil {
			return
		}
		err = z.MemInfo.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "MemInfo")
			return
		}
		// write "io_counters"
		err = en.Append(0xab, 0x69, 0x6f, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73)
		if err != nil {
			return
		}
		err = z.IOCounters.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "IOCounters")
			return
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "num_ctx_switches"
			err = en.Append(0xb0, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x74, 0x78, 0x5f, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x65, 0x73)
			if err != nil {
				return
			}
			// check for omitted fields
			zb0002Len := uint32(3)
			var zb0002Mask uint8 /* 3 bits */
			_ = zb0002Mask
			if z.NumCtxSwitches.Voluntary == 0 {
				zb0002Len--
				zb0002Mask |= 0x1
			}
			if z.NumCtxSwitches.Involuntary == 0 {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if z.NumCtxSwitches.Count == 0 {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			err = en.Append(0x80 | uint8(zb0002Len))
			if err != nil {
				return
			}

			// skip if no fields are to be emitted
			if zb0002Len != 0 {
				if (zb0002Mask & 0x1) == 0 { // if not omitted
					// write "voluntary"
					err = en.Append(0xa9, 0x76, 0x6f, 0x6c, 0x75, 0x6e, 0x74, 0x61, 0x72, 0x79)
					if err != nil {
						return
					}
					err = en.WriteInt64(z.NumCtxSwitches.Voluntary)
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Voluntary")
						return
					}
				}
				if (zb0002Mask & 0x2) == 0 { // if not omitted
					// write "involuntary"
					err = en.Append(0xab, 0x69, 0x6e, 0x76, 0x6f, 0x6c, 0x75, 0x6e, 0x74, 0x61, 0x72, 0x79)
					if err != nil {
						return
					}
					err = en.WriteInt64(z.NumCtxSwitches.Involuntary)
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Involuntary")
						return
					}
				}
				if (zb0002Mask & 0x4) == 0 { // if not omitted
					// write "count"
					err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
					if err != nil {
						return
					}
					err = en.WriteInt(z.NumCtxSwitches.Count)
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Count")
						return
					}
				}
			}
		}
		// write "page_faults"
		err = en.Append(0xab, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
		if err != nil {
			return
		}
		err = z.PageFaults.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "PageFaults")
			return
		}
		// write "cpu_times"
		err = en.Append(0xa9, 0x63, 0x70, 0x75, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73)
		if err != nil {
			return
		}
		err = z.CPUTimes.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "CPUTimes")
			return
		}
		// write "mem_maps"
		err = en.Append(0xa8, 0x6d, 0x65, 0x6d, 0x5f, 0x6d, 0x61, 0x70, 0x73)
		if err != nil {
			return
		}
		err = z.MemMaps.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "MemMaps")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(17)
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	if z.CollectedAt == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.TotalCPUPercent == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.TotalNumConnections == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.TotalRunningSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TotalNumFDs == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TotalNumThreads == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.TotalNice == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.BackgroundProcesses == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.RunningProcesses == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.NumCtxSwitches == (ProcessCtxSwitches{}) {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "collected_at"
			o = append(o, 0xac, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74)
			o = msgp.AppendTime(o, z.CollectedAt)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "nodes"
			o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			o = msgp.AppendInt(o, z.Nodes)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "total_cpu_percent"
			o = append(o, 0xb1, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x70, 0x75, 0x5f, 0x70, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
			o = msgp.AppendFloat64(o, z.TotalCPUPercent)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "total_num_connections"
			o = append(o, 0xb5, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
			o = msgp.AppendInt(o, z.TotalNumConnections)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "total_running_secs"
			o = append(o, 0xb2, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.TotalRunningSecs)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "total_num_fds"
			o = append(o, 0xad, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x5f, 0x66, 0x64, 0x73)
			o = msgp.AppendInt64(o, z.TotalNumFDs)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "total_num_threads"
			o = append(o, 0xb1, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x75, 0x6d, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x73)
			o = msgp.AppendInt64(o, z.TotalNumThreads)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "total_nice"
			o = append(o, 0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6e, 0x69, 0x63, 0x65)
			o = msgp.AppendInt64(o, z.TotalNice)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "count"
			o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.Count)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "background_processes"
			o = append(o, 0xb4, 0x62, 0x61, 0x63, 0x6b, 0x67, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73)
			o = msgp.AppendInt(o, z.BackgroundProcesses)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "running_processes"
			o = append(o, 0xb1, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73)
			o = msgp.AppendInt(o, z.RunningProcesses)
		}
		// string "mem_info"
		o = append(o, 0xa8, 0x6d, 0x65, 0x6d, 0x5f, 0x69, 0x6e, 0x66, 0x6f)
		o, err = z.MemInfo.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "MemInfo")
			return
		}
		// string "io_counters"
		o = append(o, 0xab, 0x69, 0x6f, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x73)
		o, err = z.IOCounters.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "IOCounters")
			return
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "num_ctx_switches"
			o = append(o, 0xb0, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x74, 0x78, 0x5f, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x65, 0x73)
			// check for omitted fields
			zb0002Len := uint32(3)
			var zb0002Mask uint8 /* 3 bits */
			_ = zb0002Mask
			if z.NumCtxSwitches.Voluntary == 0 {
				zb0002Len--
				zb0002Mask |= 0x1
			}
			if z.NumCtxSwitches.Involuntary == 0 {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if z.NumCtxSwitches.Count == 0 {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))

			// skip if no fields are to be emitted
			if zb0002Len != 0 {
				if (zb0002Mask & 0x1) == 0 { // if not omitted
					// string "voluntary"
					o = append(o, 0xa9, 0x76, 0x6f, 0x6c, 0x75, 0x6e, 0x74, 0x61, 0x72, 0x79)
					o = msgp.AppendInt64(o, z.NumCtxSwitches.Voluntary)
				}
				if (zb0002Mask & 0x2) == 0 { // if not omitted
					// string "involuntary"
					o = append(o, 0xab, 0x69, 0x6e, 0x76, 0x6f, 0x6c, 0x75, 0x6e, 0x74, 0x61, 0x72, 0x79)
					o = msgp.AppendInt64(o, z.NumCtxSwitches.Involuntary)
				}
				if (zb0002Mask & 0x4) == 0 { // if not omitted
					// string "count"
					o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
					o = msgp.AppendInt(o, z.NumCtxSwitches.Count)
				}
			}
		}
		// string "page_faults"
		o = append(o, 0xab, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
		o, err = z.PageFaults.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "PageFaults")
			return
		}
		// string "cpu_times"
		o = append(o, 0xa9, 0x63, 0x70, 0x75, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73)
		o, err = z.CPUTimes.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "CPUTimes")
			return
		}
		// string "mem_maps"
		o = append(o, 0xa8, 0x6d, 0x65, 0x6d, 0x5f, 0x6d, 0x61, 0x70, 0x73)
		o, err = z.MemMaps.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "MemMaps")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 17 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected_at":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
			zb0001Mask |= 0x1
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x2
		case "total_cpu_percent":
			z.TotalCPUPercent, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalCPUPercent")
				return
			}
			zb0001Mask |= 0x4
		case "total_num_connections":
			z.TotalNumConnections, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalNumConnections")
				return
			}
			zb0001Mask |= 0x8
		case "total_running_secs":
			z.TotalRunningSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalRunningSecs")
				return
			}
			zb0001Mask |= 0x10
		case "total_num_fds":
			z.TotalNumFDs, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalNumFDs")
				return
			}
			zb0001Mask |= 0x20
		case "total_num_threads":
			z.TotalNumThreads, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalNumThreads")
				return
			}
			zb0001Mask |= 0x40
		case "total_nice":
			z.TotalNice, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalNice")
				return
			}
			zb0001Mask |= 0x80
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x100
		case "background_processes":
			z.BackgroundProcesses, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BackgroundProcesses")
				return
			}
			zb0001Mask |= 0x200
		case "running_processes":
			z.RunningProcesses, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RunningProcesses")
				return
			}
			zb0001Mask |= 0x400
		case "mem_info":
			bts, err = z.MemInfo.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MemInfo")
				return
			}
			zb0001Mask |= 0x800
		case "io_counters":
			bts, err = z.IOCounters.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "IOCounters")
				return
			}
			zb0001Mask |= 0x1000
		case "num_ctx_switches":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumCtxSwitches")
				return
			}
			var zb0002Mask uint8 /* 3 bits */
			_ = zb0002Mask
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "NumCtxSwitches")
					return
				}
				switch msgp.UnsafeString(field) {
				case "voluntary":
					z.NumCtxSwitches.Voluntary, bts, err = msgp.ReadInt64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Voluntary")
						return
					}
					zb0002Mask |= 0x1
				case "involuntary":
					z.NumCtxSwitches.Involuntary, bts, err = msgp.ReadInt64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Involuntary")
						return
					}
					zb0002Mask |= 0x2
				case "count":
					z.NumCtxSwitches.Count, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches", "Count")
						return
					}
					zb0002Mask |= 0x4
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "NumCtxSwitches")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0002Mask != 0x7 {
				if (zb0002Mask & 0x1) == 0 {
					z.NumCtxSwitches.Voluntary = 0
				}
				if (zb0002Mask & 0x2) == 0 {
					z.NumCtxSwitches.Involuntary = 0
				}
				if (zb0002Mask & 0x4) == 0 {
					z.NumCtxSwitches.Count = 0
				}
			}
			zb0001Mask |= 0x2000
		case "page_faults":
			bts, err = z.PageFaults.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "PageFaults")
				return
			}
			zb0001Mask |= 0x4000
		case "cpu_times":
			bts, err = z.CPUTimes.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "CPUTimes")
				return
			}
			zb0001Mask |= 0x8000
		case "mem_maps":
			bts, err = z.MemMaps.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "MemMaps")
				return
			}
			zb0001Mask |= 0x10000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.CollectedAt = (time.Time{})
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.TotalCPUPercent = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.TotalNumConnections = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.TotalRunningSecs = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.TotalNumFDs = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.TotalNumThreads = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.TotalNice = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.Count = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.BackgroundProcesses = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.RunningProcesses = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.MemInfo = ProcessMemoryInfo{}
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.IOCounters = ProcessIOCounters{}
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.NumCtxSwitches = (ProcessCtxSwitches{})
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.PageFaults = ProcessPageFaults{}
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.CPUTimes = ProcessCPUTimes{}
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.MemMaps = ProcessMemoryMaps{}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessMetrics) Msgsize() (s int) {
	s = 3 + 13 + msgp.TimeSize + 6 + msgp.IntSize + 18 + msgp.Float64Size + 22 + msgp.IntSize + 19 + msgp.Float64Size + 14 + msgp.Int64Size + 18 + msgp.Int64Size + 11 + msgp.Int64Size + 6 + msgp.IntSize + 21 + msgp.IntSize + 18 + msgp.IntSize + 9 + z.MemInfo.Msgsize() + 12 + z.IOCounters.Msgsize() + 17 + 1 + 10 + msgp.Int64Size + 12 + msgp.Int64Size + 6 + msgp.IntSize + 12 + z.PageFaults.Msgsize() + 10 + z.CPUTimes.Msgsize() + 9 + z.MemMaps.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessPageFaults) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "minor_faults":
			z.MinorFaults, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MinorFaults")
				return
			}
			zb0001Mask |= 0x1
		case "major_faults":
			z.MajorFaults, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MajorFaults")
				return
			}
			zb0001Mask |= 0x2
		case "child_minor_faults":
			z.ChildMinorFaults, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ChildMinorFaults")
				return
			}
			zb0001Mask |= 0x4
		case "child_major_faults":
			z.ChildMajorFaults, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "ChildMajorFaults")
				return
			}
			zb0001Mask |= 0x8
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x10
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.MinorFaults = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.MajorFaults = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ChildMinorFaults = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ChildMajorFaults = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Count = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessPageFaults) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.MinorFaults == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.MajorFaults == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ChildMinorFaults == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ChildMajorFaults == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "minor_faults"
			err = en.Append(0xac, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.MinorFaults)
			if err != nil {
				err = msgp.WrapError(err, "MinorFaults")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "major_faults"
			err = en.Append(0xac, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.MajorFaults)
			if err != nil {
				err = msgp.WrapError(err, "MajorFaults")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "child_minor_faults"
			err = en.Append(0xb2, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x5f, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ChildMinorFaults)
			if err != nil {
				err = msgp.WrapError(err, "ChildMinorFaults")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "child_major_faults"
			err = en.Append(0xb2, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x5f, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteUint64(z.ChildMajorFaults)
			if err != nil {
				err = msgp.WrapError(err, "ChildMajorFaults")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "count"
			err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Count)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessPageFaults) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.MinorFaults == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.MajorFaults == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.ChildMinorFaults == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ChildMajorFaults == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Count == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "minor_faults"
			o = append(o, 0xac, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
			o = msgp.AppendUint64(o, z.MinorFaults)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "major_faults"
			o = append(o, 0xac, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
			o = msgp.AppendUint64(o, z.MajorFaults)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "child_minor_faults"
			o = append(o, 0xb2, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x5f, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
			o = msgp.AppendUint64(o, z.ChildMinorFaults)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "child_major_faults"
			o = append(o, 0xb2, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x5f, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73)
			o = msgp.AppendUint64(o, z.ChildMajorFaults)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "count"
			o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.Count)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessPageFaults) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "minor_faults":
			z.MinorFaults, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinorFaults")
				return
			}
			zb0001Mask |= 0x1
		case "major_faults":
			z.MajorFaults, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MajorFaults")
				return
			}
			zb0001Mask |= 0x2
		case "child_minor_faults":
			z.ChildMinorFaults, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChildMinorFaults")
				return
			}
			zb0001Mask |= 0x4
		case "child_major_faults":
			z.ChildMajorFaults, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChildMajorFaults")
				return
			}
			zb0001Mask |= 0x8
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
			zb0001Mask |= 0x10
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.MinorFaults = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.MajorFaults = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ChildMinorFaults = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ChildMajorFaults = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Count = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessPageFaults) Msgsize() (s int) {
	s = 1 + 13 + msgp.Uint64Size + 13 + msgp.Uint64Size + 19 + msgp.Uint64Size + 19 + msgp.Uint64Size + 6 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RPCMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 19 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x1
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "connected":
			z.Connected, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
			zb0001Mask |= 0x2
		case "disconnected":
			z.Disconnected, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
			zb0001Mask |= 0x4
		case "reconnectCount":
			z.ReconnectCount, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
			zb0001Mask |= 0x8
		case "outgoingStreams":
			z.OutgoingStreams, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
			zb0001Mask |= 0x10
		case "incomingStreams":
			z.IncomingStreams, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
			zb0001Mask |= 0x20
		case "outgoingMessages":
			z.OutgoingMessages, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
			zb0001Mask |= 0x40
		case "incomingMessages":
			z.IncomingMessages, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
			zb0001Mask |= 0x80
		case "outgoingBytes":
			z.OutgoingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x100
		case "incomingBytes":
			z.IncomingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x200
		case "outQueue":
			z.OutQueue, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
			zb0001Mask |= 0x400
		case "lastPongTime":
			z.LastPongTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
			zb0001Mask |= 0x800
		case "lastConnectTime":
			z.LastConnectTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
			zb0001Mask |= 0x1000
		case "lastPingMS":
			z.LastPingMS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
			zb0001Mask |= 0x2000
		case "maxPingDurMS":
			z.MaxPingDurMS, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
			zb0001Mask |= 0x4000
		case "lastMinute":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			if z.LastMinute == nil {
				z.LastMinute = make(map[string]RPCStats, zb0002)
			} else if len(z.LastMinute) > 0 {
				clear(z.LastMinute)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				var za0002 RPCStats
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0001)
					return
				}
				z.LastMinute[za0001] = za0002
			}
			zb0001Mask |= 0x8000
		case "lastDay":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastDay")
				return
			}
			if z.LastDay == nil {
				z.LastDay = make(map[string]SegmentedRPCMetrics, zb0003)
			} else if len(z.LastDay) > 0 {
				clear(z.LastDay)
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LastDay")
					return
				}
				var za0004 SegmentedRPCMetrics
				err = (*Segmented[RPCStats, *RPCStats])(&za0004).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastDay", za0003)
					return
				}
				z.LastDay[za0003] = za0004
			}
			zb0001Mask |= 0x10000
		case "byDestination":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			if z.ByDestination == nil {
				z.ByDestination = make(map[string]ConnectionStats, zb0004)
			} else if len(z.ByDestination) > 0 {
				clear(z.ByDestination)
			}
			for zb0004 > 0 {
				zb0004--
				var za0005 string
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				var za0006 ConnectionStats
				err = za0006.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0005)
					return
				}
				z.ByDestination[za0005] = za0006
			}
			zb0001Mask |= 0x20000
		case "byCaller":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			if z.ByCaller == nil {
				z.ByCaller = make(map[string]ConnectionStats, zb0005)
			} else if len(z.ByCaller) > 0 {
				clear(z.ByCaller)
			}
			for zb0005 > 0 {
				zb0005--
				var za0007 string
				za0007, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				var za0008 ConnectionStats
				err = za0008.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0007)
					return
				}
				z.ByCaller[za0007] = za0008
			}
			zb0001Mask |= 0x40000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Connected = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Disconnected = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ReconnectCount = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.OutgoingStreams = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IncomingStreams = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.OutgoingMessages = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.IncomingMessages = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.OutgoingBytes = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.OutQueue = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.LastPongTime = (time.Time{})
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.LastConnectTime = (time.Time{})
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.LastPingMS = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.MaxPingDurMS = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.LastMinute = nil
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.LastDay = nil
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.ByDestination = nil
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.ByCaller = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RPCMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(20)
	var zb0001Mask uint32 /* 20 bits */
	_ = zb0001Mask
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Connected == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Disconnected == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ReconnectCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.OutgoingStreams == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.IncomingStreams == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.OutgoingMessages == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.IncomingMessages == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.OutQueue == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.LastPongTime == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.LastConnectTime == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.LastPingMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.MaxPingDurMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.LastMinute == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.LastDay == nil {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.ByDestination == nil {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.ByCaller == nil {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "nodes"
			err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Nodes)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		}
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "connected"
			err = en.Append(0xa9, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Connected)
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "disconnected"
			err = en.Append(0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Disconnected)
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "reconnectCount"
			err = en.Append(0xae, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt(z.ReconnectCount)
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "outgoingStreams"
			err = en.Append(0xaf, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.OutgoingStreams)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "incomingStreams"
			err = en.Append(0xaf, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.IncomingStreams)
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "outgoingMessages"
			err = en.Append(0xb0, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.OutgoingMessages)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "incomingMessages"
			err = en.Append(0xb0, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.IncomingMessages)
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "outgoingBytes"
			err = en.Append(0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.OutgoingBytes)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "incomingBytes"
			err = en.Append(0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.IncomingBytes)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "outQueue"
			err = en.Append(0xa8, 0x6f, 0x75, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt(z.OutQueue)
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "lastPongTime"
			err = en.Append(0xac, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x6f, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			err = en.WriteTime(z.LastPongTime)
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "lastConnectTime"
			err = en.Append(0xaf, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			err = en.WriteTime(z.LastConnectTime)
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "lastPingMS"
			err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x4d, 0x53)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.LastPingMS)
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "maxPingDurMS"
			err = en.Append(0xac, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x6e, 0x67, 0x44, 0x75, 0x72, 0x4d, 0x53)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.MaxPingDurMS)
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "lastMinute"
			err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastMinute)))
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			for za0001, za0002 := range z.LastMinute {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				err = za0002.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// write "lastDay"
			err = en.Append(0xa7, 0x6c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x79)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LastDay)))
			if err != nil {
				err = msgp.WrapError(err, "LastDay")
				return
			}
			for za0003, za0004 := range z.LastDay {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "LastDay")
					return
				}
				err = (*Segmented[RPCStats, *RPCStats])(&za0004).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastDay", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x40000) == 0 { // if not omitted
			// write "byDestination"
			err = en.Append(0xad, 0x62, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByDestination)))
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			for za0005, za0006 := range z.ByDestination {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				err = za0006.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x80000) == 0 { // if not omitted
			// write "byCaller"
			err = en.Append(0xa8, 0x62, 0x79, 0x43, 0x61, 0x6c, 0x6c, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByCaller)))
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			for za0007, za0008 := range z.ByCaller {
				err = en.WriteString(za0007)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				err = za0008.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0007)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RPCMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(20)
	var zb0001Mask uint32 /* 20 bits */
	_ = zb0001Mask
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Connected == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Disconnected == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ReconnectCount == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.OutgoingStreams == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.IncomingStreams == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.OutgoingMessages == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.IncomingMessages == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.OutQueue == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.LastPongTime == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.LastConnectTime == (time.Time{}) {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.LastPingMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.MaxPingDurMS == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.LastMinute == nil {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.LastDay == nil {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.ByDestination == nil {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.ByCaller == nil {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "nodes"
			o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			o = msgp.AppendInt(o, z.Nodes)
		}
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "connected"
			o = append(o, 0xa9, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
			o = msgp.AppendInt(o, z.Connected)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "disconnected"
			o = append(o, 0xac, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64)
			o = msgp.AppendInt(o, z.Disconnected)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "reconnectCount"
			o = append(o, 0xae, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x43, 0x6f, 0x75, 0x6e, 0x74)
			o = msgp.AppendInt(o, z.ReconnectCount)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "outgoingStreams"
			o = append(o, 0xaf, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
			o = msgp.AppendInt(o, z.OutgoingStreams)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "incomingStreams"
			o = append(o, 0xaf, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x73)
			o = msgp.AppendInt(o, z.IncomingStreams)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "outgoingMessages"
			o = append(o, 0xb0, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.OutgoingMessages)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "incomingMessages"
			o = append(o, 0xb0, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.IncomingMessages)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "outgoingBytes"
			o = append(o, 0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.OutgoingBytes)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "incomingBytes"
			o = append(o, 0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.IncomingBytes)
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "outQueue"
			o = append(o, 0xa8, 0x6f, 0x75, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65)
			o = msgp.AppendInt(o, z.OutQueue)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "lastPongTime"
			o = append(o, 0xac, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x6f, 0x6e, 0x67, 0x54, 0x69, 0x6d, 0x65)
			o = msgp.AppendTime(o, z.LastPongTime)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "lastConnectTime"
			o = append(o, 0xaf, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x69, 0x6d, 0x65)
			o = msgp.AppendTime(o, z.LastConnectTime)
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "lastPingMS"
			o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x50, 0x69, 0x6e, 0x67, 0x4d, 0x53)
			o = msgp.AppendFloat64(o, z.LastPingMS)
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "maxPingDurMS"
			o = append(o, 0xac, 0x6d, 0x61, 0x78, 0x50, 0x69, 0x6e, 0x67, 0x44, 0x75, 0x72, 0x4d, 0x53)
			o = msgp.AppendFloat64(o, z.MaxPingDurMS)
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "lastMinute"
			o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute)))
			for za0001, za0002 := range z.LastMinute {
				o = msgp.AppendString(o, za0001)
				o, err = za0002.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// string "lastDay"
			o = append(o, 0xa7, 0x6c, 0x61, 0x73, 0x74, 0x44, 0x61, 0x79)
			o = msgp.AppendMapHeader(o, uint32(len(z.LastDay)))
			for za0003, za0004 := range z.LastDay {
				o = msgp.AppendString(o, za0003)
				o, err = (*Segmented[RPCStats, *RPCStats])(&za0004).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastDay", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x40000) == 0 { // if not omitted
			// string "byDestination"
			o = append(o, 0xad, 0x62, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByDestination)))
			for za0005, za0006 := range z.ByDestination {
				o = msgp.AppendString(o, za0005)
				o, err = za0006.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x80000) == 0 { // if not omitted
			// string "byCaller"
			o = append(o, 0xa8, 0x62, 0x79, 0x43, 0x61, 0x6c, 0x6c, 0x65, 0x72)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByCaller)))
			for za0007, za0008 := range z.ByCaller {
				o = msgp.AppendString(o, za0007)
				o, err = za0008.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0007)
					return
				}
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RPCMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 19 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x1
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "connected":
			z.Connected, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Connected")
				return
			}
			zb0001Mask |= 0x2
		case "disconnected":
			z.Disconnected, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Disconnected")
				return
			}
			zb0001Mask |= 0x4
		case "reconnectCount":
			z.ReconnectCount, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReconnectCount")
				return
			}
			zb0001Mask |= 0x8
		case "outgoingStreams":
			z.OutgoingStreams, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingStreams")
				return
			}
			zb0001Mask |= 0x10
		case "incomingStreams":
			z.IncomingStreams, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingStreams")
				return
			}
			zb0001Mask |= 0x20
		case "outgoingMessages":
			z.OutgoingMessages, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingMessages")
				return
			}
			zb0001Mask |= 0x40
		case "incomingMessages":
			z.IncomingMessages, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingMessages")
				return
			}
			zb0001Mask |= 0x80
		case "outgoingBytes":
			z.OutgoingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x100
		case "incomingBytes":
			z.IncomingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x200
		case "outQueue":
			z.OutQueue, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutQueue")
				return
			}
			zb0001Mask |= 0x400
		case "lastPongTime":
			z.LastPongTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPongTime")
				return
			}
			zb0001Mask |= 0x800
		case "lastConnectTime":
			z.LastConnectTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastConnectTime")
				return
			}
			zb0001Mask |= 0x1000
		case "lastPingMS":
			z.LastPingMS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastPingMS")
				return
			}
			zb0001Mask |= 0x2000
		case "maxPingDurMS":
			z.MaxPingDurMS, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxPingDurMS")
				return
			}
			zb0001Mask |= 0x4000
		case "lastMinute":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			if z.LastMinute == nil {
				z.LastMinute = make(map[string]RPCStats, zb0002)
			} else if len(z.LastMinute) > 0 {
				clear(z.LastMinute)
			}
			for zb0002 > 0 {
				var za0002 RPCStats
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", za0001)
					return
				}
				z.LastMinute[za0001] = za0002
			}
			zb0001Mask |= 0x8000
		case "lastDay":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastDay")
				return
			}
			if z.LastDay == nil {
				z.LastDay = make(map[string]SegmentedRPCMetrics, zb0003)
			} else if len(z.LastDay) > 0 {
				clear(z.LastDay)
			}
			for zb0003 > 0 {
				var za0004 SegmentedRPCMetrics
				zb0003--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDay")
					return
				}
				bts, err = (*Segmented[RPCStats, *RPCStats])(&za0004).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDay", za0003)
					return
				}
				z.LastDay[za0003] = za0004
			}
			zb0001Mask |= 0x10000
		case "byDestination":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDestination")
				return
			}
			if z.ByDestination == nil {
				z.ByDestination = make(map[string]ConnectionStats, zb0004)
			} else if len(z.ByDestination) > 0 {
				clear(z.ByDestination)
			}
			for zb0004 > 0 {
				var za0006 ConnectionStats
				zb0004--
				var za0005 string
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination")
					return
				}
				bts, err = za0006.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDestination", za0005)
					return
				}
				z.ByDestination[za0005] = za0006
			}
			zb0001Mask |= 0x20000
		case "byCaller":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByCaller")
				return
			}
			if z.ByCaller == nil {
				z.ByCaller = make(map[string]ConnectionStats, zb0005)
			} else if len(z.ByCaller) > 0 {
				clear(z.ByCaller)
			}
			for zb0005 > 0 {
				var za0008 ConnectionStats
				zb0005--
				var za0007 string
				za0007, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller")
					return
				}
				bts, err = za0008.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByCaller", za0007)
					return
				}
				z.ByCaller[za0007] = za0008
			}
			zb0001Mask |= 0x40000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7ffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Connected = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Disconnected = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ReconnectCount = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.OutgoingStreams = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IncomingStreams = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.OutgoingMessages = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.IncomingMessages = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.OutgoingBytes = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.OutQueue = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.LastPongTime = (time.Time{})
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.LastConnectTime = (time.Time{})
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.LastPingMS = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.MaxPingDurMS = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.LastMinute = nil
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.LastDay = nil
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.ByDestination = nil
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.ByCaller = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RPCMetrics) Msgsize() (s int) {
	s = 3 + 6 + msgp.IntSize + 10 + msgp.TimeSize + 10 + msgp.IntSize + 13 + msgp.IntSize + 15 + msgp.IntSize + 16 + msgp.IntSize + 16 + msgp.IntSize + 17 + msgp.Int64Size + 17 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 9 + msgp.IntSize + 13 + msgp.TimeSize + 16 + msgp.TimeSize + 11 + msgp.Float64Size + 13 + msgp.Float64Size + 11 + msgp.MapHeaderSize
	if z.LastMinute != nil {
		for za0001, za0002 := range z.LastMinute {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.LastDay != nil {
		for za0003, za0004 := range z.LastDay {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + (*Segmented[RPCStats, *RPCStats])(&za0004).Msgsize()
		}
	}
	s += 14 + msgp.MapHeaderSize
	if z.ByDestination != nil {
		for za0005, za0006 := range z.ByDestination {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + za0006.Msgsize()
		}
	}
	s += 9 + msgp.MapHeaderSize
	if z.ByCaller != nil {
		for za0007, za0008 := range z.ByCaller {
			_ = za0008
			s += msgp.StringPrefixSize + len(za0007) + za0008.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RPCStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "startTime":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
				z.StartTime = nil
			} else {
				if z.StartTime == nil {
					z.StartTime = new(time.Time)
				}
				*z.StartTime, err = dc.ReadTimeUTC()
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
			zb0001Mask |= 0x1
		case "endTime":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
				z.EndTime = nil
			} else {
				if z.EndTime == nil {
					z.EndTime = new(time.Time)
				}
				*z.EndTime, err = dc.ReadTimeUTC()
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
			zb0001Mask |= 0x2
		case "wallTimeSecs":
			z.WallTimeSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
			zb0001Mask |= 0x4
		case "requests":
			z.Requests, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
			zb0001Mask |= 0x8
		case "requestTimeSecs":
			z.RequestTimeSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
			zb0001Mask |= 0x10
		case "incomingBytes":
			z.IncomingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x20
		case "outgoingBytes":
			z.OutgoingBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x40
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7f {
		if (zb0001Mask & 0x1) == 0 {
			z.StartTime = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.EndTime = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.WallTimeSecs = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Requests = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.RequestTimeSecs = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.OutgoingBytes = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RPCStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.StartTime == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.EndTime == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.WallTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Requests == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.RequestTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "startTime"
			err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			if z.StartTime == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteTime(*z.StartTime)
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "endTime"
			err = en.Append(0xa7, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			if z.EndTime == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteTime(*z.EndTime)
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "wallTimeSecs"
			err = en.Append(0xac, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.WallTimeSecs)
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "requests"
			err = en.Append(0xa8, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Requests)
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "requestTimeSecs"
			err = en.Append(0xaf, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.RequestTimeSecs)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "incomingBytes"
			err = en.Append(0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.IncomingBytes)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "outgoingBytes"
			err = en.Append(0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.OutgoingBytes)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RPCStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.StartTime == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.EndTime == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.WallTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Requests == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.RequestTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.IncomingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.OutgoingBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "startTime"
			o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if z.StartTime == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendTime(o, *z.StartTime)
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "endTime"
			o = append(o, 0xa7, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
			if z.EndTime == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendTime(o, *z.EndTime)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "wallTimeSecs"
			o = append(o, 0xac, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.WallTimeSecs)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "requests"
			o = append(o, 0xa8, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73)
			o = msgp.AppendInt64(o, z.Requests)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "requestTimeSecs"
			o = append(o, 0xaf, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.RequestTimeSecs)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "incomingBytes"
			o = append(o, 0xad, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.IncomingBytes)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "outgoingBytes"
			o = append(o, 0xad, 0x6f, 0x75, 0x74, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.OutgoingBytes)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RPCStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "startTime":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StartTime = nil
			} else {
				if z.StartTime == nil {
					z.StartTime = new(time.Time)
				}
				*z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
			zb0001Mask |= 0x1
		case "endTime":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EndTime = nil
			} else {
				if z.EndTime == nil {
					z.EndTime = new(time.Time)
				}
				*z.EndTime, bts, err = msgp.ReadTimeUTCBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
			zb0001Mask |= 0x2
		case "wallTimeSecs":
			z.WallTimeSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
			zb0001Mask |= 0x4
		case "requests":
			z.Requests, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Requests")
				return
			}
			zb0001Mask |= 0x8
		case "requestTimeSecs":
			z.RequestTimeSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestTimeSecs")
				return
			}
			zb0001Mask |= 0x10
		case "incomingBytes":
			z.IncomingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncomingBytes")
				return
			}
			zb0001Mask |= 0x20
		case "outgoingBytes":
			z.OutgoingBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutgoingBytes")
				return
			}
			zb0001Mask |= 0x40
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7f {
		if (zb0001Mask & 0x1) == 0 {
			z.StartTime = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.EndTime = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.WallTimeSecs = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Requests = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.RequestTimeSecs = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.IncomingBytes = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.OutgoingBytes = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RPCStats) Msgsize() (s int) {
	s = 1 + 10
	if z.StartTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 8
	if z.EndTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 13 + msgp.Float64Size + 9 + msgp.Int64Size + 16 + msgp.Float64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RealtimeMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "errors":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0002) {
				z.Errors = (z.Errors)[:zb0002]
			} else {
				z.Errors = make([]string, zb0002)
			}
			for za0001 := range z.Errors {
				z.Errors[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "hosts":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0003) {
				z.Hosts = (z.Hosts)[:zb0003]
			} else {
				z.Hosts = make([]string, zb0003)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "aggregated":
			err = z.Aggregated.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Aggregated")
				return
			}
		case "by_host":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			if z.ByHost == nil {
				z.ByHost = make(map[string]Metrics, zb0004)
			} else if len(z.ByHost) > 0 {
				clear(z.ByHost)
			}
			for zb0004 > 0 {
				zb0004--
				var za0003 string
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				var za0004 Metrics
				err = za0004.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
				z.ByHost[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "by_disk":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			if z.ByDisk == nil {
				z.ByDisk = make(map[string]DiskMetric, zb0005)
			} else if len(z.ByDisk) > 0 {
				clear(z.ByDisk)
			}
			for zb0005 > 0 {
				zb0005--
				var za0005 string
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				var za0006 DiskMetric
				err = za0006.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
				z.ByDisk[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "by_disk_set":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ByDiskSet")
				return
			}
			if z.ByDiskSet == nil {
				z.ByDiskSet = make(map[int]map[int]DiskMetric, zb0006)
			} else if len(z.ByDiskSet) > 0 {
				clear(z.ByDiskSet)
			}
			for zb0006 > 0 {
				zb0006--
				var za0007 int
				za0007, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ByDiskSet", za0007)
					return
				}
				var za0008 map[int]DiskMetric
				var zb0007 uint32
				zb0007, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "ByDiskSet", za0007)
					return
				}
				if za0008 == nil {
					za0008 = make(map[int]DiskMetric, zb0007)
				} else if len(za0008) > 0 {
					clear(za0008)
				}
				for zb0007 > 0 {
					zb0007--
					var za0009 int
					za0009, err = dc.ReadInt()
					if err != nil {
						err = msgp.WrapError(err, "ByDiskSet", za0007, za0009)
						return
					}
					var za0010 DiskMetric
					err = za0010.DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "ByDiskSet", za0007, za0009)
						return
					}
					za0008[za0009] = za0010
				}
				z.ByDiskSet[za0007] = za0008
			}
			zb0001Mask |= 0x8
		case "final":
			z.Final, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Final")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Errors = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByHost = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ByDisk = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ByDiskSet = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RealtimeMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.Errors == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ByHost == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ByDisk == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.ByDiskSet == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "errors"
			err = en.Append(0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Errors)))
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			for za0001 := range z.Errors {
				err = en.WriteString(z.Errors[za0001])
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
		}
		// write "hosts"
		err = en.Append(0xa5, 0x68, 0x6f, 0x73, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Hosts)))
		if err != nil {
			err = msgp.WrapError(err, "Hosts")
			return
		}
		for za0002 := range z.Hosts {
			err = en.WriteString(z.Hosts[za0002])
			if err != nil {
				err = msgp.WrapError(err, "Hosts", za0002)
				return
			}
		}
		// write "aggregated"
		err = en.Append(0xaa, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = z.Aggregated.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Aggregated")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "by_host"
			err = en.Append(0xa7, 0x62, 0x79, 0x5f, 0x68, 0x6f, 0x73, 0x74)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByHost)))
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			for za0003, za0004 := range z.ByHost {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				err = za0004.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "by_disk"
			err = en.Append(0xa7, 0x62, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByDisk)))
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			for za0005, za0006 := range z.ByDisk {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				err = za0006.EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "by_disk_set"
			err = en.Append(0xab, 0x62, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x73, 0x65, 0x74)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.ByDiskSet)))
			if err != nil {
				err = msgp.WrapError(err, "ByDiskSet")
				return
			}
			for za0007, za0008 := range z.ByDiskSet {
				err = en.WriteInt(za0007)
				if err != nil {
					err = msgp.WrapError(err, "ByDiskSet", za0007)
					return
				}
				err = en.WriteMapHeader(uint32(len(za0008)))
				if err != nil {
					err = msgp.WrapError(err, "ByDiskSet", za0007)
					return
				}
				for za0009, za0010 := range za0008 {
					err = en.WriteInt(za0009)
					if err != nil {
						err = msgp.WrapError(err, "ByDiskSet", za0007, za0009)
						return
					}
					err = za0010.EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "ByDiskSet", za0007, za0009)
						return
					}
				}
			}
		}
		// write "final"
		err = en.Append(0xa5, 0x66, 0x69, 0x6e, 0x61, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteBool(z.Final)
		if err != nil {
			err = msgp.WrapError(err, "Final")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RealtimeMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(7)
	var zb0001Mask uint8 /* 7 bits */
	_ = zb0001Mask
	if z.Errors == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.ByHost == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.ByDisk == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.ByDiskSet == nil {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "errors"
			o = append(o, 0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Errors)))
			for za0001 := range z.Errors {
				o = msgp.AppendString(o, z.Errors[za0001])
			}
		}
		// string "hosts"
		o = append(o, 0xa5, 0x68, 0x6f, 0x73, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Hosts)))
		for za0002 := range z.Hosts {
			o = msgp.AppendString(o, z.Hosts[za0002])
		}
		// string "aggregated"
		o = append(o, 0xaa, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x64)
		o, err = z.Aggregated.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Aggregated")
			return
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "by_host"
			o = append(o, 0xa7, 0x62, 0x79, 0x5f, 0x68, 0x6f, 0x73, 0x74)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByHost)))
			for za0003, za0004 := range z.ByHost {
				o = msgp.AppendString(o, za0003)
				o, err = za0004.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "by_disk"
			o = append(o, 0xa7, 0x62, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByDisk)))
			for za0005, za0006 := range z.ByDisk {
				o = msgp.AppendString(o, za0005)
				o, err = za0006.MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "by_disk_set"
			o = append(o, 0xab, 0x62, 0x79, 0x5f, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x73, 0x65, 0x74)
			o = msgp.AppendMapHeader(o, uint32(len(z.ByDiskSet)))
			for za0007, za0008 := range z.ByDiskSet {
				o = msgp.AppendInt(o, za0007)
				o = msgp.AppendMapHeader(o, uint32(len(za0008)))
				for za0009, za0010 := range za0008 {
					o = msgp.AppendInt(o, za0009)
					o, err = za0010.MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "ByDiskSet", za0007, za0009)
						return
					}
				}
			}
		}
		// string "final"
		o = append(o, 0xa5, 0x66, 0x69, 0x6e, 0x61, 0x6c)
		o = msgp.AppendBool(o, z.Final)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RealtimeMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "errors":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0002) {
				z.Errors = (z.Errors)[:zb0002]
			} else {
				z.Errors = make([]string, zb0002)
			}
			for za0001 := range z.Errors {
				z.Errors[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "hosts":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hosts")
				return
			}
			if cap(z.Hosts) >= int(zb0003) {
				z.Hosts = (z.Hosts)[:zb0003]
			} else {
				z.Hosts = make([]string, zb0003)
			}
			for za0002 := range z.Hosts {
				z.Hosts[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Hosts", za0002)
					return
				}
			}
		case "aggregated":
			bts, err = z.Aggregated.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Aggregated")
				return
			}
		case "by_host":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByHost")
				return
			}
			if z.ByHost == nil {
				z.ByHost = make(map[string]Metrics, zb0004)
			} else if len(z.ByHost) > 0 {
				clear(z.ByHost)
			}
			for zb0004 > 0 {
				var za0004 Metrics
				zb0004--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByHost")
					return
				}
				bts, err = za0004.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByHost", za0003)
					return
				}
				z.ByHost[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "by_disk":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDisk")
				return
			}
			if z.ByDisk == nil {
				z.ByDisk = make(map[string]DiskMetric, zb0005)
			} else if len(z.ByDisk) > 0 {
				clear(z.ByDisk)
			}
			for zb0005 > 0 {
				var za0006 DiskMetric
				zb0005--
				var za0005 string
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk")
					return
				}
				bts, err = za0006.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDisk", za0005)
					return
				}
				z.ByDisk[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "by_disk_set":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ByDiskSet")
				return
			}
			if z.ByDiskSet == nil {
				z.ByDiskSet = make(map[int]map[int]DiskMetric, zb0006)
			} else if len(z.ByDiskSet) > 0 {
				clear(z.ByDiskSet)
			}
			for zb0006 > 0 {
				var za0008 map[int]DiskMetric
				zb0006--
				var za0007 int
				za0007, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDiskSet", za0007)
					return
				}
				var zb0007 uint32
				zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ByDiskSet", za0007)
					return
				}
				if za0008 == nil {
					za0008 = make(map[int]DiskMetric, zb0007)
				} else if len(za0008) > 0 {
					clear(za0008)
				}
				for zb0007 > 0 {
					var za0010 DiskMetric
					zb0007--
					var za0009 int
					za0009, bts, err = msgp.ReadIntBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "ByDiskSet", za0007, za0009)
						return
					}
					bts, err = za0010.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ByDiskSet", za0007, za0009)
						return
					}
					za0008[za0009] = za0010
				}
				z.ByDiskSet[za0007] = za0008
			}
			zb0001Mask |= 0x8
		case "final":
			z.Final, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Final")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xf {
		if (zb0001Mask & 0x1) == 0 {
			z.Errors = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.ByHost = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.ByDisk = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ByDiskSet = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RealtimeMetrics) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize
	for za0001 := range z.Errors {
		s += msgp.StringPrefixSize + len(z.Errors[za0001])
	}
	s += 6 + msgp.ArrayHeaderSize
	for za0002 := range z.Hosts {
		s += msgp.StringPrefixSize + len(z.Hosts[za0002])
	}
	s += 11 + z.Aggregated.Msgsize() + 8 + msgp.MapHeaderSize
	if z.ByHost != nil {
		for za0003, za0004 := range z.ByHost {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + za0004.Msgsize()
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.ByDisk != nil {
		for za0005, za0006 := range z.ByDisk {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + za0006.Msgsize()
		}
	}
	s += 12 + msgp.MapHeaderSize
	if z.ByDiskSet != nil {
		for za0007, za0008 := range z.ByDiskSet {
			_ = za0008
			_ = za0007
			s += msgp.IntSize + msgp.MapHeaderSize
			if za0008 != nil {
				for za0009, za0010 := range za0008 {
					_ = za0010
					_ = za0009
					s += msgp.IntSize + za0010.Msgsize()
				}
			}
		}
	}
	s += 6 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RejectedAPIStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "auth":
			z.Auth, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Auth")
				return
			}
			zb0001Mask |= 0x1
		case "requestsTime":
			z.RequestsTime, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "RequestsTime")
				return
			}
			zb0001Mask |= 0x2
		case "header":
			z.Header, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Header")
				return
			}
			zb0001Mask |= 0x4
		case "invalid":
			z.Invalid, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Invalid")
				return
			}
			zb0001Mask |= 0x8
		case "notImplemented":
			z.NotImplemented, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "NotImplemented")
				return
			}
			zb0001Mask |= 0x10
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.Auth = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.RequestsTime = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Header = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Invalid = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.NotImplemented = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RejectedAPIStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Auth == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.RequestsTime == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Header == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Invalid == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.NotImplemented == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "auth"
			err = en.Append(0xa4, 0x61, 0x75, 0x74, 0x68)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Auth)
			if err != nil {
				err = msgp.WrapError(err, "Auth")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "requestsTime"
			err = en.Append(0xac, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.RequestsTime)
			if err != nil {
				err = msgp.WrapError(err, "RequestsTime")
				return
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "header"
			err = en.Append(0xa6, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Header)
			if err != nil {
				err = msgp.WrapError(err, "Header")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "invalid"
			err = en.Append(0xa7, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Invalid)
			if err != nil {
				err = msgp.WrapError(err, "Invalid")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "notImplemented"
			err = en.Append(0xae, 0x6e, 0x6f, 0x74, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.NotImplemented)
			if err != nil {
				err = msgp.WrapError(err, "NotImplemented")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RejectedAPIStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Auth == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.RequestsTime == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Header == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Invalid == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.NotImplemented == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "auth"
			o = append(o, 0xa4, 0x61, 0x75, 0x74, 0x68)
			o = msgp.AppendInt64(o, z.Auth)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "requestsTime"
			o = append(o, 0xac, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x54, 0x69, 0x6d, 0x65)
			o = msgp.AppendInt64(o, z.RequestsTime)
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "header"
			o = append(o, 0xa6, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72)
			o = msgp.AppendInt64(o, z.Header)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "invalid"
			o = append(o, 0xa7, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64)
			o = msgp.AppendInt64(o, z.Invalid)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "notImplemented"
			o = append(o, 0xae, 0x6e, 0x6f, 0x74, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64)
			o = msgp.AppendInt64(o, z.NotImplemented)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RejectedAPIStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "auth":
			z.Auth, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Auth")
				return
			}
			zb0001Mask |= 0x1
		case "requestsTime":
			z.RequestsTime, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequestsTime")
				return
			}
			zb0001Mask |= 0x2
		case "header":
			z.Header, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Header")
				return
			}
			zb0001Mask |= 0x4
		case "invalid":
			z.Invalid, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Invalid")
				return
			}
			zb0001Mask |= 0x8
		case "notImplemented":
			z.NotImplemented, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NotImplemented")
				return
			}
			zb0001Mask |= 0x10
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.Auth = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.RequestsTime = 0
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Header = 0
		}
		if (zb0001Mask & 0x8) == 0 {
			z.Invalid = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.NotImplemented = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RejectedAPIStats) Msgsize() (s int) {
	s = 1 + 5 + msgp.Int64Size + 13 + msgp.Int64Size + 7 + msgp.Int64Size + 8 + msgp.Int64Size + 15 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReplicateInfo) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		case "bytesTransferred":
			z.BytesTransferred, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BytesTransferred")
				return
			}
		case "bytesFailed":
			z.BytesFailed, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReplicateInfo) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "lastBucket"
	err = en.Append(0x88, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Bucket)
	if err != nil {
		err = msgp.WrapError(err, "Bucket")
		return
	}
	// write "lastObject"
	err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Object)
	if err != nil {
		err = msgp.WrapError(err, "Object")
		return
	}
	// write "objects"
	err = en.Append(0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Objects)
	if err != nil {
		err = msgp.WrapError(err, "Objects")
		return
	}
	// write "objectsFailed"
	err = en.Append(0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.ObjectsFailed)
	if err != nil {
		err = msgp.WrapError(err, "ObjectsFailed")
		return
	}
	// write "deleteMarkers"
	err = en.Append(0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkers)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkers")
		return
	}
	// write "deleteMarkersFailed"
	err = en.Append(0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.DeleteMarkersFailed)
	if err != nil {
		err = msgp.WrapError(err, "DeleteMarkersFailed")
		return
	}
	// write "bytesTransferred"
	err = en.Append(0xb0, 0x62, 0x79, 0x74, 0x65, 0x73, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BytesTransferred)
	if err != nil {
		err = msgp.WrapError(err, "BytesTransferred")
		return
	}
	// write "bytesFailed"
	err = en.Append(0xab, 0x62, 0x79, 0x74, 0x65, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.BytesFailed)
	if err != nil {
		err = msgp.WrapError(err, "BytesFailed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReplicateInfo) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "lastBucket"
	o = append(o, 0x88, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendString(o, z.Bucket)
	// string "lastObject"
	o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74)
	o = msgp.AppendString(o, z.Object)
	// string "objects"
	o = append(o, 0xa7, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendInt64(o, z.Objects)
	// string "objectsFailed"
	o = append(o, 0xad, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.ObjectsFailed)
	// string "deleteMarkers"
	o = append(o, 0xad, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73)
	o = msgp.AppendInt64(o, z.DeleteMarkers)
	// string "deleteMarkersFailed"
	o = append(o, 0xb3, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x72, 0x6b, 0x65, 0x72, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.DeleteMarkersFailed)
	// string "bytesTransferred"
	o = append(o, 0xb0, 0x62, 0x79, 0x74, 0x65, 0x73, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x72, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.BytesTransferred)
	// string "bytesFailed"
	o = append(o, 0xab, 0x62, 0x79, 0x74, 0x65, 0x73, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.BytesFailed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReplicateInfo) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "lastBucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		case "lastObject":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		case "objects":
			z.Objects, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Objects")
				return
			}
		case "objectsFailed":
			z.ObjectsFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectsFailed")
				return
			}
		case "deleteMarkers":
			z.DeleteMarkers, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkers")
				return
			}
		case "deleteMarkersFailed":
			z.DeleteMarkersFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeleteMarkersFailed")
				return
			}
		case "bytesTransferred":
			z.BytesTransferred, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesTransferred")
				return
			}
		case "bytesFailed":
			z.BytesFailed, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BytesFailed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReplicateInfo) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.Bucket) + 11 + msgp.StringPrefixSize + len(z.Object) + 8 + msgp.Int64Size + 14 + msgp.Int64Size + 14 + msgp.Int64Size + 20 + msgp.Int64Size + 17 + msgp.Int64Size + 12 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReplicationMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "active":
			z.Active, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
			zb0001Mask |= 0x1
		case "queued":
			z.Queued, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Queued")
				return
			}
			zb0001Mask |= 0x2
		case "targets":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Targets")
				return
			}
			if z.Targets == nil {
				z.Targets = make(map[string]ReplicationTargetStats, zb0002)
			} else if len(z.Targets) > 0 {
				clear(z.Targets)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Targets")
					return
				}
				var za0002 ReplicationTargetStats
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Targets", za0001)
					return
				}
				z.Targets[za0001] = za0002
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Active = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Queued = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReplicationMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Active == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Queued == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "nodes"
		err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Nodes)
		if err != nil {
			err = msgp.WrapError(err, "Nodes")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "active"
			err = en.Append(0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Active)
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "queued"
			err = en.Append(0xa6, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Queued)
			if err != nil {
				err = msgp.WrapError(err, "Queued")
				return
			}
		}
		// write "targets"
		err = en.Append(0xa7, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteMapHeader(uint32(len(z.Targets)))
		if err != nil {
			err = msgp.WrapError(err, "Targets")
			return
		}
		for za0001, za0002 := range z.Targets {
			err = en.WriteString(za0001)
			if err != nil {
				err = msgp.WrapError(err, "Targets")
				return
			}
			err = za0002.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Targets", za0001)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReplicationMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.Active == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.Queued == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "nodes"
		o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		o = msgp.AppendInt(o, z.Nodes)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "active"
			o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
			o = msgp.AppendInt64(o, z.Active)
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "queued"
			o = append(o, 0xa6, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64)
			o = msgp.AppendInt64(o, z.Queued)
		}
		// string "targets"
		o = append(o, 0xa7, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x73)
		o = msgp.AppendMapHeader(o, uint32(len(z.Targets)))
		for za0001, za0002 := range z.Targets {
			o = msgp.AppendString(o, za0001)
			o, err = za0002.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Targets", za0001)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReplicationMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "active":
			z.Active, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Active")
				return
			}
			zb0001Mask |= 0x1
		case "queued":
			z.Queued, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Queued")
				return
			}
			zb0001Mask |= 0x2
		case "targets":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Targets")
				return
			}
			if z.Targets == nil {
				z.Targets = make(map[string]ReplicationTargetStats, zb0002)
			} else if len(z.Targets) > 0 {
				clear(z.Targets)
			}
			for zb0002 > 0 {
				var za0002 ReplicationTargetStats
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Targets")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Targets", za0001)
					return
				}
				z.Targets[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Active = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Queued = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReplicationMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 6 + msgp.IntSize + 7 + msgp.Int64Size + 7 + msgp.Int64Size + 8 + msgp.MapHeaderSize
	if z.Targets != nil {
		for za0001, za0002 := range z.Targets {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReplicationStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 28 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
				z.StartTime = nil
			} else {
				if z.StartTime == nil {
					z.StartTime = new(time.Time)
				}
				*z.StartTime, err = dc.ReadTimeUTC()
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
			zb0001Mask |= 0x2
		case "endTime":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
				z.EndTime = nil
			} else {
				if z.EndTime == nil {
					z.EndTime = new(time.Time)
				}
				*z.EndTime, err = dc.ReadTimeUTC()
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
			zb0001Mask |= 0x4
		case "wallTimeSecs":
			z.WallTimeSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
			zb0001Mask |= 0x8
		case "events":
			z.Events, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Events")
				return
			}
			zb0001Mask |= 0x10
		case "bytes":
			z.Bytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Bytes")
				return
			}
			zb0001Mask |= 0x20
		case "timeSecs":
			z.EventTimeSecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "EventTimeSecs")
				return
			}
			zb0001Mask |= 0x40
		case "latency":
			z.LatencySecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "LatencySecs")
				return
			}
			zb0001Mask |= 0x80
		case "maxLatency":
			z.MaxLatencySecs, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxLatencySecs")
				return
			}
			zb0001Mask |= 0x100
		case "put":
			z.PutObject, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "PutObject")
				return
			}
			zb0001Mask |= 0x200
		case "updateMeta":
			z.UpdateMeta, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "UpdateMeta")
				return
			}
			zb0001Mask |= 0x400
		case "del":
			z.DelObject, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DelObject")
				return
			}
			zb0001Mask |= 0x800
		case "delTag":
			z.DelTag, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DelTag")
				return
			}
			zb0001Mask |= 0x1000
		case "putErrs":
			z.PutErrors, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "PutErrors")
				return
			}
			zb0001Mask |= 0x2000
		case "putTagErrs":
			z.UpdateMetaErrors, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "UpdateMetaErrors")
				return
			}
			zb0001Mask |= 0x4000
		case "delErrs":
			z.DelErrors, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DelErrors")
				return
			}
			zb0001Mask |= 0x8000
		case "delTagErrs":
			z.DelTagErrors, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "DelTagErrors")
				return
			}
			zb0001Mask |= 0x10000
		case "synced":
			z.Synced, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Synced")
				return
			}
			zb0001Mask |= 0x20000
		case "alreadyOK":
			z.AlreadyOK, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "AlreadyOK")
				return
			}
			zb0001Mask |= 0x40000
		case "rejected":
			z.Rejected, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Rejected")
				return
			}
			zb0001Mask |= 0x80000
		case "proxy":
			z.ProxyEvents, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ProxyEvents")
				return
			}
			zb0001Mask |= 0x100000
		case "proxyBytes":
			z.ProxyBytes, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ProxyBytes")
				return
			}
			zb0001Mask |= 0x200000
		case "proxyHead":
			z.ProxyHead, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ProxyHead")
				return
			}
			zb0001Mask |= 0x400000
		case "proxyGet":
			z.ProxyGet, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ProxyGet")
				return
			}
			zb0001Mask |= 0x800000
		case "proxyGetTag":
			z.ProxyGetTag, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetTag")
				return
			}
			zb0001Mask |= 0x1000000
		case "proxyHeadOK":
			z.ProxyHeadOK, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ProxyHeadOK")
				return
			}
			zb0001Mask |= 0x2000000
		case "proxyGetOK":
			z.ProxyGetOK, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetOK")
				return
			}
			zb0001Mask |= 0x4000000
		case "proxyGetTagOK":
			z.ProxyGetTagOK, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetTagOK")
				return
			}
			zb0001Mask |= 0x8000000
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xfffffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.StartTime = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.EndTime = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.WallTimeSecs = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Events = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Bytes = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.EventTimeSecs = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.LatencySecs = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.MaxLatencySecs = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.PutObject = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.UpdateMeta = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.DelObject = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.DelTag = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.PutErrors = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.UpdateMetaErrors = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.DelErrors = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.DelTagErrors = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.Synced = 0
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.AlreadyOK = 0
		}
		if (zb0001Mask & 0x80000) == 0 {
			z.Rejected = 0
		}
		if (zb0001Mask & 0x100000) == 0 {
			z.ProxyEvents = 0
		}
		if (zb0001Mask & 0x200000) == 0 {
			z.ProxyBytes = 0
		}
		if (zb0001Mask & 0x400000) == 0 {
			z.ProxyHead = 0
		}
		if (zb0001Mask & 0x800000) == 0 {
			z.ProxyGet = 0
		}
		if (zb0001Mask & 0x1000000) == 0 {
			z.ProxyGetTag = 0
		}
		if (zb0001Mask & 0x2000000) == 0 {
			z.ProxyHeadOK = 0
		}
		if (zb0001Mask & 0x4000000) == 0 {
			z.ProxyGetOK = 0
		}
		if (zb0001Mask & 0x8000000) == 0 {
			z.ProxyGetTagOK = 0
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReplicationStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(28)
	var zb0001Mask uint32 /* 28 bits */
	_ = zb0001Mask
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.StartTime == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.EndTime == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.WallTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Events == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Bytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.EventTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.LatencySecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.MaxLatencySecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.PutObject == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.UpdateMeta == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.DelObject == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.DelTag == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.PutErrors == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.UpdateMetaErrors == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.DelErrors == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.DelTagErrors == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.Synced == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.AlreadyOK == 0 {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.Rejected == 0 {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.ProxyEvents == 0 {
		zb0001Len--
		zb0001Mask |= 0x100000
	}
	if z.ProxyBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x200000
	}
	if z.ProxyHead == 0 {
		zb0001Len--
		zb0001Mask |= 0x400000
	}
	if z.ProxyGet == 0 {
		zb0001Len--
		zb0001Mask |= 0x800000
	}
	if z.ProxyGetTag == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000000
	}
	if z.ProxyHeadOK == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000000
	}
	if z.ProxyGetOK == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000000
	}
	if z.ProxyGetTagOK == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "nodes"
			err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt(z.Nodes)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "startTime"
			err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			if z.StartTime == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteTime(*z.StartTime)
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "endTime"
			err = en.Append(0xa7, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
			if err != nil {
				return
			}
			if z.EndTime == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = en.WriteTime(*z.EndTime)
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "wallTimeSecs"
			err = en.Append(0xac, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.WallTimeSecs)
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "events"
			err = en.Append(0xa6, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Events)
			if err != nil {
				err = msgp.WrapError(err, "Events")
				return
			}
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// write "bytes"
			err = en.Append(0xa5, 0x62, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Bytes)
			if err != nil {
				err = msgp.WrapError(err, "Bytes")
				return
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "timeSecs"
			err = en.Append(0xa8, 0x74, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.EventTimeSecs)
			if err != nil {
				err = msgp.WrapError(err, "EventTimeSecs")
				return
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "latency"
			err = en.Append(0xa7, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.LatencySecs)
			if err != nil {
				err = msgp.WrapError(err, "LatencySecs")
				return
			}
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// write "maxLatency"
			err = en.Append(0xaa, 0x6d, 0x61, 0x78, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.MaxLatencySecs)
			if err != nil {
				err = msgp.WrapError(err, "MaxLatencySecs")
				return
			}
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// write "put"
			err = en.Append(0xa3, 0x70, 0x75, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.PutObject)
			if err != nil {
				err = msgp.WrapError(err, "PutObject")
				return
			}
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// write "updateMeta"
			err = en.Append(0xaa, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x74, 0x61)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.UpdateMeta)
			if err != nil {
				err = msgp.WrapError(err, "UpdateMeta")
				return
			}
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// write "del"
			err = en.Append(0xa3, 0x64, 0x65, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.DelObject)
			if err != nil {
				err = msgp.WrapError(err, "DelObject")
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "delTag"
			err = en.Append(0xa6, 0x64, 0x65, 0x6c, 0x54, 0x61, 0x67)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.DelTag)
			if err != nil {
				err = msgp.WrapError(err, "DelTag")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "putErrs"
			err = en.Append(0xa7, 0x70, 0x75, 0x74, 0x45, 0x72, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.PutErrors)
			if err != nil {
				err = msgp.WrapError(err, "PutErrors")
				return
			}
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// write "putTagErrs"
			err = en.Append(0xaa, 0x70, 0x75, 0x74, 0x54, 0x61, 0x67, 0x45, 0x72, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.UpdateMetaErrors)
			if err != nil {
				err = msgp.WrapError(err, "UpdateMetaErrors")
				return
			}
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// write "delErrs"
			err = en.Append(0xa7, 0x64, 0x65, 0x6c, 0x45, 0x72, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.DelErrors)
			if err != nil {
				err = msgp.WrapError(err, "DelErrors")
				return
			}
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// write "delTagErrs"
			err = en.Append(0xaa, 0x64, 0x65, 0x6c, 0x54, 0x61, 0x67, 0x45, 0x72, 0x72, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.DelTagErrors)
			if err != nil {
				err = msgp.WrapError(err, "DelTagErrors")
				return
			}
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// write "synced"
			err = en.Append(0xa6, 0x73, 0x79, 0x6e, 0x63, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Synced)
			if err != nil {
				err = msgp.WrapError(err, "Synced")
				return
			}
		}
		if (zb0001Mask & 0x40000) == 0 { // if not omitted
			// write "alreadyOK"
			err = en.Append(0xa9, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x4f, 0x4b)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.AlreadyOK)
			if err != nil {
				err = msgp.WrapError(err, "AlreadyOK")
				return
			}
		}
		if (zb0001Mask & 0x80000) == 0 { // if not omitted
			// write "rejected"
			err = en.Append(0xa8, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Rejected)
			if err != nil {
				err = msgp.WrapError(err, "Rejected")
				return
			}
		}
		if (zb0001Mask & 0x100000) == 0 { // if not omitted
			// write "proxy"
			err = en.Append(0xa5, 0x70, 0x72, 0x6f, 0x78, 0x79)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ProxyEvents)
			if err != nil {
				err = msgp.WrapError(err, "ProxyEvents")
				return
			}
		}
		if (zb0001Mask & 0x200000) == 0 { // if not omitted
			// write "proxyBytes"
			err = en.Append(0xaa, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x42, 0x79, 0x74, 0x65, 0x73)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ProxyBytes)
			if err != nil {
				err = msgp.WrapError(err, "ProxyBytes")
				return
			}
		}
		if (zb0001Mask & 0x400000) == 0 { // if not omitted
			// write "proxyHead"
			err = en.Append(0xa9, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x48, 0x65, 0x61, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ProxyHead)
			if err != nil {
				err = msgp.WrapError(err, "ProxyHead")
				return
			}
		}
		if (zb0001Mask & 0x800000) == 0 { // if not omitted
			// write "proxyGet"
			err = en.Append(0xa8, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x47, 0x65, 0x74)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ProxyGet)
			if err != nil {
				err = msgp.WrapError(err, "ProxyGet")
				return
			}
		}
		if (zb0001Mask & 0x1000000) == 0 { // if not omitted
			// write "proxyGetTag"
			err = en.Append(0xab, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x47, 0x65, 0x74, 0x54, 0x61, 0x67)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ProxyGetTag)
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetTag")
				return
			}
		}
		if (zb0001Mask & 0x2000000) == 0 { // if not omitted
			// write "proxyHeadOK"
			err = en.Append(0xab, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x48, 0x65, 0x61, 0x64, 0x4f, 0x4b)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ProxyHeadOK)
			if err != nil {
				err = msgp.WrapError(err, "ProxyHeadOK")
				return
			}
		}
		if (zb0001Mask & 0x4000000) == 0 { // if not omitted
			// write "proxyGetOK"
			err = en.Append(0xaa, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x47, 0x65, 0x74, 0x4f, 0x4b)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ProxyGetOK)
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetOK")
				return
			}
		}
		if (zb0001Mask & 0x8000000) == 0 { // if not omitted
			// write "proxyGetTagOK"
			err = en.Append(0xad, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x47, 0x65, 0x74, 0x54, 0x61, 0x67, 0x4f, 0x4b)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.ProxyGetTagOK)
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetTagOK")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReplicationStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(28)
	var zb0001Mask uint32 /* 28 bits */
	_ = zb0001Mask
	if z.Nodes == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.StartTime == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.EndTime == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.WallTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.Events == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.Bytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.EventTimeSecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.LatencySecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	if z.MaxLatencySecs == 0 {
		zb0001Len--
		zb0001Mask |= 0x100
	}
	if z.PutObject == 0 {
		zb0001Len--
		zb0001Mask |= 0x200
	}
	if z.UpdateMeta == 0 {
		zb0001Len--
		zb0001Mask |= 0x400
	}
	if z.DelObject == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.DelTag == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.PutErrors == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	if z.UpdateMetaErrors == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.DelErrors == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.DelTagErrors == 0 {
		zb0001Len--
		zb0001Mask |= 0x10000
	}
	if z.Synced == 0 {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.AlreadyOK == 0 {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.Rejected == 0 {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.ProxyEvents == 0 {
		zb0001Len--
		zb0001Mask |= 0x100000
	}
	if z.ProxyBytes == 0 {
		zb0001Len--
		zb0001Mask |= 0x200000
	}
	if z.ProxyHead == 0 {
		zb0001Len--
		zb0001Mask |= 0x400000
	}
	if z.ProxyGet == 0 {
		zb0001Len--
		zb0001Mask |= 0x800000
	}
	if z.ProxyGetTag == 0 {
		zb0001Len--
		zb0001Mask |= 0x1000000
	}
	if z.ProxyHeadOK == 0 {
		zb0001Len--
		zb0001Mask |= 0x2000000
	}
	if z.ProxyGetOK == 0 {
		zb0001Len--
		zb0001Mask |= 0x4000000
	}
	if z.ProxyGetTagOK == 0 {
		zb0001Len--
		zb0001Mask |= 0x8000000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "nodes"
			o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
			o = msgp.AppendInt(o, z.Nodes)
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "startTime"
			o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
			if z.StartTime == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendTime(o, *z.StartTime)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "endTime"
			o = append(o, 0xa7, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65)
			if z.EndTime == nil {
				o = msgp.AppendNil(o)
			} else {
				o = msgp.AppendTime(o, *z.EndTime)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "wallTimeSecs"
			o = append(o, 0xac, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.WallTimeSecs)
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "events"
			o = append(o, 0xa6, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73)
			o = msgp.AppendInt64(o, z.Events)
		}
		if (zb0001Mask & 0x20) == 0 { // if not omitted
			// string "bytes"
			o = append(o, 0xa5, 0x62, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.Bytes)
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "timeSecs"
			o = append(o, 0xa8, 0x74, 0x69, 0x6d, 0x65, 0x53, 0x65, 0x63, 0x73)
			o = msgp.AppendFloat64(o, z.EventTimeSecs)
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "latency"
			o = append(o, 0xa7, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79)
			o = msgp.AppendFloat64(o, z.LatencySecs)
		}
		if (zb0001Mask & 0x100) == 0 { // if not omitted
			// string "maxLatency"
			o = append(o, 0xaa, 0x6d, 0x61, 0x78, 0x4c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79)
			o = msgp.AppendFloat64(o, z.MaxLatencySecs)
		}
		if (zb0001Mask & 0x200) == 0 { // if not omitted
			// string "put"
			o = append(o, 0xa3, 0x70, 0x75, 0x74)
			o = msgp.AppendInt64(o, z.PutObject)
		}
		if (zb0001Mask & 0x400) == 0 { // if not omitted
			// string "updateMeta"
			o = append(o, 0xaa, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x4d, 0x65, 0x74, 0x61)
			o = msgp.AppendInt64(o, z.UpdateMeta)
		}
		if (zb0001Mask & 0x800) == 0 { // if not omitted
			// string "del"
			o = append(o, 0xa3, 0x64, 0x65, 0x6c)
			o = msgp.AppendInt64(o, z.DelObject)
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "delTag"
			o = append(o, 0xa6, 0x64, 0x65, 0x6c, 0x54, 0x61, 0x67)
			o = msgp.AppendInt64(o, z.DelTag)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "putErrs"
			o = append(o, 0xa7, 0x70, 0x75, 0x74, 0x45, 0x72, 0x72, 0x73)
			o = msgp.AppendInt64(o, z.PutErrors)
		}
		if (zb0001Mask & 0x4000) == 0 { // if not omitted
			// string "putTagErrs"
			o = append(o, 0xaa, 0x70, 0x75, 0x74, 0x54, 0x61, 0x67, 0x45, 0x72, 0x72, 0x73)
			o = msgp.AppendInt64(o, z.UpdateMetaErrors)
		}
		if (zb0001Mask & 0x8000) == 0 { // if not omitted
			// string "delErrs"
			o = append(o, 0xa7, 0x64, 0x65, 0x6c, 0x45, 0x72, 0x72, 0x73)
			o = msgp.AppendInt64(o, z.DelErrors)
		}
		if (zb0001Mask & 0x10000) == 0 { // if not omitted
			// string "delTagErrs"
			o = append(o, 0xaa, 0x64, 0x65, 0x6c, 0x54, 0x61, 0x67, 0x45, 0x72, 0x72, 0x73)
			o = msgp.AppendInt64(o, z.DelTagErrors)
		}
		if (zb0001Mask & 0x20000) == 0 { // if not omitted
			// string "synced"
			o = append(o, 0xa6, 0x73, 0x79, 0x6e, 0x63, 0x65, 0x64)
			o = msgp.AppendInt64(o, z.Synced)
		}
		if (zb0001Mask & 0x40000) == 0 { // if not omitted
			// string "alreadyOK"
			o = append(o, 0xa9, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x4f, 0x4b)
			o = msgp.AppendInt64(o, z.AlreadyOK)
		}
		if (zb0001Mask & 0x80000) == 0 { // if not omitted
			// string "rejected"
			o = append(o, 0xa8, 0x72, 0x65, 0x6a, 0x65, 0x63, 0x74, 0x65, 0x64)
			o = msgp.AppendInt64(o, z.Rejected)
		}
		if (zb0001Mask & 0x100000) == 0 { // if not omitted
			// string "proxy"
			o = append(o, 0xa5, 0x70, 0x72, 0x6f, 0x78, 0x79)
			o = msgp.AppendInt64(o, z.ProxyEvents)
		}
		if (zb0001Mask & 0x200000) == 0 { // if not omitted
			// string "proxyBytes"
			o = append(o, 0xaa, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x42, 0x79, 0x74, 0x65, 0x73)
			o = msgp.AppendInt64(o, z.ProxyBytes)
		}
		if (zb0001Mask & 0x400000) == 0 { // if not omitted
			// string "proxyHead"
			o = append(o, 0xa9, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x48, 0x65, 0x61, 0x64)
			o = msgp.AppendInt64(o, z.ProxyHead)
		}
		if (zb0001Mask & 0x800000) == 0 { // if not omitted
			// string "proxyGet"
			o = append(o, 0xa8, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x47, 0x65, 0x74)
			o = msgp.AppendInt64(o, z.ProxyGet)
		}
		if (zb0001Mask & 0x1000000) == 0 { // if not omitted
			// string "proxyGetTag"
			o = append(o, 0xab, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x47, 0x65, 0x74, 0x54, 0x61, 0x67)
			o = msgp.AppendInt64(o, z.ProxyGetTag)
		}
		if (zb0001Mask & 0x2000000) == 0 { // if not omitted
			// string "proxyHeadOK"
			o = append(o, 0xab, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x48, 0x65, 0x61, 0x64, 0x4f, 0x4b)
			o = msgp.AppendInt64(o, z.ProxyHeadOK)
		}
		if (zb0001Mask & 0x4000000) == 0 { // if not omitted
			// string "proxyGetOK"
			o = append(o, 0xaa, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x47, 0x65, 0x74, 0x4f, 0x4b)
			o = msgp.AppendInt64(o, z.ProxyGetOK)
		}
		if (zb0001Mask & 0x8000000) == 0 { // if not omitted
			// string "proxyGetTagOK"
			o = append(o, 0xad, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x47, 0x65, 0x74, 0x54, 0x61, 0x67, 0x4f, 0x4b)
			o = msgp.AppendInt64(o, z.ProxyGetTagOK)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReplicationStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint32 /* 28 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StartTime = nil
			} else {
				if z.StartTime == nil {
					z.StartTime = new(time.Time)
				}
				*z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StartTime")
					return
				}
			}
			zb0001Mask |= 0x2
		case "endTime":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EndTime = nil
			} else {
				if z.EndTime == nil {
					z.EndTime = new(time.Time)
				}
				*z.EndTime, bts, err = msgp.ReadTimeUTCBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EndTime")
					return
				}
			}
			zb0001Mask |= 0x4
		case "wallTimeSecs":
			z.WallTimeSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WallTimeSecs")
				return
			}
			zb0001Mask |= 0x8
		case "events":
			z.Events, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Events")
				return
			}
			zb0001Mask |= 0x10
		case "bytes":
			z.Bytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bytes")
				return
			}
			zb0001Mask |= 0x20
		case "timeSecs":
			z.EventTimeSecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EventTimeSecs")
				return
			}
			zb0001Mask |= 0x40
		case "latency":
			z.LatencySecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LatencySecs")
				return
			}
			zb0001Mask |= 0x80
		case "maxLatency":
			z.MaxLatencySecs, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxLatencySecs")
				return
			}
			zb0001Mask |= 0x100
		case "put":
			z.PutObject, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PutObject")
				return
			}
			zb0001Mask |= 0x200
		case "updateMeta":
			z.UpdateMeta, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UpdateMeta")
				return
			}
			zb0001Mask |= 0x400
		case "del":
			z.DelObject, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DelObject")
				return
			}
			zb0001Mask |= 0x800
		case "delTag":
			z.DelTag, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DelTag")
				return
			}
			zb0001Mask |= 0x1000
		case "putErrs":
			z.PutErrors, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PutErrors")
				return
			}
			zb0001Mask |= 0x2000
		case "putTagErrs":
			z.UpdateMetaErrors, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UpdateMetaErrors")
				return
			}
			zb0001Mask |= 0x4000
		case "delErrs":
			z.DelErrors, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DelErrors")
				return
			}
			zb0001Mask |= 0x8000
		case "delTagErrs":
			z.DelTagErrors, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DelTagErrors")
				return
			}
			zb0001Mask |= 0x10000
		case "synced":
			z.Synced, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Synced")
				return
			}
			zb0001Mask |= 0x20000
		case "alreadyOK":
			z.AlreadyOK, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AlreadyOK")
				return
			}
			zb0001Mask |= 0x40000
		case "rejected":
			z.Rejected, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Rejected")
				return
			}
			zb0001Mask |= 0x80000
		case "proxy":
			z.ProxyEvents, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProxyEvents")
				return
			}
			zb0001Mask |= 0x100000
		case "proxyBytes":
			z.ProxyBytes, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProxyBytes")
				return
			}
			zb0001Mask |= 0x200000
		case "proxyHead":
			z.ProxyHead, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProxyHead")
				return
			}
			zb0001Mask |= 0x400000
		case "proxyGet":
			z.ProxyGet, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProxyGet")
				return
			}
			zb0001Mask |= 0x800000
		case "proxyGetTag":
			z.ProxyGetTag, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetTag")
				return
			}
			zb0001Mask |= 0x1000000
		case "proxyHeadOK":
			z.ProxyHeadOK, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProxyHeadOK")
				return
			}
			zb0001Mask |= 0x2000000
		case "proxyGetOK":
			z.ProxyGetOK, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetOK")
				return
			}
			zb0001Mask |= 0x4000000
		case "proxyGetTagOK":
			z.ProxyGetTagOK, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProxyGetTagOK")
				return
			}
			zb0001Mask |= 0x8000000
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0xfffffff {
		if (zb0001Mask & 0x1) == 0 {
			z.Nodes = 0
		}
		if (zb0001Mask & 0x2) == 0 {
			z.StartTime = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.EndTime = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.WallTimeSecs = 0
		}
		if (zb0001Mask & 0x10) == 0 {
			z.Events = 0
		}
		if (zb0001Mask & 0x20) == 0 {
			z.Bytes = 0
		}
		if (zb0001Mask & 0x40) == 0 {
			z.EventTimeSecs = 0
		}
		if (zb0001Mask & 0x80) == 0 {
			z.LatencySecs = 0
		}
		if (zb0001Mask & 0x100) == 0 {
			z.MaxLatencySecs = 0
		}
		if (zb0001Mask & 0x200) == 0 {
			z.PutObject = 0
		}
		if (zb0001Mask & 0x400) == 0 {
			z.UpdateMeta = 0
		}
		if (zb0001Mask & 0x800) == 0 {
			z.DelObject = 0
		}
		if (zb0001Mask & 0x1000) == 0 {
			z.DelTag = 0
		}
		if (zb0001Mask & 0x2000) == 0 {
			z.PutErrors = 0
		}
		if (zb0001Mask & 0x4000) == 0 {
			z.UpdateMetaErrors = 0
		}
		if (zb0001Mask & 0x8000) == 0 {
			z.DelErrors = 0
		}
		if (zb0001Mask & 0x10000) == 0 {
			z.DelTagErrors = 0
		}
		if (zb0001Mask & 0x20000) == 0 {
			z.Synced = 0
		}
		if (zb0001Mask & 0x40000) == 0 {
			z.AlreadyOK = 0
		}
		if (zb0001Mask & 0x80000) == 0 {
			z.Rejected = 0
		}
		if (zb0001Mask & 0x100000) == 0 {
			z.ProxyEvents = 0
		}
		if (zb0001Mask & 0x200000) == 0 {
			z.ProxyBytes = 0
		}
		if (zb0001Mask & 0x400000) == 0 {
			z.ProxyHead = 0
		}
		if (zb0001Mask & 0x800000) == 0 {
			z.ProxyGet = 0
		}
		if (zb0001Mask & 0x1000000) == 0 {
			z.ProxyGetTag = 0
		}
		if (zb0001Mask & 0x2000000) == 0 {
			z.ProxyHeadOK = 0
		}
		if (zb0001Mask & 0x4000000) == 0 {
			z.ProxyGetOK = 0
		}
		if (zb0001Mask & 0x8000000) == 0 {
			z.ProxyGetTagOK = 0
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReplicationStats) Msgsize() (s int) {
	s = 3 + 6 + msgp.IntSize + 10
	if z.StartTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 8
	if z.EndTime == nil {
		s += msgp.NilSize
	} else {
		s += msgp.TimeSize
	}
	s += 13 + msgp.Float64Size + 7 + msgp.Int64Size + 6 + msgp.Int64Size + 9 + msgp.Float64Size + 8 + msgp.Float64Size + 11 + msgp.Float64Size + 4 + msgp.Int64Size + 11 + msgp.Int64Size + 4 + msgp.Int64Size + 7 + msgp.Int64Size + 8 + msgp.Int64Size + 11 + msgp.Int64Size + 8 + msgp.Int64Size + 11 + msgp.Int64Size + 7 + msgp.Int64Size + 10 + msgp.Int64Size + 9 + msgp.Int64Size + 6 + msgp.Int64Size + 11 + msgp.Int64Size + 10 + msgp.Int64Size + 9 + msgp.Int64Size + 12 + msgp.Int64Size + 12 + msgp.Int64Size + 11 + msgp.Int64Size + 14 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ReplicationTargetStats) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "last_hour":
			err = z.LastHour.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "LastHour")
				return
			}
			zb0001Mask |= 0x1
		case "last_day":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "LastDay")
					return
				}
				z.LastDay = nil
			} else {
				if z.LastDay == nil {
					z.LastDay = new(SegmentedReplicationStats)
				}
				err = (*Segmented[ReplicationStats, *ReplicationStats])(z.LastDay).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "LastDay")
					return
				}
			}
			zb0001Mask |= 0x2
		case "since_start":
			err = z.SinceStart.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "SinceStart")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.LastHour = ReplicationStats{}
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LastDay = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ReplicationTargetStats) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.LastDay == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "nodes"
		err = en.Append(0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Nodes)
		if err != nil {
			err = msgp.WrapError(err, "Nodes")
			return
		}
		// write "last_hour"
		err = en.Append(0xa9, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x68, 0x6f, 0x75, 0x72)
		if err != nil {
			return
		}
		err = z.LastHour.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "LastHour")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "last_day"
			err = en.Append(0xa8, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x64, 0x61, 0x79)
			if err != nil {
				return
			}
			if z.LastDay == nil {
				err = en.WriteNil()
				if err != nil {
					return
				}
			} else {
				err = (*Segmented[ReplicationStats, *ReplicationStats])(z.LastDay).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "LastDay")
					return
				}
			}
		}
		// write "since_start"
		err = en.Append(0xab, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74)
		if err != nil {
			return
		}
		err = z.SinceStart.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "SinceStart")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ReplicationTargetStats) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.LastDay == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "nodes"
		o = append(o, 0xa5, 0x6e, 0x6f, 0x64, 0x65, 0x73)
		o = msgp.AppendInt(o, z.Nodes)
		// string "last_hour"
		o = append(o, 0xa9, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x68, 0x6f, 0x75, 0x72)
		o, err = z.LastHour.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "LastHour")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "last_day"
			o = append(o, 0xa8, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x64, 0x61, 0x79)
			if z.LastDay == nil {
				o = msgp.AppendNil(o)
			} else {
				o, err = (*Segmented[ReplicationStats, *ReplicationStats])(z.LastDay).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "LastDay")
					return
				}
			}
		}
		// string "since_start"
		o = append(o, 0xab, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74)
		o, err = z.SinceStart.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "SinceStart")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ReplicationTargetStats) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "nodes":
			z.Nodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Nodes")
				return
			}
		case "last_hour":
			bts, err = z.LastHour.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastHour")
				return
			}
			zb0001Mask |= 0x1
		case "last_day":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.LastDay = nil
			} else {
				if z.LastDay == nil {
					z.LastDay = new(SegmentedReplicationStats)
				}
				bts, err = (*Segmented[ReplicationStats, *ReplicationStats])(z.LastDay).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastDay")
					return
				}
			}
			zb0001Mask |= 0x2
		case "since_start":
			bts, err = z.SinceStart.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "SinceStart")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.LastHour = ReplicationStats{}
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LastDay = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ReplicationTargetStats) Msgsize() (s int) {
	s = 1 + 6 + msgp.IntSize + 10 + z.LastHour.Msgsize() + 9
	if z.LastDay == nil {
		s += msgp.NilSize
	} else {
		s += (*Segmented[ReplicationStats, *ReplicationStats])(z.LastDay).Msgsize()
	}
	s += 12 + z.SinceStart.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *RuntimeMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uintMetrics":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			if z.UintMetrics == nil {
				z.UintMetrics = make(map[string]uint64, zb0002)
			} else if len(z.UintMetrics) > 0 {
				clear(z.UintMetrics)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				var za0002 uint64
				za0002, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
				z.UintMetrics[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "floatMetrics":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			if z.FloatMetrics == nil {
				z.FloatMetrics = make(map[string]float64, zb0003)
			} else if len(z.FloatMetrics) > 0 {
				clear(z.FloatMetrics)
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				var za0004 float64
				za0004, err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
				z.FloatMetrics[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "histMetrics":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			if z.HistMetrics == nil {
				z.HistMetrics = make(map[string]metrics.Float64Histogram, zb0004)
			} else if len(z.HistMetrics) > 0 {
				clear(z.HistMetrics)
			}
			for zb0004 > 0 {
				zb0004--
				var za0005 string
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				var za0006 metrics.Float64Histogram
				err = (*localF64H)(&za0006).DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
				z.HistMetrics[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "n":
			z.N, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.UintMetrics = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.FloatMetrics = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.HistMetrics = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *RuntimeMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.UintMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.FloatMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.HistMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "uintMetrics"
			err = en.Append(0xab, 0x75, 0x69, 0x6e, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.UintMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			for za0001, za0002 := range z.UintMetrics {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				err = en.WriteUint64(za0002)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "floatMetrics"
			err = en.Append(0xac, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.FloatMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			for za0003, za0004 := range z.FloatMetrics {
				err = en.WriteString(za0003)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				err = en.WriteFloat64(za0004)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "histMetrics"
			err = en.Append(0xab, 0x68, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.HistMetrics)))
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			for za0005, za0006 := range z.HistMetrics {
				err = en.WriteString(za0005)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				err = (*localF64H)(&za0006).EncodeMsg(en)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
			}
		}
		// write "n"
		err = en.Append(0xa1, 0x6e)
		if err != nil {
			return
		}
		err = en.WriteInt(z.N)
		if err != nil {
			err = msgp.WrapError(err, "N")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *RuntimeMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 4 bits */
	_ = zb0001Mask
	if z.UintMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.FloatMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.HistMetrics == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "uintMetrics"
			o = append(o, 0xab, 0x75, 0x69, 0x6e, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.UintMetrics)))
			for za0001, za0002 := range z.UintMetrics {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendUint64(o, za0002)
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "floatMetrics"
			o = append(o, 0xac, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.FloatMetrics)))
			for za0003, za0004 := range z.FloatMetrics {
				o = msgp.AppendString(o, za0003)
				o = msgp.AppendFloat64(o, za0004)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "histMetrics"
			o = append(o, 0xab, 0x68, 0x69, 0x73, 0x74, 0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.HistMetrics)))
			for za0005, za0006 := range z.HistMetrics {
				o = msgp.AppendString(o, za0005)
				o, err = (*localF64H)(&za0006).MarshalMsg(o)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
			}
		}
		// string "n"
		o = append(o, 0xa1, 0x6e)
		o = msgp.AppendInt(o, z.N)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *RuntimeMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uintMetrics":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UintMetrics")
				return
			}
			if z.UintMetrics == nil {
				z.UintMetrics = make(map[string]uint64, zb0002)
			} else if len(z.UintMetrics) > 0 {
				clear(z.UintMetrics)
			}
			for zb0002 > 0 {
				var za0002 uint64
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics")
					return
				}
				za0002, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UintMetrics", za0001)
					return
				}
				z.UintMetrics[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "floatMetrics":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FloatMetrics")
				return
			}
			if z.FloatMetrics == nil {
				z.FloatMetrics = make(map[string]float64, zb0003)
			} else if len(z.FloatMetrics) > 0 {
				clear(z.FloatMetrics)
			}
			for zb0003 > 0 {
				var za0004 float64
				zb0003--
				var za0003 string
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics")
					return
				}
				za0004, bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FloatMetrics", za0003)
					return
				}
				z.FloatMetrics[za0003] = za0004
			}
			zb0001Mask |= 0x2
		case "histMetrics":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HistMetrics")
				return
			}
			if z.HistMetrics == nil {
				z.HistMetrics = make(map[string]metrics.Float64Histogram, zb0004)
			} else if len(z.HistMetrics) > 0 {
				clear(z.HistMetrics)
			}
			for zb0004 > 0 {
				var za0006 metrics.Float64Histogram
				zb0004--
				var za0005 string
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics")
					return
				}
				bts, err = (*localF64H)(&za0006).UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "HistMetrics", za0005)
					return
				}
				z.HistMetrics[za0005] = za0006
			}
			zb0001Mask |= 0x4
		case "n":
			z.N, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "N")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.UintMetrics = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.FloatMetrics = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.HistMetrics = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *RuntimeMetrics) Msgsize() (s int) {
	s = 1 + 12 + msgp.MapHeaderSize
	if z.UintMetrics != nil {
		for za0001, za0002 := range z.UintMetrics {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.Uint64Size
		}
	}
	s += 13 + msgp.MapHeaderSize
	if z.FloatMetrics != nil {
		for za0003, za0004 := range z.FloatMetrics {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.Float64Size
		}
	}
	s += 12 + msgp.MapHeaderSize
	if z.HistMetrics != nil {
		for za0005, za0006 := range z.HistMetrics {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + (*localF64H)(&za0006).Msgsize()
		}
	}
	s += 2 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ScannerMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "ongoing_buckets":
			z.OngoingBuckets, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OngoingBuckets")
				return
			}
		case "per_bucket_stats":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			if z.PerBucketStats == nil {
				z.PerBucketStats = make(map[string][]BucketScanInfo, zb0002)
			} else if len(z.PerBucketStats) > 0 {
				clear(z.PerBucketStats)
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				var za0002 []BucketScanInfo
				var zb0003 uint32
				zb0003, err = dc.ReadArrayHeader()
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0001)
					return
				}
				if cap(za0002) >= int(zb0003) {
					za0002 = (za0002)[:zb0003]
				} else {
					za0002 = make([]BucketScanInfo, zb0003)
				}
				for za0003 := range za0002 {
					err = za0002[za0003].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0001, za0003)
						return
					}
				}
				z.PerBucketStats[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "life_time_ops":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0004)
			} else if len(z.LifeTimeOps) > 0 {
				clear(z.LifeTimeOps)
			}
			for zb0004 > 0 {
				zb0004--
				var za0004 string
				za0004, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				var za0005 uint64
				za0005, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0004)
					return
				}
				z.LifeTimeOps[za0004] = za0005
			}
			zb0001Mask |= 0x2
		case "ilm_ops":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			if z.LifeTimeILM == nil {
				z.LifeTimeILM = make(map[string]uint64, zb0005)
			} else if len(z.LifeTimeILM) > 0 {
				clear(z.LifeTimeILM)
			}
			for zb0005 > 0 {
				zb0005--
				var za0006 string
				za0006, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				var za0007 uint64
				za0007, err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0006)
					return
				}
				z.LifeTimeILM[za0006] = za0007
			}
			zb0001Mask |= 0x4
		case "last_minute":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0006Mask uint8 /* 2 bits */
			_ = zb0006Mask
			for zb0006 > 0 {
				zb0006--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "actions":
					var zb0007 uint32
					zb0007, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					if z.LastMinute.Actions == nil {
						z.LastMinute.Actions = make(map[string]TimedAction, zb0007)
					} else if len(z.LastMinute.Actions) > 0 {
						clear(z.LastMinute.Actions)
					}
					for zb0007 > 0 {
						zb0007--
						var za0008 string
						za0008, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions")
							return
						}
						var za0009 TimedAction
						err = za0009.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions", za0008)
							return
						}
						z.LastMinute.Actions[za0008] = za0009
					}
					zb0006Mask |= 0x1
				case "ilm":
					var zb0008 uint32
					zb0008, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					if z.LastMinute.ILM == nil {
						z.LastMinute.ILM = make(map[string]TimedAction, zb0008)
					} else if len(z.LastMinute.ILM) > 0 {
						clear(z.LastMinute.ILM)
					}
					for zb0008 > 0 {
						zb0008--
						var za0010 string
						za0010, err = dc.ReadString()
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM")
							return
						}
						var za0011 TimedAction
						err = za0011.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM", za0010)
							return
						}
						z.LastMinute.ILM[za0010] = za0011
					}
					zb0006Mask |= 0x2
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0006Mask != 0x3 {
				if (zb0006Mask & 0x1) == 0 {
					z.LastMinute.Actions = nil
				}
				if (zb0006Mask & 0x2) == 0 {
					z.LastMinute.ILM = nil
				}
			}
		case "active":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			if cap(z.ActivePaths) >= int(zb0009) {
				z.ActivePaths = (z.ActivePaths)[:zb0009]
			} else {
				z.ActivePaths = make([]string, zb0009)
			}
			for za0012 := range z.ActivePaths {
				z.ActivePaths[za0012], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0012)
					return
				}
			}
			zb0001Mask |= 0x8
		case "excessive":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ExcessivePrefixes")
				return
			}
			if cap(z.ExcessivePrefixes) >= int(zb0010) {
				z.ExcessivePrefixes = (z.ExcessivePrefixes)[:zb0010]
			} else {
				z.ExcessivePrefixes = make([]string, zb0010)
			}
			for za0013 := range z.ExcessivePrefixes {
				z.ExcessivePrefixes[za0013], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ExcessivePrefixes", za0013)
					return
				}
			}
			zb0001Mask |= 0x10
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.PerBucketStats = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LifeTimeILM = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ActivePaths = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.ExcessivePrefixes = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ScannerMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(8)
	var zb0001Mask uint8 /* 8 bits */
	_ = zb0001Mask
	if z.PerBucketStats == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LifeTimeILM == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.ActivePaths == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.ExcessivePrefixes == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		// write "ongoing_buckets"
		err = en.Append(0xaf, 0x6f, 0x6e, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt(z.OngoingBuckets)
		if err != nil {
			err = msgp.WrapError(err, "OngoingBuckets")
			return
		}
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// write "per_bucket_stats"
			err = en.Append(0xb0, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.PerBucketStats)))
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			for za0001, za0002 := range z.PerBucketStats {
				err = en.WriteString(za0001)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				err = en.WriteArrayHeader(uint32(len(za0002)))
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0001)
					return
				}
				for za0003 := range za0002 {
					err = za0002[za0003].EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0001, za0003)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// write "life_time_ops"
			err = en.Append(0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeOps)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			for za0004, za0005 := range z.LifeTimeOps {
				err = en.WriteString(za0004)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				err = en.WriteUint64(za0005)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0004)
					return
				}
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "ilm_ops"
			err = en.Append(0xa7, 0x69, 0x6c, 0x6d, 0x5f, 0x6f, 0x70, 0x73)
			if err != nil {
				return
			}
			err = en.WriteMapHeader(uint32(len(z.LifeTimeILM)))
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			for za0006, za0007 := range z.LifeTimeILM {
				err = en.WriteString(za0006)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				err = en.WriteUint64(za0007)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0006)
					return
				}
			}
		}
		// write "last_minute"
		err = en.Append(0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		if err != nil {
			return
		}
		// check for omitted fields
		zb0002Len := uint32(2)
		var zb0002Mask uint8 /* 2 bits */
		_ = zb0002Mask
		if z.LastMinute.Actions == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		if z.LastMinute.ILM == nil {
			zb0002Len--
			zb0002Mask |= 0x2
		}
		// variable map header, size zb0002Len
		err = en.Append(0x80 | uint8(zb0002Len))
		if err != nil {
			return
		}

		// skip if no fields are to be emitted
		if zb0002Len != 0 {
			if (zb0002Mask & 0x1) == 0 { // if not omitted
				// write "actions"
				err = en.Append(0xa7, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
				if err != nil {
					return
				}
				err = en.WriteMapHeader(uint32(len(z.LastMinute.Actions)))
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "Actions")
					return
				}
				for za0008, za0009 := range z.LastMinute.Actions {
					err = en.WriteString(za0008)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					err = za0009.EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions", za0008)
						return
					}
				}
			}
			if (zb0002Mask & 0x2) == 0 { // if not omitted
				// write "ilm"
				err = en.Append(0xa3, 0x69, 0x6c, 0x6d)
				if err != nil {
					return
				}
				err = en.WriteMapHeader(uint32(len(z.LastMinute.ILM)))
				if err != nil {
					err = msgp.WrapError(err, "LastMinute", "ILM")
					return
				}
				for za0010, za0011 := range z.LastMinute.ILM {
					err = en.WriteString(za0010)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					err = za0011.EncodeMsg(en)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM", za0010)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// write "active"
			err = en.Append(0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.ActivePaths)))
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			for za0012 := range z.ActivePaths {
				err = en.WriteString(z.ActivePaths[za0012])
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0012)
					return
				}
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// write "excessive"
			err = en.Append(0xa9, 0x65, 0x78, 0x63, 0x65, 0x73, 0x73, 0x69, 0x76, 0x65)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.ExcessivePrefixes)))
			if err != nil {
				err = msgp.WrapError(err, "ExcessivePrefixes")
				return
			}
			for za0013 := range z.ExcessivePrefixes {
				err = en.WriteString(z.ExcessivePrefixes[za0013])
				if err != nil {
					err = msgp.WrapError(err, "ExcessivePrefixes", za0013)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ScannerMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(8)
	var zb0001Mask uint8 /* 8 bits */
	_ = zb0001Mask
	if z.PerBucketStats == nil {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.LifeTimeOps == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.LifeTimeILM == nil {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.ActivePaths == nil {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.ExcessivePrefixes == nil {
		zb0001Len--
		zb0001Mask |= 0x80
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		// string "ongoing_buckets"
		o = append(o, 0xaf, 0x6f, 0x6e, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendInt(o, z.OngoingBuckets)
		if (zb0001Mask & 0x4) == 0 { // if not omitted
			// string "per_bucket_stats"
			o = append(o, 0xb0, 0x70, 0x65, 0x72, 0x5f, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.PerBucketStats)))
			for za0001, za0002 := range z.PerBucketStats {
				o = msgp.AppendString(o, za0001)
				o = msgp.AppendArrayHeader(o, uint32(len(za0002)))
				for za0003 := range za0002 {
					o, err = za0002[za0003].MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0001, za0003)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not omitted
			// string "life_time_ops"
			o = append(o, 0xad, 0x6c, 0x69, 0x66, 0x65, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeOps)))
			for za0004, za0005 := range z.LifeTimeOps {
				o = msgp.AppendString(o, za0004)
				o = msgp.AppendUint64(o, za0005)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "ilm_ops"
			o = append(o, 0xa7, 0x69, 0x6c, 0x6d, 0x5f, 0x6f, 0x70, 0x73)
			o = msgp.AppendMapHeader(o, uint32(len(z.LifeTimeILM)))
			for za0006, za0007 := range z.LifeTimeILM {
				o = msgp.AppendString(o, za0006)
				o = msgp.AppendUint64(o, za0007)
			}
		}
		// string "last_minute"
		o = append(o, 0xab, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65)
		// check for omitted fields
		zb0002Len := uint32(2)
		var zb0002Mask uint8 /* 2 bits */
		_ = zb0002Mask
		if z.LastMinute.Actions == nil {
			zb0002Len--
			zb0002Mask |= 0x1
		}
		if z.LastMinute.ILM == nil {
			zb0002Len--
			zb0002Mask |= 0x2
		}
		// variable map header, size zb0002Len
		o = append(o, 0x80|uint8(zb0002Len))

		// skip if no fields are to be emitted
		if zb0002Len != 0 {
			if (zb0002Mask & 0x1) == 0 { // if not omitted
				// string "actions"
				o = append(o, 0xa7, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
				o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.Actions)))
				for za0008, za0009 := range z.LastMinute.Actions {
					o = msgp.AppendString(o, za0008)
					o, err = za0009.MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions", za0008)
						return
					}
				}
			}
			if (zb0002Mask & 0x2) == 0 { // if not omitted
				// string "ilm"
				o = append(o, 0xa3, 0x69, 0x6c, 0x6d)
				o = msgp.AppendMapHeader(o, uint32(len(z.LastMinute.ILM)))
				for za0010, za0011 := range z.LastMinute.ILM {
					o = msgp.AppendString(o, za0010)
					o, err = za0011.MarshalMsg(o)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM", za0010)
						return
					}
				}
			}
		}
		if (zb0001Mask & 0x40) == 0 { // if not omitted
			// string "active"
			o = append(o, 0xa6, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65)
			o = msgp.AppendArrayHeader(o, uint32(len(z.ActivePaths)))
			for za0012 := range z.ActivePaths {
				o = msgp.AppendString(o, z.ActivePaths[za0012])
			}
		}
		if (zb0001Mask & 0x80) == 0 { // if not omitted
			// string "excessive"
			o = append(o, 0xa9, 0x65, 0x78, 0x63, 0x65, 0x73, 0x73, 0x69, 0x76, 0x65)
			o = msgp.AppendArrayHeader(o, uint32(len(z.ExcessivePrefixes)))
			for za0013 := range z.ExcessivePrefixes {
				o = msgp.AppendString(o, z.ExcessivePrefixes[za0013])
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ScannerMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "ongoing_buckets":
			z.OngoingBuckets, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OngoingBuckets")
				return
			}
		case "per_bucket_stats":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PerBucketStats")
				return
			}
			if z.PerBucketStats == nil {
				z.PerBucketStats = make(map[string][]BucketScanInfo, zb0002)
			} else if len(z.PerBucketStats) > 0 {
				clear(z.PerBucketStats)
			}
			for zb0002 > 0 {
				var za0002 []BucketScanInfo
				zb0002--
				var za0001 string
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats")
					return
				}
				var zb0003 uint32
				zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PerBucketStats", za0001)
					return
				}
				if cap(za0002) >= int(zb0003) {
					za0002 = (za0002)[:zb0003]
				} else {
					za0002 = make([]BucketScanInfo, zb0003)
				}
				for za0003 := range za0002 {
					bts, err = za0002[za0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "PerBucketStats", za0001, za0003)
						return
					}
				}
				z.PerBucketStats[za0001] = za0002
			}
			zb0001Mask |= 0x1
		case "life_time_ops":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeOps")
				return
			}
			if z.LifeTimeOps == nil {
				z.LifeTimeOps = make(map[string]uint64, zb0004)
			} else if len(z.LifeTimeOps) > 0 {
				clear(z.LifeTimeOps)
			}
			for zb0004 > 0 {
				var za0005 uint64
				zb0004--
				var za0004 string
				za0004, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps")
					return
				}
				za0005, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeOps", za0004)
					return
				}
				z.LifeTimeOps[za0004] = za0005
			}
			zb0001Mask |= 0x2
		case "ilm_ops":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeTimeILM")
				return
			}
			if z.LifeTimeILM == nil {
				z.LifeTimeILM = make(map[string]uint64, zb0005)
			} else if len(z.LifeTimeILM) > 0 {
				clear(z.LifeTimeILM)
			}
			for zb0005 > 0 {
				var za0007 uint64
				zb0005--
				var za0006 string
				za0006, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM")
					return
				}
				za0007, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "LifeTimeILM", za0006)
					return
				}
				z.LifeTimeILM[za0006] = za0007
			}
			zb0001Mask |= 0x4
		case "last_minute":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastMinute")
				return
			}
			var zb0006Mask uint8 /* 2 bits */
			_ = zb0006Mask
			for zb0006 > 0 {
				zb0006--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "LastMinute")
					return
				}
				switch msgp.UnsafeString(field) {
				case "actions":
					var zb0007 uint32
					zb0007, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "Actions")
						return
					}
					if z.LastMinute.Actions == nil {
						z.LastMinute.Actions = make(map[string]TimedAction, zb0007)
					} else if len(z.LastMinute.Actions) > 0 {
						clear(z.LastMinute.Actions)
					}
					for zb0007 > 0 {
						var za0009 TimedAction
						zb0007--
						var za0008 string
						za0008, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions")
							return
						}
						bts, err = za0009.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "Actions", za0008)
							return
						}
						z.LastMinute.Actions[za0008] = za0009
					}
					zb0006Mask |= 0x1
				case "ilm":
					var zb0008 uint32
					zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute", "ILM")
						return
					}
					if z.LastMinute.ILM == nil {
						z.LastMinute.ILM = make(map[string]TimedAction, zb0008)
					} else if len(z.LastMinute.ILM) > 0 {
						clear(z.LastMinute.ILM)
					}
					for zb0008 > 0 {
						var za0011 TimedAction
						zb0008--
						var za0010 string
						za0010, bts, err = msgp.ReadStringBytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM")
							return
						}
						bts, err = za0011.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "LastMinute", "ILM", za0010)
							return
						}
						z.LastMinute.ILM[za0010] = za0011
					}
					zb0006Mask |= 0x2
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "LastMinute")
						return
					}
				}
			}
			// Clear omitted fields.
			if zb0006Mask != 0x3 {
				if (zb0006Mask & 0x1) == 0 {
					z.LastMinute.Actions = nil
				}
				if (zb0006Mask & 0x2) == 0 {
					z.LastMinute.ILM = nil
				}
			}
		case "active":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActivePaths")
				return
			}
			if cap(z.ActivePaths) >= int(zb0009) {
				z.ActivePaths = (z.ActivePaths)[:zb0009]
			} else {
				z.ActivePaths = make([]string, zb0009)
			}
			for za0012 := range z.ActivePaths {
				z.ActivePaths[za0012], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ActivePaths", za0012)
					return
				}
			}
			zb0001Mask |= 0x8
		case "excessive":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExcessivePrefixes")
				return
			}
			if cap(z.ExcessivePrefixes) >= int(zb0010) {
				z.ExcessivePrefixes = (z.ExcessivePrefixes)[:zb0010]
			} else {
				z.ExcessivePrefixes = make([]string, zb0010)
			}
			for za0013 := range z.ExcessivePrefixes {
				z.ExcessivePrefixes[za0013], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExcessivePrefixes", za0013)
					return
				}
			}
			zb0001Mask |= 0x10
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x1f {
		if (zb0001Mask & 0x1) == 0 {
			z.PerBucketStats = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.LifeTimeOps = nil
		}
		if (zb0001Mask & 0x4) == 0 {
			z.LifeTimeILM = nil
		}
		if (zb0001Mask & 0x8) == 0 {
			z.ActivePaths = nil
		}
		if (zb0001Mask & 0x10) == 0 {
			z.ExcessivePrefixes = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ScannerMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 16 + msgp.IntSize + 17 + msgp.MapHeaderSize
	if z.PerBucketStats != nil {
		for za0001, za0002 := range z.PerBucketStats {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.ArrayHeaderSize
			for za0003 := range za0002 {
				s += za0002[za0003].Msgsize()
			}
		}
	}
	s += 14 + msgp.MapHeaderSize
	if z.LifeTimeOps != nil {
		for za0004, za0005 := range z.LifeTimeOps {
			_ = za0005
			s += msgp.StringPrefixSize + len(za0004) + msgp.Uint64Size
		}
	}
	s += 8 + msgp.MapHeaderSize
	if z.LifeTimeILM != nil {
		for za0006, za0007 := range z.LifeTimeILM {
			_ = za0007
			s += msgp.StringPrefixSize + len(za0006) + msgp.Uint64Size
		}
	}
	s += 12 + 1 + 8 + msgp.MapHeaderSize
	if z.LastMinute.Actions != nil {
		for za0008, za0009 := range z.LastMinute.Actions {
			_ = za0009
			s += msgp.StringPrefixSize + len(za0008) + za0009.Msgsize()
		}
	}
	s += 4 + msgp.MapHeaderSize
	if z.LastMinute.ILM != nil {
		for za0010, za0011 := range z.LastMinute.ILM {
			_ = za0011
			s += msgp.StringPrefixSize + len(za0010) + za0011.Msgsize()
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0012 := range z.ActivePaths {
		s += msgp.StringPrefixSize + len(z.ActivePaths[za0012])
	}
	s += 10 + msgp.ArrayHeaderSize
	for za0013 := range z.ExcessivePrefixes {
		s += msgp.StringPrefixSize + len(z.ExcessivePrefixes[za0013])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SensorMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "min_temp":
			z.MinTemp, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MinTemp")
				return
			}
		case "max_temp":
			z.MaxTemp, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "MaxTemp")
				return
			}
		case "total_temp":
			z.TotalTemp, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "TotalTemp")
				return
			}
		case "count":
			z.Count, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "exceeds_critical":
			z.ExceedsCritical, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ExceedsCritical")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.ExceedsCritical = 0
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z *SensorMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.ExceedsCritical == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "min_temp"
		err = en.Append(0xa8, 0x6d, 0x69, 0x6e, 0x5f, 0x74, 0x65, 0x6d, 0x70)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.MinTemp)
		if err != nil {
			err = msgp.WrapError(err, "MinTemp")
			return
		}
		// write "max_temp"
		err = en.Append(0xa8, 0x6d, 0x61, 0x78, 0x5f, 0x74, 0x65, 0x6d, 0x70)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.MaxTemp)
		if err != nil {
			err = msgp.WrapError(err, "MaxTemp")
			return
		}
		// write "total_temp"
		err = en.Append(0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x65, 0x6d, 0x70)
		if err != nil {
			return
		}
		err = en.WriteFloat64(z.TotalTemp)
		if err != nil {
			err = msgp.WrapError(err, "TotalTemp")
			return
		}
		// write "count"
		err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt(z.Count)
		if err != nil {
			err = msgp.WrapError(err, "Count")
			return
		}
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// write "exceeds_critical"
			err = en.Append(0xb0, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64, 0x73, 0x5f, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c)
			if err != nil {
				return
			}
			err = en.WriteInt(z.ExceedsCritical)
			if err != nil {
				err = msgp.WrapError(err, "ExceedsCritical")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SensorMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(5)
	var zb0001Mask uint8 /* 5 bits */
	_ = zb0001Mask
	if z.ExceedsCritical == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "min_temp"
		o = append(o, 0xa8, 0x6d, 0x69, 0x6e, 0x5f, 0x74, 0x65, 0x6d, 0x70)
		o = msgp.AppendFloat64(o, z.MinTemp)
		// string "max_temp"
		o = append(o, 0xa8, 0x6d, 0x61, 0x78, 0x5f, 0x74, 0x65, 0x6d, 0x70)
		o = msgp.AppendFloat64(o, z.MaxTemp)
		// string "total_temp"
		o = append(o, 0xaa, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x74, 0x65, 0x6d, 0x70)
		o = msgp.AppendFloat64(o, z.TotalTemp)
		// string "count"
		o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt(o, z.Count)
		if (zb0001Mask & 0x10) == 0 { // if not omitted
			// string "exceeds_critical"
			o = append(o, 0xb0, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64, 0x73, 0x5f, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c)
			o = msgp.AppendInt(o, z.ExceedsCritical)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SensorMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "min_temp":
			z.MinTemp, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinTemp")
				return
			}
		case "max_temp":
			z.MaxTemp, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxTemp")
				return
			}
		case "total_temp":
			z.TotalTemp, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalTemp")
				return
			}
		case "count":
			z.Count, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		case "exceeds_critical":
			z.ExceedsCritical, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExceedsCritical")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.ExceedsCritical = 0
	}

	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SensorMetrics) Msgsize() (s int) {
	s = 1 + 9 + msgp.Float64Size + 9 + msgp.Float64Size + 11 + msgp.Float64Size + 6 + msgp.IntSize + 17 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SiteResyncMetrics) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "resyncStatus":
			z.ResyncStatus, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			z.StartTime, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, err = dc.ReadTimeUTC()
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "numBuckets":
			z.NumBuckets, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "NumBuckets")
				return
			}
		case "resyncID":
			z.ResyncID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ResyncID")
				return
			}
		case "deplID":
			z.DeplID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DeplID")
				return
			}
		case "completedReplicationSize":
			z.ReplicatedSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "replicationCount":
			z.ReplicatedCount, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedCount")
				return
			}
		case "failedReplicationSize":
			z.FailedSize, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FailedSize")
				return
			}
		case "failedReplicationCount":
			z.FailedCount, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "FailedCount")
				return
			}
		case "failedBuckets":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets")
				return
			}
			if cap(z.FailedBuckets) >= int(zb0002) {
				z.FailedBuckets = (z.FailedBuckets)[:zb0002]
			} else {
				z.FailedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.FailedBuckets {
				z.FailedBuckets[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "FailedBuckets", za0001)
					return
				}
			}
		case "bucket":
			z.Bucket, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
			zb0001Mask |= 0x2
		case "object":
			z.Object, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
			zb0001Mask |= 0x4
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.ResyncStatus = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Bucket = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Object = ""
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SiteResyncMetrics) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.ResyncStatus == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Bucket == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.Object == "" {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "collected"
		err = en.Append(0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteTime(z.CollectedAt)
		if err != nil {
			err = msgp.WrapError(err, "CollectedAt")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "resyncStatus"
			err = en.Append(0xac, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
			if err != nil {
				return
			}
			err = en.WriteString(z.ResyncStatus)
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
		}
		// write "startTime"
		err = en.Append(0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.StartTime)
		if err != nil {
			err = msgp.WrapError(err, "StartTime")
			return
		}
		// write "lastUpdate"
		err = en.Append(0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		if err != nil {
			return
		}
		err = en.WriteTime(z.LastUpdate)
		if err != nil {
			err = msgp.WrapError(err, "LastUpdate")
			return
		}
		// write "numBuckets"
		err = en.Append(0xaa, 0x6e, 0x75, 0x6d, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.NumBuckets)
		if err != nil {
			err = msgp.WrapError(err, "NumBuckets")
			return
		}
		// write "resyncID"
		err = en.Append(0xa8, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.ResyncID)
		if err != nil {
			err = msgp.WrapError(err, "ResyncID")
			return
		}
		// write "deplID"
		err = en.Append(0xa6, 0x64, 0x65, 0x70, 0x6c, 0x49, 0x44)
		if err != nil {
			return
		}
		err = en.WriteString(z.DeplID)
		if err != nil {
			err = msgp.WrapError(err, "DeplID")
			return
		}
		// write "completedReplicationSize"
		err = en.Append(0xb8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.ReplicatedSize)
		if err != nil {
			err = msgp.WrapError(err, "ReplicatedSize")
			return
		}
		// write "replicationCount"
		err = en.Append(0xb0, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.ReplicatedCount)
		if err != nil {
			err = msgp.WrapError(err, "ReplicatedCount")
			return
		}
		// write "failedReplicationSize"
		err = en.Append(0xb5, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.FailedSize)
		if err != nil {
			err = msgp.WrapError(err, "FailedSize")
			return
		}
		// write "failedReplicationCount"
		err = en.Append(0xb6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.FailedCount)
		if err != nil {
			err = msgp.WrapError(err, "FailedCount")
			return
		}
		// write "failedBuckets"
		err = en.Append(0xad, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.FailedBuckets)))
		if err != nil {
			err = msgp.WrapError(err, "FailedBuckets")
			return
		}
		for za0001 := range z.FailedBuckets {
			err = en.WriteString(z.FailedBuckets[za0001])
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets", za0001)
				return
			}
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// write "bucket"
			err = en.Append(0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
			if err != nil {
				return
			}
			err = en.WriteString(z.Bucket)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// write "object"
			err = en.Append(0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
			if err != nil {
				return
			}
			err = en.WriteString(z.Object)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SiteResyncMetrics) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(14)
	var zb0001Mask uint16 /* 14 bits */
	_ = zb0001Mask
	if z.ResyncStatus == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Bucket == "" {
		zb0001Len--
		zb0001Mask |= 0x1000
	}
	if z.Object == "" {
		zb0001Len--
		zb0001Mask |= 0x2000
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "collected"
		o = append(o, 0xa9, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64)
		o = msgp.AppendTime(o, z.CollectedAt)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "resyncStatus"
			o = append(o, 0xac, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73)
			o = msgp.AppendString(o, z.ResyncStatus)
		}
		// string "startTime"
		o = append(o, 0xa9, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65)
		o = msgp.AppendTime(o, z.StartTime)
		// string "lastUpdate"
		o = append(o, 0xaa, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65)
		o = msgp.AppendTime(o, z.LastUpdate)
		// string "numBuckets"
		o = append(o, 0xaa, 0x6e, 0x75, 0x6d, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendInt64(o, z.NumBuckets)
		// string "resyncID"
		o = append(o, 0xa8, 0x72, 0x65, 0x73, 0x79, 0x6e, 0x63, 0x49, 0x44)
		o = msgp.AppendString(o, z.ResyncID)
		// string "deplID"
		o = append(o, 0xa6, 0x64, 0x65, 0x70, 0x6c, 0x49, 0x44)
		o = msgp.AppendString(o, z.DeplID)
		// string "completedReplicationSize"
		o = append(o, 0xb8, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt64(o, z.ReplicatedSize)
		// string "replicationCount"
		o = append(o, 0xb0, 0x72, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt64(o, z.ReplicatedCount)
		// string "failedReplicationSize"
		o = append(o, 0xb5, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x69, 0x7a, 0x65)
		o = msgp.AppendInt64(o, z.FailedSize)
		// string "failedReplicationCount"
		o = append(o, 0xb6, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x52, 0x65, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x75, 0x6e, 0x74)
		o = msgp.AppendInt64(o, z.FailedCount)
		// string "failedBuckets"
		o = append(o, 0xad, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x42, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.FailedBuckets)))
		for za0001 := range z.FailedBuckets {
			o = msgp.AppendString(o, z.FailedBuckets[za0001])
		}
		if (zb0001Mask & 0x1000) == 0 { // if not omitted
			// string "bucket"
			o = append(o, 0xa6, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74)
			o = msgp.AppendString(o, z.Bucket)
		}
		if (zb0001Mask & 0x2000) == 0 { // if not omitted
			// string "object"
			o = append(o, 0xa6, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74)
			o = msgp.AppendString(o, z.Object)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SiteResyncMetrics) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 3 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "collected":
			z.CollectedAt, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CollectedAt")
				return
			}
		case "resyncStatus":
			z.ResyncStatus, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResyncStatus")
				return
			}
			zb0001Mask |= 0x1
		case "startTime":
			z.StartTime, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StartTime")
				return
			}
		case "lastUpdate":
			z.LastUpdate, bts, err = msgp.ReadTimeUTCBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LastUpdate")
				return
			}
		case "numBuckets":
			z.NumBuckets, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NumBuckets")
				return
			}
		case "resyncID":
			z.ResyncID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ResyncID")
				return
			}
		case "deplID":
			z.DeplID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DeplID")
				return
			}
		case "completedReplicationSize":
			z.ReplicatedSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedSize")
				return
			}
		case "replicationCount":
			z.ReplicatedCount, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReplicatedCount")
				return
			}
		case "failedReplicationSize":
			z.FailedSize, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedSize")
				return
			}
		case "failedReplicationCount":
			z.FailedCount, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedCount")
				return
			}
		case "failedBuckets":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FailedBuckets")
				return
			}
			if cap(z.FailedBuckets) >= int(zb0002) {
				z.FailedBuckets = (z.FailedBuckets)[:zb0002]
			} else {
				z.FailedBuckets = make([]string, zb0002)
			}
			for za0001 := range z.FailedBuckets {
				z.FailedBuckets[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FailedBuckets", za0001)
					return
				}
			}
		case "bucket":
			z.Bucket, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bucket")
				return
			}
			zb0001Mask |= 0x2
		case "object":
			z.Object, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Object")
				return
			}
			zb0001Mask |= 0x4
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x7 {
		if (zb0001Mask & 0x1) == 0 {
			z.ResyncStatus = ""
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Bucket = ""
		}
		if (zb0001Mask & 0x4) == 0 {
			z.Object = ""
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SiteResyncMetrics) Msgsize() (s int) {
	s = 1 + 10 + msgp.TimeSize + 13 + msgp.StringPrefixSize + len(z.ResyncStatus) + 10 + msgp.TimeSize + 11 + msgp.TimeSize + 11 + msgp.Int64Size + 9 + msgp.StringPrefixSize + len(z.ResyncID) + 7 + msgp.StringPrefixSize + len(z.DeplID) + 25 + msgp.Int64Size + 17 + msgp.Int64Size + 22 + msgp.Int64Size + 23 + msgp.Int64Size + 14 + msgp.ArrayHeaderSize
	for za0001 := range z.FailedBuckets {
		s += msgp.StringPrefixSize + len(z.FailedBuckets[za0001])
	}
	s += 7 + msgp.StringPrefixSize + len(z.Bucket) + 7 + msgp.StringPrefixSize + len(z.Object)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TotalMinMaxUint64) DecodeMsg(dc *msgp.Reader) (err error) {
	var zb0001 uint32
	zb0001, err = dc.ReadArrayHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	z.Total, err = dc.ReadUint64()
	if err != nil {
		err = msgp.WrapError(err, "Total")
		return
	}
	z.Min, err = dc.ReadUint64()
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	z.Max, err = dc.ReadUint64()
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TotalMinMaxUint64) EncodeMsg(en *msgp.Writer) (err error) {
	// array header, size 3
	err = en.Append(0x93)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Total)
	if err != nil {
		err = msgp.WrapError(err, "Total")
		return
	}
	err = en.WriteUint64(z.Min)
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	err = en.WriteUint64(z.Max)
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TotalMinMaxUint64) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// array header, size 3
	o = append(o, 0x93)
	o = msgp.AppendUint64(o, z.Total)
	o = msgp.AppendUint64(o, z.Min)
	o = msgp.AppendUint64(o, z.Max)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TotalMinMaxUint64) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadArrayHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	if zb0001 != 3 {
		err = msgp.ArrayError{Wanted: 3, Got: zb0001}
		return
	}
	z.Total, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Total")
		return
	}
	z.Min, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Min")
		return
	}
	z.Max, bts, err = msgp.ReadUint64Bytes(bts)
	if err != nil {
		err = msgp.WrapError(err, "Max")
		return
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TotalMinMaxUint64) Msgsize() (s int) {
	s = 1 + msgp.Uint64Size + msgp.Uint64Size + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *localF64H) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "counts":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			if cap(z.Counts) >= int(zb0002) {
				z.Counts = (z.Counts)[:zb0002]
			} else {
				z.Counts = make([]uint64, zb0002)
			}
			for za0001 := range z.Counts {
				z.Counts[za0001], err = dc.ReadUint64()
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "buckets":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			if cap(z.Buckets) >= int(zb0003) {
				z.Buckets = (z.Buckets)[:zb0003]
			} else {
				z.Buckets = make([]float64, zb0003)
			}
			for za0002 := range z.Buckets {
				z.Buckets[za0002], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Counts = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Buckets = nil
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *localF64H) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Counts == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Buckets == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// write "counts"
			err = en.Append(0xa6, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Counts)))
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			for za0001 := range z.Counts {
				err = en.WriteUint64(z.Counts[za0001])
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "buckets"
			err = en.Append(0xa7, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
			if err != nil {
				return
			}
			err = en.WriteArrayHeader(uint32(len(z.Buckets)))
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			for za0002 := range z.Buckets {
				err = en.WriteFloat64(z.Buckets[za0002])
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *localF64H) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Counts == nil {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.Buckets == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		if (zb0001Mask & 0x1) == 0 { // if not omitted
			// string "counts"
			o = append(o, 0xa6, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Counts)))
			for za0001 := range z.Counts {
				o = msgp.AppendUint64(o, z.Counts[za0001])
			}
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "buckets"
			o = append(o, 0xa7, 0x62, 0x75, 0x63, 0x6b, 0x65, 0x74, 0x73)
			o = msgp.AppendArrayHeader(o, uint32(len(z.Buckets)))
			for za0002 := range z.Buckets {
				o = msgp.AppendFloat64(o, z.Buckets[za0002])
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *localF64H) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "counts":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Counts")
				return
			}
			if cap(z.Counts) >= int(zb0002) {
				z.Counts = (z.Counts)[:zb0002]
			} else {
				z.Counts = make([]uint64, zb0002)
			}
			for za0001 := range z.Counts {
				z.Counts[za0001], bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Counts", za0001)
					return
				}
			}
			zb0001Mask |= 0x1
		case "buckets":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Buckets")
				return
			}
			if cap(z.Buckets) >= int(zb0003) {
				z.Buckets = (z.Buckets)[:zb0003]
			} else {
				z.Buckets = make([]float64, zb0003)
			}
			for za0002 := range z.Buckets {
				z.Buckets[za0002], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buckets", za0002)
					return
				}
			}
			zb0001Mask |= 0x2
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if zb0001Mask != 0x3 {
		if (zb0001Mask & 0x1) == 0 {
			z.Counts = nil
		}
		if (zb0001Mask & 0x2) == 0 {
			z.Buckets = nil
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *localF64H) Msgsize() (s int) {
	s = 1 + 7 + msgp.ArrayHeaderSize + (len(z.Counts) * (msgp.Uint64Size)) + 8 + msgp.ArrayHeaderSize + (len(z.Buckets) * (msgp.Float64Size))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *nodeCommon) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			z.Addr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Addr")
				return
			}
		case "error":
			z.Error, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.Error = ""
	}

	return
}

// EncodeMsg implements msgp.Encodable
func (z nodeCommon) EncodeMsg(en *msgp.Writer) (err error) {
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// write "addr"
		err = en.Append(0xa4, 0x61, 0x64, 0x64, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.Addr)
		if err != nil {
			err = msgp.WrapError(err, "Addr")
			return
		}
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// write "error"
			err = en.Append(0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			if err != nil {
				return
			}
			err = en.WriteString(z.Error)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z nodeCommon) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// check for omitted fields
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	_ = zb0001Mask
	if z.Error == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))

	// skip if no fields are to be emitted
	if zb0001Len != 0 {
		// string "addr"
		o = append(o, 0xa4, 0x61, 0x64, 0x64, 0x72)
		o = msgp.AppendString(o, z.Addr)
		if (zb0001Mask & 0x2) == 0 { // if not omitted
			// string "error"
			o = append(o, 0xa5, 0x65, 0x72, 0x72, 0x6f, 0x72)
			o = msgp.AppendString(o, z.Error)
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *nodeCommon) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	var zb0001Mask uint8 /* 1 bits */
	_ = zb0001Mask
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "addr":
			z.Addr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Addr")
				return
			}
		case "error":
			z.Error, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Error")
				return
			}
			zb0001Mask |= 0x1
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	// Clear omitted fields.
	if (zb0001Mask & 0x1) == 0 {
		z.Error = ""
	}

	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z nodeCommon) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Addr) + 6 + msgp.StringPrefixSize + len(z.Error)
	return
}
